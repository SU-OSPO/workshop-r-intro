[
  {
    "objectID": "lessons/shell-intro/shell-intro.html",
    "href": "lessons/shell-intro/shell-intro.html",
    "title": "Introduction to the Unix Shell",
    "section": "",
    "text": "What is a command shell and why would I use one?\n\n\nExplain how the shell relates to the keyboard, the screen, the operating system, and users’ programs.\nExplain when and why command-line interfaces should be used instead of graphical interfaces.",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#the-prompt",
    "href": "lessons/shell-intro/shell-intro.html#the-prompt",
    "title": "Introduction to the Unix Shell",
    "section": "The prompt",
    "text": "The prompt\nWhen the shell is first opened, you are presented with a prompt, indicating that the shell is waiting for input.\n$\nThe shell typically uses $ as the prompt, but may use a different symbol. In the examples for this lesson, we’ll show the prompt as $. Most importantly, do not type the prompt when typing commands. Only type the command that follows the prompt. This rule applies both in these lessons and in lessons from other sources. Also note that after you type a command, you have to press the Enter key to execute it.\nThe prompt is followed by a text cursor, a character that indicates the position where your typing will appear. The cursor is usually a flashing or solid block, but it can also be an underscore or a pipe. You may have seen it in a text editor program, for example.\nNote that your prompt might look a little different. In particular, most popular shell environments by default put your user name and the host name before the $. Such a prompt might look like, e.g.:\nsklucas@localhost $\nThe prompt might even include more than this. Do not worry if your prompt is not just a short $. This lesson does not depend on this additional information and it should also not get in your way. The only important item to focus on is the $ character itself and we will see later why.\n\n\n\n\n\n\nOPTIONAL: Change your prompt to $\n\n\n\nIf you’d like to simplify your prompt for the purposes of this tutorial, copy and paste the code below into your terminal:\nPS1='$ '\n\n\nSo let’s try our first command, ls, which is short for listing. This command will list the contents of the current directory:\n$ ls\nDesktop     Downloads   Movies      Pictures\nDocuments   Library     Music       Public\n\n\n\n\n\n\nCommand not found\n\n\n\nIf the shell can’t find a program whose name is the command you typed, it will print an error message such as:\n$ ks\nks: command not found\nThis might happen if the command was mis-typed or if the program corresponding to that command is not installed.\n\n\n\nA Typical Problem\nYou are a marine biologist who has just returned from a six-month survey of the North Pacific Gyre, where you have sampled gelatinous marine life in the Great Pacific Garbage Patch. You have 1520 samples that you’ve run through an assay machine to measure the relative abundance of 300 proteins. You need to run these 1520 files through an imaginary program called goostats.sh. In addition to this huge task, you have to write up results by the end of the month, so your paper can appear in a special issue of Aquatic Goo Letters.\nIf you choose to run goostats.sh by hand using a GUI, you’ll have to select and open a file 1520 times. If goostats.sh takes 30 seconds to run each file, the whole process will take more than 12 hours. With the shell, you can instead assign your computer this mundane task while you focuses her attention on writing your paper.\nThe next few lessons will explore the ways you can achieve this. More specifically, the lessons explain how you can use a command shell to run the goostats.sh program, using loops to automate the repetitive steps of entering file names, so that your computer can work while you write your paper.\nAs a bonus, once you have put a processing pipeline together, you will be able to use it again whenever you collect more data.\nIn order to achieve her task, you need to know how to:\n\nnavigate to a file/directory\ncreate a file/directory\ncheck the length of a file\nchain commands together\nretrieve a set of files\niterate over files\nrun a shell script containing her pipeline\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA shell is a program whose primary purpose is to read commands and run other programs.\nThis lesson uses Bash, the default shell in many implementations of Unix.\nPrograms can be run in Bash by entering commands at the command-line prompt.\nThe shell’s main advantages are its high action-to-keystroke ratio, its support for automating repetitive tasks, and its capacity to access networked machines.\nA significant challenge when using the shell can be knowing what commands need to be run and how to run them.",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#where-am-i",
    "href": "lessons/shell-intro/shell-intro.html#where-am-i",
    "title": "Introduction to the Unix Shell",
    "section": "Where am I?",
    "text": "Where am I?\nFirst, let’s find out where we are by running a command called pwd (which stands for ‘print working directory’). Directories are like places — at any time while we are using the shell, we are in exactly one place called our current working directory. Commands mostly read and write files in the current working directory, i.e. ‘here’, so knowing where you are before running a command is important. pwd shows you where you are:\n$ pwd\n/Users/sklucas\nThe computer’s response is /Users/sklucas, which is my home directory.\n\nThe home directory\nThe home directory will look different on different operating systems.\n\nLinux: /home/sklucas\nWindows: C:\\Users\\sklucas (This may differ based on Windows versions)\n\nIf pwd returns something else, you may need to navigate to your home directory using the command cd.\nLet’s look at how a filesystem is organized:\n\nThe filesystem looks like an upside-down tree. We refer to the topmost directory as the “root directory”. It contains everything else. It is referred to with the / symbol.\nIn this illustration, we have several other directories stemming off of the root. The bin directory often refers to a location where programs are stored. tmp is a common directory on filesystems as a place to hold files that don’t need to be kept long-term. You may recognize the Users directory from the output we had above when typing pwd. We know the path of our home directory, where we currently are, is /Users/sklucas.\n\n\n\n\n\n\nSlashes\n\n\n\nThere are two meanings for the / character. When it appears at the front of a path, it means “root”, when it appears within a path, it acts as a separator.\n\n\n\nThe Users folder may have more than one directory in it. For example, the image below depicts two users, sklucas and Collin. The home directory just as the home directory for sklucas is /Users/sklucas, the home directory for Collin would be /Users/Collin. Typically, when you open a new command prompt, you will start in your home directory by default",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#listing-directory-contents",
    "href": "lessons/shell-intro/shell-intro.html#listing-directory-contents",
    "title": "Introduction to the Unix Shell",
    "section": "Listing directory contents",
    "text": "Listing directory contents\nWe often want to know what a directory contains. To do this, we use the “listing” command ls:\n$ ls\nwhich might return something that looks like this (results will vary):\nApplications  Documents  Library  Music    Public\nDesktop       Downloads  Movies   Pictures  \nls prints the names of the files and directories in your current location. Typing ls -F will give specific notation below based on the\n\nA trailing / indicates that this is a directory\n@ indicates a link\n* indicates an executable\n\nDepending on your shell’s default settings, the shell might also use colors to indicate whether each entry is a file or directory.\n\n\n\n\n\n\nClearing your terminal\n\n\n\nIf your screen gets too cluttered, you can clear your terminal using the clear command. You can still access previous commands using ↑↑ and ↓↓ to move line-by-line, or by scrolling in your terminal.",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#getting-help",
    "href": "lessons/shell-intro/shell-intro.html#getting-help",
    "title": "Introduction to the Unix Shell",
    "section": "Getting help",
    "text": "Getting help\nMost bash commands have help menus that tell the user about how the command is used and what options are available for tailoring the function. There are two common ways to get help with commands, which can differ based on the source of the command (built-in or externally installed), and the operating system.\n\nWe can pass a --help option to any command (on linux and Git Bash).\n$ ls --help\nWe can read the manual on a function using the man command (linux and OSX)\n$ man ls\nTo navigate through the man pages, you may use ↑↑ and ↓↓ to move line-by-line, or try bb and SpacebarSpacebar to skip up and down by a full page. To search for a character or word in the man pages, use // followed by the character or word you are searching for. Sometimes a search will result in multiple hits. If so, you can move between hits using NN (for moving forward) and Shift+NShift+N (for moving backward). To **quit** the man pages, press qq.\n\n\n\n\n\n\n\nBash Built-in commands\n\n\n\nSome commands are built in to the Bash shell, rather than existing as separate programs on the filesystem. One example is the cd “change directory” command. If you get a message like No manual entry for cd, try help cd instead. The help command is how you get usage information for Bash built-ins.",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#command-options",
    "href": "lessons/shell-intro/shell-intro.html#command-options",
    "title": "Introduction to the Unix Shell",
    "section": "Command options",
    "text": "Command options\nWe’ve seen that commands can have many options associated with them, which can control how the command functions. These are often notated by short and long forms that are typically equal in their meaning, but have conventional use in different scenarios.\nWhen options exist as both short and long options:\n\nUse the short option when typing commands directly into the shell to minimize keystrokes and get your task done faster.\nUse the long option in scripts to provide clarity. It will be read many times and typed once.\n\n\n\n\n\n\n\nUnsupported commandline options\n\n\n\nIf you try to use an option that is not supported, ls and other commands will usually print an error message similar to:\n$ ls -j\nMac zsh output:\nls: invalid option -- j\nusage: ls [-@ABCFGHILOPRSTUWXabcdefghiklmnopqrstuvwxy1%,] [--color=when] [-D format] [file ...]\nother Unix output:\nls: invalid option -- 'j'\nTry 'ls --help' for more information.\n\n\n\nChallenge Questions\nExplore the ls command options to answer the following questions:\n\n\n\n\n\n\nQuestion 1: Listing in long, human-readable format\n\n\n\nWhich options for ls produces output in long format that is human readable? (i.e. displaying something like 5.3K instead of 5369)\n\n\n\n\n\n\nSolution\n\n\n\n\n\nthe options -l and -h can be used with ls to make the output long and human readable. You can use them in two ways:\n\nls -l -h\nor string them together ls -lh\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 2: Listing in Reverse Chronological Order\n\n\n\nBy default, ls lists the contents of a directory in alphabetical order by name. The command ls -t lists items by time of last change instead of alphabetically. The command ls -r lists the contents of a directory in reverse order. Which file is displayed last when you combine the -t and -r options? Hint: You may need to use the -l option to see the last changed dates.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe most recently changed file is listed last when using -rt. This can be very useful for finding your most recent edits or checking to see if a new output file was written.",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#exploring-other-directories",
    "href": "lessons/shell-intro/shell-intro.html#exploring-other-directories",
    "title": "Introduction to the Unix Shell",
    "section": "Exploring other directories",
    "text": "Exploring other directories\nNot only can we use ls on the current working directory, but we can use it to list the contents of a different directory. Let’s take a look at our Desktop directory by running ls -F Desktop, i.e., the command ls with the -F option and the argument Desktop. The argument Desktop tells ls that we want a listing of something other than our current working directory:\n$ ls -F Desktop\nYou should see your newly created directory “workshop”\nshell-lesson-data/\nNote that if a directory named Desktop does not exist in your current working directory, this command will return an error. Typically, a Desktop directory exists in your home directory, which we assume is the current working directory of your bash shell.\nYour output should be a list of all the files and sub-directories in your Desktop directory, including the shell-lesson-data directory you downloaded at the setup for this lesson. (On most systems, the contents of the Desktop directory in the shell will show up as icons in a graphical user interface behind all the open windows. See if this is the case for you.)\nOrganizing things hierarchically helps us keep track of our work. While it’s possible to put hundreds of files in our home directory just as it’s possible to pile hundreds of printed papers on our desk, it’s much easier to find things when they’ve been organized into sensibly-named subdirectories.\nNow that we know the shell-lesson-data directory is located in our Desktop directory, we can do two things.\nFirst, using the same strategy as before, we can look at its contents by passing a directory name to ls:\n$ ls -F Desktop/shell-lesson-data\nexercise-data/  north-pacific-gyre/\nSecond, we can actually change our location to a different directory, so we are no longer located in our home directory.\nThe command to change locations is cd followed by a directory name to change our working directory. cd stands for ‘change directory’, which is a bit misleading. The command doesn’t change the directory; it changes the shell’s current working directory. In other words it changes the shell’s settings for what directory we are in. The cd command is akin to double-clicking a folder in a graphical interface to get into that folder.\nLet’s say we want to move into the exercise-data directory we saw above. We can use the following series of commands to get there:\n$ cd Desktop\n$ cd shell-lesson-data\n$ cd exercise-data\nThese commands will move us from our home directory into our Desktop directory, then into the shell-lesson-data directory, then into the exercise-data directory. You will notice that cd doesn’t print anything. This is normal. Many shell commands will not output anything to the screen when successfully executed. But if we run pwd after it, we can see that we are now in /Users/sklucas/Desktop/shell-lesson-data/exercise-data.\nIf we run ls -F without arguments now, it lists the contents of /Users/sklucas/Desktop/shell-lesson-data/exercise-data, because that’s where we now are:\n$ pwd\n/Users/sklucas/Desktop/shell-lesson-data/exercise-data\n$ ls -F\nalkanes/  animal-counts/  creatures/  numbers.txt  writing/\nWe now know how to go down the directory tree (i.e. how to go into a subdirectory), but how do we go up (i.e. how do we leave a directory and go into its parent directory)? We might try the following:\n$ cd shell-lesson-data\n-bash: cd: shell-lesson-data: No such file or directory\nBut we get an error! Why is this?\nWith our methods so far, cd can only see sub-directories inside your current directory. There are different ways to see directories above your current location; we’ll start with the simplest.\nThere is a shortcut in the shell to move up one directory level. It works as follows:\n$ cd ..\n.. is a special directory name meaning “the directory containing this one”, or more succinctly, the parent of the current directory. Sure enough, if we run pwd after running cd .., we’re back in /Users/sklucas/Desktop/shell-lesson-data:\n$ pwd\n/Users/sklucas/Desktop/shell-lesson-data\nThe special directory .. doesn’t usually show up when we run ls. If we want to display it, we can add the -a option to ls -F:\n$ ls -F -a\n./  ../  exercise-data/  north-pacific-gyre/\n-a stands for ‘show all’ (including hidden files); it forces ls to show us file and directory names that begin with ., such as .. (which, if we’re in /Users/sklucas, refers to the /Users directory). As you can see, it also displays another special directory that’s just called ., which means ‘the current working directory’. It may seem redundant to have a name for it, but we’ll see some uses for it soon.\nNote that in most command line tools, multiple options can be combined with a single - and no spaces between the options; ls -F -a is equivalent to ls -Fa.\n\n\n\n\n\n\nOther Hidden Files\n\n\n\nIn addition to the hidden directories .. and ., you may also see a file called .bash_profile. This file usually contains shell configuration settings. You may also see other files and directories beginning with .. These are usually files and directories that are used to configure different programs on your computer. The prefix . is used to prevent these configuration files from cluttering the terminal when a standard ls command is used.\n\n\nThese three commands are the basic commands for navigating the filesystem on your computer: pwd, ls, and cd. Let’s explore some variations on those commands. What happens if you type cd on its own, without giving a directory?\n$ cd\nHow can you check what happened? pwd gives us the answer!\n$ pwd\n/Users/sklucas\nIt turns out that cd without an argument will return you to your home directory, which is great if you’ve got lost in your own filesystem.\nLet’s try returning to the exercise-data directory from before. Last time, we used three commands, but we can actually string together the list of directories to move to exercise-data in one step:\n$ cd Desktop/shell-lesson-data/exercise-data\nCheck that we’ve moved to the right place by running pwd and ls -F.\nIf we want to move up one level from the data directory, we could use cd ... But there is another way to move to any directory, regardless of your current location.\nSo far, when specifying directory names, or even a directory path (as above), we have been using relative paths. When you use a relative path with a command like ls or cd, it tries to find that location from where we are, rather than from the root of the file system.\nHowever, it is possible to specify the absolute path to a directory by including its entire path from the root directory, which is indicated by a leading slash. The leading / tells the computer to follow the path from the root of the file system, so it always refers to exactly one directory, no matter where we are when we run the command.\nThis allows us to move to our shell-lesson-data directory from anywhere on the filesystem (including from inside exercise-data). To find the absolute path we’re looking for, we can use pwd and then extract the piece we need to move to shell-lesson-data.\n$ pwd\n/Users/sklucas/Desktop/shell-lesson-data/exercise-data\n$ cd /Users/sklucas/Desktop/shell-lesson-data\nRun pwd and ls -F to ensure that we’re in the directory we expect.\n\n\n\n\n\n\nTwo more shortcuts\n\n\n\nThe shell interprets a tilde (~) character at the start of a path to mean “the current user’s home directory”. For example, if your home directory is /Users/sklucas, then ~/data is equivalent to /Users/sklucas/data. This only works if it is the first character in the path; here/there/~/elsewhere is not here/there/Users/sklucas/elsewhere.\nAnother shortcut is the - (dash) character. cd will translate - into the previous directory I was in, which is faster than having to remember, then type, the full path. This is a very efficient way of moving back and forth between two directories – i.e. if you execute cd - twice, you end up back in the starting directory.\nThe difference between cd .. and cd - is that the former brings you up, while the latter brings you back.\n\nTry it!\nFirst navigate to ~/Desktop/shell-lesson-data (you should already be there).\n$ cd ~/Desktop/shell-lesson-data\nThen cd into the exercise-data/creatures directory\n$ cd exercise-data/creatures\nNow if you run\n$ cd -\nyou’ll see you’re back in ~/Desktop/shell-lesson-data. Run cd - again and you’re back in ~/Desktop/shell-lesson-data/exercise-data/creatures\n\n\n\n\nChallenge Questions\n\n\n\n\n\n\nQuestion 3: Absolute vs Relative Paths\n\n\n\nStarting from /Users/sklucas/data, which of the following commands could sklucas use to navigate to her home directory, which is /Users/sklucas?\n\ncd .\ncd /\ncd /home/sklucas\ncd ../..\ncd ~\ncd home\ncd ~/data/..\ncd\ncd ..\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: . stands for the current directory.\nNo: / stands for the root directory.\nNo: sklucas’s home directory is /Users/sklucas.\nNo: this command goes up two levels, i.e. ends in /Users.\nYes: ~ stands for the user’s home directory, in this case /Users/sklucas.\nNo: this command would navigate into a directory home in the current directory if it exists.\nYes: unnecessarily complicated, but correct.\nYes: shortcut to go back to the user’s home directory.\nYes: goes up one level.\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 4: Relative Path Resolution\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/thing, what will ls -F ../backup display?\n\n\n../backup: No such file or directory\n2012-12-01 2013-01-08 2013-01-27\n2012-12-01/ 2013-01-08/ 2013-01-27/\noriginal/ pnas_final/ pnas_sub/\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: there is a directory backup in /Users.\nNo: this is the content of Users/thing/backup, but with .., we asked for one level further up.\nNo: see previous explanation.\nYes: ../backup/ refers to /Users/backup/.\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 4: ls reading comprehension\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/backup, and -r tells ls to display things in reverse order, what command(s) will result in the following output:\npnas_sub/ pnas_final/ original/\n\n\nls pwd\nls -r -F\nls -r -F /Users/backup\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: pwd is not the name of a directory.\nYes: ls without directory argument lists files and directories in the current directory.\nYes: uses the absolute path explicitly.",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#general-syntax-of-a-shell-command",
    "href": "lessons/shell-intro/shell-intro.html#general-syntax-of-a-shell-command",
    "title": "Introduction to the Unix Shell",
    "section": "General Syntax of a Shell Command",
    "text": "General Syntax of a Shell Command\nWe have now encountered commands, options, and arguments, but it is perhaps useful to formalise some terminology.\nConsider the command below as a general example of a command, which we will dissect into its component parts:\n$ ls -F /\n\nls is the command, with an option -F and an argument /. We’ve already encountered options which either start with a single dash (-), known as short options, or two dashes (--), known as long options. Options change the behavior of a command and arguments tell the command what to operate on (e.g. files and directories). Sometimes options and arguments are referred to as parameters. A command can be called with more than one option and more than one argument, but a command doesn’t always require an argument or an option.\nYou might sometimes see options being referred to as switches or flags, especially for options that take no argument. In this lesson we will stick with using the term option.\nEach part is separated by spaces. If you omit the space between ls and -F the shell will look for a command called ls-F, which doesn’t exist. Also, capitalization can be important. For example, ls -s will display the size of files and directories alongside the names, while ls -S will sort the files and directories by size, as shown below:\n$ cd ~/Desktop/shell-lesson-data\n$ ls -s exercise-data\ntotal 28\n 4 animal-counts   4 creatures  12 numbers.txt   4 alkanes   4 writing\nNote that the sizes returned by ls -s are in blocks. As these are defined differently for different operating systems, you may not obtain the same figures as in the example.\n$ ls -S exercise-data\nanimal-counts  creatures  alkanes  writing  numbers.txt\nPutting all that together, our command ls -F / above gives us a listing of files and directories in the root directory /. An example of the output you might get from the above command is given below:\n$ ls -F /\nApplications/         System/\nLibrary/              Users/\nNetwork/              Volumes/\n\nYour Task: Organizing Files\nKnowing this much about files and directories, You are ready to organize the files that the protein assay machine will create.\nYou create a directory called north-pacific-gyre (to remind yourself where the data came from), which will contain the data files from the assay machine and your data processing scripts.\nEach of your physical samples is labelled according to your lab’s convention with a unique ten-character ID, such as ‘NENE01729A’. This ID is what you used in your collection log to record the location, time, depth, and other characteristics of the sample, so you decide to use it within the filename of each data file. Since the output of the assay machine is plain text, you will call your files NENE01729A.txt, NENE01812A.txt, and so on. All 1520 files will go into the same directory.\nNow in your current directory shell-lesson-data, you can see what files you have using the command:\n$ ls north-pacific-gyre/\nThis command is a lot to type, but you can let the shell do most of the work through what is called tab completion. If you types:\n$ ls nor\nand then presses Tab (the tab key on her keyboard), the shell automatically completes the directory name for you:\n$ ls north-pacific-gyre/\nPressing Tab again does nothing, since there are multiple possibilities; pressing Tab twice brings up a list of all the files.\nIf you then presses G and then presses Tab again, the shell will append ‘goo’ since all files that start with ‘g’ share the first three characters ‘goo’.\n$ ls north-pacific-gyre/goo\nTo see all of those files, you can press Tab twice more.\nls north-pacific-gyre/goo\ngoodiff.sh   goostats.sh\nThis is called tab completion, and we will see it in many other tools as we go on.\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nThe file system is responsible for managing information on the disk.\nInformation is stored in files, which are stored in directories (folders).\nDirectories can also store other directories, which then form a directory tree.\npwd prints the user’s current working directory.\nls [path] prints a listing of a specific file or directory; ls on its own lists the current working directory.\ncd [path] changes the current working directory.\nMost commands take options that begin with a single -.\nDirectory names in a path are separated with / on Unix, but \\ on Windows.\n/ on its own is the root directory of the whole file system.\nAn absolute path specifies a location from the root of the file system.\nA relative path specifies a location starting from the current location.\n. on its own means ‘the current directory’; .. means ‘the directory above the current one’.",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#creating-directories-and-files",
    "href": "lessons/shell-intro/shell-intro.html#creating-directories-and-files",
    "title": "Introduction to the Unix Shell",
    "section": "Creating Directories and Files",
    "text": "Creating Directories and Files\nWe now know how to explore files and directories, but how do we create them in the first place?\nIn this episode we will learn about creating and moving files and directories, using the exercise-data/writing directory as an example.\n\nStep one: see where we are and what we already have\nWe should still be in the shell-lesson-data directory on the Desktop, which we can check using:\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data\nNext we’ll move to the exercise-data/writing directory and see what it contains:\n$ cd exercise-data/writing/\n$ ls -F\nhaiku.txt  LittleWomen.txt\n\n\nCreate a directory\nLet’s create a new directory called thesis using the command mkdir thesis (which has no output):\n$ mkdir thesis\nAs you might guess from its name, mkdir means ‘make directory’. Since thesis is a relative path (i.e., does not have a leading slash, like /what/ever/thesis), the new directory is created in the current working directory:\n$ ls -F\nhaiku.txt  LittleWomen.txt  thesis/\nSince we’ve just created the thesis directory, there’s nothing in it yet:\n$ ls -F thesis\nNote that mkdir is not limited to creating single directories one at a time. The -p option allows mkdir to create a directory with nested subdirectories in a single operation:\n$ mkdir -p ../project/data ../project/results\nThe -R option to the ls command will list all nested subdirectories within a directory. Let’s use ls -FR to recursively list the new directory hierarchy we just created in the project directory:\n$ ls -FR ../project\n../project/:\ndata/  results/\n\n../project/data:\n\n../project/results:\n\n\n\n\n\n\nTwo ways of doing the same thing\n\n\n\nUsing the shell to create a directory is no different than using a file explorer. If you open the current directory using your operating system’s graphical file explorer, the thesis directory will appear there too. While the shell and the file explorer are two different ways of interacting with the files, the files and directories themselves are the same.\n\n\n\n\n\n\n\n\nGood names for files and directories\n\n\n\nComplicated names of files and directories can make your life painful when working on the command line. Here we provide a few useful tips for the names of your files and directories.\n\nDon’t use spaces.\n\nSpaces can make a name more meaningful, but since spaces are used to separate arguments on the command line it is better to avoid them in names of files and directories. You can use - or _ instead (e.g. north-pacific-gyre/ rather than north pacific gyre/). To test this out, try typing mkdir north pacific gyre and see what directory (or directories!) are made when you check with ls -F.\n\nDon’t begin the name with - (dash).\n\nCommands treat names starting with - as options.\n\nStick with letters, numbers, . (period or ‘full stop’), - (dash) and _ (underscore).\n\nMany other characters have special meanings on the command line. We will learn about some of these during this lesson. There are special characters that can cause your command to not work as expected and can even result in data loss.\nIf you need to refer to names of files or directories that have spaces or other special characters, you should surround the name in single quotes ('').\n\n\n\n\nCreate a text file\nLet’s change our working directory to thesis using cd, then run a text editor called Nano to create a file called draft.txt:\n$ cd thesis\n$ nano draft.txt\n\n\n\n\n\n\nWhich editor?\n\n\n\nWhen we say, ‘nano is a text editor’ we really do mean ‘text’. It can only work with plain character data, not tables, images, or any other human-friendly media. We use it in examples because it is one of the least complex text editors. However, because of this trait, it may not be powerful enough or flexible enough for the work you need to do after this workshop. On Unix systems (such as Linux and macOS), many programmers use Emacs or Vim (both of which require more time to learn), or a graphical editor such as Gedit or VScode. On Windows, you may wish to use Notepad++. Windows also has a built-in editor called notepad that can be run from the command line in the same way as nano for the purposes of this lesson.\nNo matter what editor you use, you will need to know where it searches for and saves files. If you start it from the shell, it will (probably) use your current working directory as its default location. If you use your computer’s start menu, it may want to save files in your Desktop or Documents directory instead. You can change this by navigating to another directory the first time you ‘Save As…’\n\n\nLet’s type a few lines of text:\n\nOnce we’re happy with our text, we can press Ctrl+O (press the Ctrl or Control key and, while holding it down, press the O key) to write our data to disk. We will be asked to provide a name for the file that will contain our text. Press Return to accept the suggested default of draft.txt.\nOnce our file is saved, we can use Ctrl+X to quit the editor and return to the shell.\n\n\n\n\n\n\nControl, Ctrl, or ^ Key\n\n\n\nThe Control key is also called the ‘Ctrl’ key. There are various ways in which using the Control key may be described. For example, you may see an instruction to press the Control key and, while holding it down, press the X key, described as any of:\n\nControl-X\nControl+X\nCtrl-X\nCtrl+X\n^X\nC-x\n\nIn nano, along the bottom of the screen you’ll see ^G Get Help ^O WriteOut. This means that you can use Control-G to get help and Control-O to save your file.\n\n\nnano doesn’t leave any output on the screen after it exits, but ls now shows that we have created a file called draft.txt:\n$ ls\ndraft.txt\n\n\n\n\n\n\nChallenge: Creating Files a Different Way\n\n\n\nWe have seen how to create text files using the nano editor. Now, try the following command:\n$ touch my_file.txt\n\nWhat did the touch command do? When you look at your current directory using the GUI file explorer, does the file show up?\nUse ls -l to inspect the files. How large is my_file.txt?\nWhen might you want to create a file this way?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThe touch command generates a new file called my_file.txt in your current directory. You can observe this newly generated file by typing ls at the command line prompt. my_file.txt can also be viewed in your GUI file explorer.\nWhen you inspect the file with ls -l, note that the size of my_file.txt is 0 bytes. In other words, it contains no data. If you open my_file.txt using your text editor it is blank.\nSome programs do not generate output files themselves, but instead require that empty files have already been generated. When the program is run, it searches for an existing file to populate with its output. The touch command allows you to efficiently generate a blank text file to be used by such programs.\n\n\n\n\nTo avoid confusion later on, we suggest removing the file you’ve just created before proceeding with the rest of the episode, otherwise future outputs may vary from those given in the lesson. To do this, use the following command:\n$ rm my_file.txt\n\n\n\nWhat’s in a name?\nYou may have noticed that all of your files are named ‘something dot something’, and in this part of the lesson, we always used the extension .txt. This is just a convention; we can call a file mythesis or almost anything else we want. However, most people use two-part names most of the time to help them (and their programs) tell different kinds of files apart. The second part of such a name is called the filename extension and indicates what type of data the file holds: .txt signals a plain text file, .pdf indicates a PDF document, .cfg is a configuration file full of parameters for some program or other, .png is a PNG image, and so on.\nThis is just a convention, albeit an important one. Files merely contain bytes; it’s up to us and our programs to interpret those bytes according to the rules for plain text files, PDF documents, configuration files, images, and so on.\nNaming a PNG image of a whale as whale.mp3 doesn’t somehow magically turn it into a recording of whale song, though it might cause the operating system to associate the file with a music player program. In this case, if someone double-clicked whale.mp3 in a file explorer program, the music player will automatically (and erroneously) attempt to open the whale.mp3 file.",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#moving-files-and-directories",
    "href": "lessons/shell-intro/shell-intro.html#moving-files-and-directories",
    "title": "Introduction to the Unix Shell",
    "section": "Moving Files and Directories",
    "text": "Moving Files and Directories\nReturning to the shell-lesson-data/exercise-data/writing directory,\n$ cd ~/Desktop/shell-lesson-data/exercise-data/writing\nIn our thesis directory we have a file draft.txt which isn’t a particularly informative name, so let’s change the file’s name using mv, which is short for ‘move’:\n$ mv thesis/draft.txt thesis/quotes.txt\nThe first argument tells mv what we’re ‘moving’, while the second is where it’s to go. In this case, we’re moving thesis/draft.txt to thesis/quotes.txt, which has the same effect as renaming the file. Sure enough, ls shows us that thesis now contains one file called quotes.txt:\n$ ls thesis\nquotes.txt\nOne must be careful when specifying the target file name, since mv will silently overwrite any existing file with the same name, which could lead to data loss. By default, mv will not ask for confirmation before overwriting files. However, an additional option, mv -i (or mv --interactive), will cause mv to request such confirmation.\nNote that mv also works on directories.\nLet’s move quotes.txt into the current working directory. We use mv once again, but this time we’ll use just the name of a directory as the second argument to tell mv that we want to keep the filename but put the file somewhere new. (This is why the command is called ‘move’.) In this case, the directory name we use is the special directory name . that we mentioned earlier.\n$ mv thesis/quotes.txt .\nThe effect is to move the file from the directory it was in to the current working directory. ls now shows us that thesis is empty:\n$ ls thesis\n$\nAlternatively, we can confirm the file quotes.txt is no longer present in the thesis directory by explicitly trying to list it:\n$ ls thesis/quotes.txt\nls: cannot access 'thesis/quotes.txt': No such file or directory\nls with a filename or directory as an argument only lists the requested file or directory. If the file given as the argument doesn’t exist, the shell returns an error as we saw above. We can use this to see that quotes.txt is now present in our current directory:\n$ ls quotes.txt\nquotes.txt\n\n\n\n\n\n\nChallenge: Moving files to a new folder\n\n\n\nAfter running the following commands, Jamie realizes that she put the files sucrose.dat and maltose.dat into the wrong folder. The files should have been placed in the raw folder.\n$ ls -F\n analyzed/ raw/\n$ ls -F analyzed\nfructose.dat glucose.dat maltose.dat sucrose.dat\n$ cd analyzed\nFill in the blanks to move these files to the raw/ folder (i.e. the one she forgot to put them in)\n$ mv sucrose.dat maltose.dat ____/____\n\n\n\n\n\n\nSolution\n\n\n\n\n\n$ mv sucrose.dat maltose.dat ../raw\nRecall that .. refers to the parent directory (i.e. one above the current directory) and that . refers to the current directory.",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#copying-files-and-directories",
    "href": "lessons/shell-intro/shell-intro.html#copying-files-and-directories",
    "title": "Introduction to the Unix Shell",
    "section": "Copying Files and Directories",
    "text": "Copying Files and Directories\nThe cp command works very much like mv, except it copies a file instead of moving it. We can check that it did the right thing using ls with two paths as arguments — like most Unix commands, ls can be given multiple paths at once:\n$ cp quotes.txt thesis/quotations.txt\n$ ls quotes.txt thesis/quotations.txt\nquotes.txt   thesis/quotations.txt\nWe can also copy a directory and all its contents by using the recursive option -r, e.g. to back up a directory:\n$ cp -r thesis thesis_backup\nWe can check the result by listing the contents of both the thesis and thesis_backup directory:\n$ ls thesis thesis_backup\nthesis:\nquotations.txt\n\nthesis_backup:\nquotations.txt\nIt is important to include the -r flag. If you want to copy a directory and you omit this option you will see a message that the directory has been omitted because -r not specified.\n$ cp thesis thesis_backup\ncp: -r not specified; omitting directory 'thesis'\n\n\n\n\n\n\nChallenge: Renaming files\n\n\n\nSuppose that you created a plain-text file in your current directory to contain a list of the statistical tests you will need to do to analyze your data, and named it statstics.txt\nAfter creating and saving this file you realize you misspelled the filename! You want to correct the mistake, which of the following commands could you use to do so?\n\ncp statstics.txt statistics.txt\nmv statstics.txt statistics.txt\nmv statstics.txt .\ncp statstics.txt .\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo. While this would create a file with the correct name, the incorrectly named file still exists in the directory and would need to be deleted.\nYes, this would work to rename the file.\nNo, the period(.) indicates where to move the file, but does not provide a new file name; identical file names cannot be created.\nNo, the period(.) indicates where to copy the file, but does not provide a new file name; identical file names cannot be created.\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge: Moving and copying\n\n\n\nWhat is the output of the closing ls command in the sequence shown below?\n$ pwd\n/Users/jamie/data\n$ ls\nproteins.dat\n$ mkdir recombined\n$ mv proteins.dat recombined/\n$ cp recombined/proteins.dat ../proteins-saved.dat\n$ ls\n\nproteins-saved.dat recombined\nrecombined\nproteins.dat recombined\nproteins-saved.dat\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe start in the /Users/jamie/data directory, and create a new folder called recombined. The second line moves (mv) the file proteins.dat to the new folder (recombined). The third line makes a copy of the file we just moved. The tricky part here is where the file was copied to. Recall that .. means ‘go up a level’, so the copied file is now in /Users/jamie. Notice that .. is interpreted with respect to the current working directory, not with respect to the location of the file being copied. So, the only thing that will show using ls (in /Users/jamie/data) is the recombined folder.\n\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie\nYes\nNo, see explanation above. proteins.dat is located at /Users/jamie/data/recombined\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#removing-files-and-directories",
    "href": "lessons/shell-intro/shell-intro.html#removing-files-and-directories",
    "title": "Introduction to the Unix Shell",
    "section": "Removing files and directories",
    "text": "Removing files and directories\nReturning to the shell-lesson-data/exercise-data/writing directory, let’s tidy up this directory by removing the quotes.txt file we created. The Unix command we’ll use for this is rm (short for ‘remove’):\n$ rm quotes.txt\nWe can confirm the file has gone using ls:\n$ ls quotes.txt\nls: cannot access 'quotes.txt': No such file or directory\n\n\n\n\n\n\nDeleting is forever\n\n\n\nThe Unix shell doesn’t have a trash bin that we can recover deleted files from (though most graphical interfaces to Unix do). Instead, when we delete files, they are unlinked from the file system so that their storage space on disk can be recycled. Tools for finding and recovering deleted files do exist, but there’s no guarantee they’ll work in any particular situation, since the computer may recycle the file’s disk space right away.\n\n\n\n\n\n\n\n\nChallenge: Using rm Safely\n\n\n\nWhat happens when we execute rm -i thesis_backup/quotations.txt? Why would we want this protection when using rm?\n\n\n\n\n\n\nSolution\n\n\n\n\n\nrm: remove regular file 'thesis_backup/quotations.txt'? y\nThe -i option will prompt before (every) removal (use Y to confirm deletion or N to keep the file). The Unix shell doesn’t have a trash bin, so all the files removed will disappear forever. By using the -i option, we have the chance to check that we are deleting only the files that we want to remove.\n\n\n\n\n\nIf we try to remove the thesis directory using rm thesis, we get an error message:\n$ rm thesis\nrm: cannot remove 'thesis': Is a directory\nThis happens because rm by default only works on files, not directories.\nrm can remove a directory and all its contents if we use the recursive option -r, and it will do so without any confirmation prompts:\n$ rm -r thesis\nGiven that there is no way to retrieve files deleted using the shell, rm -r should be used with great caution (you might consider adding the interactive option rm -r -i).",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#operations-with-multiple-filenames",
    "href": "lessons/shell-intro/shell-intro.html#operations-with-multiple-filenames",
    "title": "Introduction to the Unix Shell",
    "section": "Operations with Multiple Filenames",
    "text": "Operations with Multiple Filenames\nOftentimes one needs to copy or move several files at once. This can be done by providing a list of individual filenames, or specifying a naming pattern using wildcards. Wildcards are special characters that can be used to represent unknown characters or sets of characters when navigating the Unix file system.\n\n\n\n\n\n\nChallenge: Copy with Multiple Filenames\n\n\n\nFor this exercise, you can test the commands in the shell-lesson-data/exercise-data directory.\nIn the example below, what does cp do when given several filenames and a directory name?\n$ mkdir backup\n$ cp creatures/minotaur.dat creatures/unicorn.dat backup/\nIn the example below, what does cp do when given three or more file names?\n$ cd creatures\n$ ls -F\nbasilisk.dat  minotaur.dat  unicorn.dat\n$ cp minotaur.dat unicorn.dat basilisk.dat\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIf given more than one file name followed by a directory name (i.e. the destination directory must be the last argument), cp copies the files to the named directory.\nIf given three file names, cp throws an error such as the one below, because it is expecting a directory name as the last argument.\ncp: target 'basilisk.dat' is not a directory",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#using-wildcards-for-accessing-multiple-files-at-once",
    "href": "lessons/shell-intro/shell-intro.html#using-wildcards-for-accessing-multiple-files-at-once",
    "title": "Introduction to the Unix Shell",
    "section": "Using Wildcards for Accessing Multiple Files at Once",
    "text": "Using Wildcards for Accessing Multiple Files at Once\n* is a wildcard, which represents zero or more other characters. Let’s consider the shell-lesson-data/exercise-data/alkanes directory: *.pdb represents ethane.pdb, propane.pdb, and every file that ends with ‘.pdb’. On the other hand, p*.pdb only represents pentane.pdb and propane.pdb, because the ‘p’ at the front can only represent filenames that begin with the letter ‘p’.\n? is also a wildcard, but it represents exactly one character. So ?ethane.pdb could represent methane.pdb whereas *ethane.pdb represents both ethane.pdb and methane.pdb.\nWildcards can be used in combination with each other. For example, ???ane.pdb indicates three characters followed by ane.pdb, giving cubane.pdb  ethane.pdb  octane.pdb.\nWhen the shell sees a wildcard, it expands the wildcard to create a list of matching filenames before running the preceding command. As an exception, if a wildcard expression does not match any file, Bash will pass the expression as an argument to the command as it is. For example, typing ls *.pdf in the alkanes directory (which contains only files with names ending with .pdb) results in an error message that there is no file called *.pdf. However, generally commands like wc and ls see the lists of file names matching these expressions, but not the wildcards themselves. It is the shell, not the other programs, that expands the wildcards.\n\n\n\n\n\n\nChallenge: List filenames matching a pattern\n\n\n\nWhen run in the alkanes directory, which ls command(s) will produce this output?\nethane.pdb   methane.pdb\n\nls *t*ane.pdb\nls *t?ne.*\nls *t??ne.pdb\nls ethane.*\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe solution is 3.\n1. shows all files whose names contain zero or more characters (*) followed by the letter t, then zero or more characters (*) followed by ane.pdb. This gives ethane.pdb  methane.pdb  octane.pdb  pentane.pdb.\n2. shows all files whose names start with zero or more characters (*) followed by the letter t, then a single character (?), then ne. followed by zero or more characters (*). This will give us octane.pdb and pentane.pdb but doesn’t match anything which ends in thane.pdb.\n3. fixes the problems of option 2 by matching two characters (??) between t and ne. This is the solution.\n4. only shows files starting with ethane..\n\n\n\n\n\n\n\n\n\n\n\nChallenge: More on wildcards\n\n\n\nSam has a directory containing calibration data, datasets, and descriptions of the datasets:\n.\n├── 2015-10-23-calibration.txt\n├── 2015-10-23-dataset1.txt\n├── 2015-10-23-dataset2.txt\n├── 2015-10-23-dataset_overview.txt\n├── 2015-10-26-calibration.txt\n├── 2015-10-26-dataset1.txt\n├── 2015-10-26-dataset2.txt\n├── 2015-10-26-dataset_overview.txt\n├── 2015-11-23-calibration.txt\n├── 2015-11-23-dataset1.txt\n├── 2015-11-23-dataset2.txt\n├── 2015-11-23-dataset_overview.txt\n├── backup\n│   ├── calibration\n│   └── datasets\n└── send_to_bob\n    ├── all_datasets_created_on_a_23rd\n    └── all_november_files\nBefore heading off to another field trip, she wants to back up her data and send some datasets to her colleague Bob. Sam uses the following commands to get the job done:\n$ cp *dataset* backup/datasets\n$ cp ____calibration____ backup/calibration\n$ cp 2015-____-____ send_to_bob/all_november_files/\n$ cp ____ send_to_bob/all_datasets_created_on_a_23rd/\nHelp Sam by filling in the blanks.\nThe resulting directory structure should look like this\n.\n├── 2015-10-23-calibration.txt\n├── 2015-10-23-dataset1.txt\n├── 2015-10-23-dataset2.txt\n├── 2015-10-23-dataset_overview.txt\n├── 2015-10-26-calibration.txt\n├── 2015-10-26-dataset1.txt\n├── 2015-10-26-dataset2.txt\n├── 2015-10-26-dataset_overview.txt\n├── 2015-11-23-calibration.txt\n├── 2015-11-23-dataset1.txt\n├── 2015-11-23-dataset2.txt\n├── 2015-11-23-dataset_overview.txt\n├── backup\n│   ├── calibration\n│   │   ├── 2015-10-23-calibration.txt\n│   │   ├── 2015-10-26-calibration.txt\n│   │   └── 2015-11-23-calibration.txt\n│   └── datasets\n│       ├── 2015-10-23-dataset1.txt\n│       ├── 2015-10-23-dataset2.txt\n│       ├── 2015-10-23-dataset_overview.txt\n│       ├── 2015-10-26-dataset1.txt\n│       ├── 2015-10-26-dataset2.txt\n│       ├── 2015-10-26-dataset_overview.txt\n│       ├── 2015-11-23-dataset1.txt\n│       ├── 2015-11-23-dataset2.txt\n│       └── 2015-11-23-dataset_overview.txt\n└── send_to_bob\n    ├── all_datasets_created_on_a_23rd\n    │   ├── 2015-10-23-dataset1.txt\n    │   ├── 2015-10-23-dataset2.txt\n    │   ├── 2015-10-23-dataset_overview.txt\n    │   ├── 2015-11-23-dataset1.txt\n    │   ├── 2015-11-23-dataset2.txt\n    │   └── 2015-11-23-dataset_overview.txt\n    └── all_november_files\n        ├── 2015-11-23-calibration.txt\n        ├── 2015-11-23-dataset1.txt\n        ├── 2015-11-23-dataset2.txt\n        └── 2015-11-23-dataset_overview.txt\n\n\n\n\n\n\nSolution\n\n\n\n\n\n$ cp *calibration.txt backup/calibration\n$ cp 2015-11-* send_to_bob/all_november_files/\n$ cp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/\n\n\n\n\n\n\n\n\n\n\n\nChallenge: Organizing directories and files\n\n\n\nJamie is working on a project, and she sees that her files aren’t very well organized:\n$ ls -F\nanalyzed/  fructose.dat    raw/   sucrose.dat\nThe fructose.dat and sucrose.dat files contain output from her data analysis. What command(s) covered in this lesson does she need to run so that the commands below will produce the output shown?\n$ ls -F\nanalyzed/   raw/\n$ ls analyzed\nfructose.dat    sucrose.dat\n\n\n\n\n\n\nSolution\n\n\n\n\n\nmv *.dat analyzed\nJamie needs to move her files fructose.dat and sucrose.dat to the analyzed directory. The shell will expand *.dat to match all .dat files in the current directory. The mv command then moves the list of .dat files to the ‘analyzed’ directory.\n\n\n\n\n\n\n\n\n\n\n\nChallenge: Reproduce a folder structure\n\n\n\nYou’re starting a new experiment and would like to duplicate the directory structure from your previous experiment so you can add new data.\nAssume that the previous experiment is in a folder called 2016-05-18, which contains a data folder that in turn contains folders named raw and processed that contain data files. The goal is to copy the folder structure of the 2016-05-18 folder into a folder called 2016-05-20 so that your final directory structure looks like this:\n2016-05-20/\n└── data\n   ├── processed\n   └── raw\nWhich of the following set of commands would achieve this objective? What would the other commands do?\n$ mkdir 2016-05-20\n$ mkdir 2016-05-20/data\n$ mkdir 2016-05-20/data/processed\n$ mkdir 2016-05-20/data/raw\n$ mkdir 2016-05-20\n$ cd 2016-05-20\n$ mkdir data\n$ cd data\n$ mkdir raw processed\n$ mkdir 2016-05-20/data/raw\n$ mkdir 2016-05-20/data/processed\n$ mkdir -p 2016-05-20/data/raw\n$ mkdir -p 2016-05-20/data/processed\n$ mkdir 2016-05-20\n$ cd 2016-05-20\n$ mkdir data\n$ mkdir raw processed\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe first two sets of commands achieve this objective. The first set uses relative paths to create the top-level directory before the subdirectories.\nThe third set of commands will give an error because the default behavior of mkdir won’t create a subdirectory of a non-existent directory: the intermediate level folders must be created first.\nThe fourth set of commands achieve this objective. Remember, the -p option, followed by a path of one or more directories, will cause mkdir to create any intermediate subdirectories as required.\nThe final set of commands generates the ‘raw’ and ‘processed’ directories at the same level as the ‘data’ directory.\n\n\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\ncp [old] [new] copies a file.\nmkdir [path] creates a new directory.\nmv [old] [new] moves (renames) a file or directory.\nrm [path] removes (deletes) a file.\n* matches zero or more characters in a filename, so *.txt matches all files ending in .txt.\n? matches any single character in a filename, so ?.txt matches a.txt but not any.txt.\nUse of the Control key may be described in many ways, including Ctrl-X, Control-X, and ^X.\nThe shell does not have a trash bin: once something is deleted, it’s really gone.\nMost files’ names are something.extension. The extension isn’t required, and doesn’t guarantee anything, but is normally used to indicate the type of data in the file.\nDepending on the type of work you do, you may need a more powerful text editor than Nano.",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#capturing-output-from-commands",
    "href": "lessons/shell-intro/shell-intro.html#capturing-output-from-commands",
    "title": "Introduction to the Unix Shell",
    "section": "Capturing output from commands",
    "text": "Capturing output from commands\n\nOutput page by page with less\nWe’ll continue to use cat in this lesson, for convenience and consistency, but it has the disadvantage that it always dumps the whole file onto your screen. More useful in practice is the command less (e.g. less lengths.txt). This displays a screenful of the file, and then stops. You can go forward one screenful by pressing the spacebar, or back one by pressing b. Press q to quit.\nWhich of these files contains the fewest lines? It’s an easy question to answer when there are only six files, but what if there were 6000? Our first step toward a solution is to run the command:\n$ wc -l *.pdb &gt; lengths.txt\nThe greater than symbol, &gt;, tells the shell to redirect the command’s output to a file instead of printing it to the screen. This command prints no screen output, because everything that wc would have printed has gone into the file lengths.txt instead. If the file doesn’t exist prior to issuing the command, the shell will create the file. If the file exists already, it will be silently overwritten, which may lead to data loss. Thus, redirect commands require caution.\nls lengths.txt confirms that the file exists:\n$ ls lengths.txt\nlengths.txt\nWe can now send the content of lengths.txt to the screen using cat lengths.txt. The cat command gets its name from ‘concatenate’ i.e. join together, and it prints the contents of files one after another. There’s only one file in this case, so cat just shows us what it contains:\n$ cat lengths.txt\n  20  cubane.pdb\n  12  ethane.pdb\n   9  methane.pdb\n  30  octane.pdb\n  21  pentane.pdb\n  15  propane.pdb\n 107  total\n\n\nFiltering output\nNext we’ll use the sort command to sort the contents of the lengths.txt file. But first we’ll do an exercise to learn a little about the sort command:\n\n\n\n\n\n\nChallenge: What does sort -n do?\n\n\n\nThe file shell-lesson-data/exercise-data/numbers.txt contains the following lines:\n10\n2\n19\n22\n6\nIf we run sort on this file, the output is:\n10\n19\n2\n22\n6\nIf we run sort -n on the same file, we get this instead:\n2\n6\n10\n19\n22\nExplain why -n has this effect.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -n option specifies a numerical rather than an alphanumerical sort.\n\n\n\n\n\nWe will also use the -n option to specify that the sort is numerical instead of alphanumerical. This does not change the file; instead, it sends the sorted result to the screen:\n$ sort -n lengths.txt\n  9  methane.pdb\n 12  ethane.pdb\n 15  propane.pdb\n 20  cubane.pdb\n 21  pentane.pdb\n 30  octane.pdb\n107  total\nWe can put the sorted list of lines in another temporary file called sorted-lengths.txt by putting &gt; sorted-lengths.txt after the command, just as we used &gt; lengths.txt to put the output of wc into lengths.txt. Once we’ve done that, we can run another command called head to get the first few lines in sorted-lengths.txt:\n$ sort -n lengths.txt &gt; sorted-lengths.txt\n$ head -n 1 sorted-lengths.txt\n  9  methane.pdb\nUsing -n 1 with head tells it that we only want the first line of the file; -n 20 would get the first 20, and so on. Since sorted-lengths.txt contains the lengths of our files ordered from least to greatest, the output of head must be the file with the fewest lines.\n\n\n\n\n\n\nRedirecting to the same file\n\n\n\nIt’s a very bad idea to try redirecting the output of a command that operates on a file to the same file. For example:\n$ sort -n lengths.txt &gt; lengths.txt\nDoing something like this may give you incorrect results and/or delete the contents of lengths.txt.\n\n\n\n\n\n\n\n\nChallenge: What Does &gt;&gt; Mean?\n\n\n\nWe have seen the use of &gt;, but there is a similar operator &gt;&gt; which works slightly differently. We’ll learn about the differences between these two operators by printing some strings. We can use the echo command to print strings e.g.\n$ echo The echo command prints text\nThe echo command prints text\nNow test the commands below to reveal the difference between the two operators:\n$ echo hello &gt; testfile01.txt\nand:\n$ echo hello &gt;&gt; testfile02.txt\nHint: Try executing each command twice in a row and then examining the output files.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIn the first example with &gt;, the string ‘hello’ is written to testfile01.txt, but the file gets overwritten each time we run the command.\nWe see from the second example that the &gt;&gt; operator also writes ‘hello’ to a file (in this case testfile02.txt), but appends the string to the file if it already exists (i.e. when we run it for the second time).\n\n\n\n\n\n\n\n\n\n\n\nChallenge: appending data\n\n\n\nWe have already met the head command, which prints lines from the start of a file. tail is similar, but prints lines from the end of a file instead.\nConsider the file shell-lesson-data/exercise-data/animal-counts/animals.csv. After these commands, select the answer that corresponds to the file animals-subset.csv:\n$ head -n 3 animals.csv &gt; animals-subset.csv\n$ tail -n 2 animals.csv &gt;&gt; animals-subset.csv\n\nThe first three lines of animals.csv\nThe last two lines of animals.csv\nThe first three lines and the last two lines of animals.csv\nThe second and third lines of animals.csv\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 3 is correct. For option 1 to be correct we would only run the head command. For option 2 to be correct we would only run the tail command. For option 4 to be correct we would have to pipe the output of head into tail -n 2 by doing head -n 3 animals.csv | tail -n 2 &gt; animals-subset.csv",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#passing-output-to-another-command",
    "href": "lessons/shell-intro/shell-intro.html#passing-output-to-another-command",
    "title": "Introduction to the Unix Shell",
    "section": "Passing output to another command",
    "text": "Passing output to another command\nIn our example of finding the file with the fewest lines, we are using two intermediate files lengths.txt and sorted-lengths.txt to store output. This is a confusing way to work because even once you understand what wc, sort, and head do, those intermediate files make it hard to follow what’s going on. We can make it easier to understand by running sort and head together:\n$ sort -n lengths.txt | head -n 1\n  9  methane.pdb\nThe vertical bar, |, between the two commands is called a pipe. It tells the shell that we want to use the output of the command on the left as the input to the command on the right.\nThis has removed the need for the sorted-lengths.txt file.",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#combining-multiple-commands",
    "href": "lessons/shell-intro/shell-intro.html#combining-multiple-commands",
    "title": "Introduction to the Unix Shell",
    "section": "Combining multiple commands",
    "text": "Combining multiple commands\nNothing prevents us from chaining pipes consecutively. We can for example send the output of wc directly to sort, and then send the resulting output to head. This removes the need for any intermediate files.\nWe’ll start by using a pipe to send the output of wc to sort:\n$ wc -l *.pdb | sort -n\n   9 methane.pdb\n  12 ethane.pdb\n  15 propane.pdb\n  20 cubane.pdb\n  21 pentane.pdb\n  30 octane.pdb\n 107 total\nWe can then send that output through another pipe, to head, so that the full pipeline becomes:\n$ wc -l *.pdb | sort -n | head -n 1\n   9  methane.pdb\nThis is exactly like a mathematician nesting functions like log(3x) and saying ‘the log of three times x’. In our case, the algorithm is ‘head of sort of line count of *.pdb’.\nThe redirection and pipes used in the last few commands are illustrated below:\n\n\n\n\n\n\n\nChallenge: Piping commands together\n\n\n\nIn our current directory, we want to find the 3 files which have the least number of lines. Which command listed below would work?\n\nwc -l * &gt; sort -n &gt; head -n 3\nwc -l * | sort -n | head -n 1-3\nwc -l * | head -n 3 | sort -n\nwc -l * | sort -n | head -n 3\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4 is the solution. The pipe character | is used to connect the output from one command to the input of another. &gt; is used to redirect standard output to a file. Try it in the shell-lesson-data/exercise-data/alkanes directory!",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#tools-designed-to-work-together",
    "href": "lessons/shell-intro/shell-intro.html#tools-designed-to-work-together",
    "title": "Introduction to the Unix Shell",
    "section": "Tools designed to work together",
    "text": "Tools designed to work together\nThis idea of linking programs together is why Unix has been so successful. Instead of creating enormous programs that try to do many different things, Unix programmers focus on creating lots of simple tools that each do one job well, and that work well with each other. This programming model is called ‘pipes and filters’. We’ve already seen pipes; a filter is a program like wc or sort that transforms a stream of input into a stream of output. Almost all of the standard Unix tools can work this way. Unless told to do otherwise, they read from standard input, do something with what they’ve read, and write to standard output.\nThe key is that any program that reads lines of text from standard input and writes lines of text to standard output can be combined with every other program that behaves this way as well. You can and should write your programs this way so that you and other people can put those programs into pipes to multiply their power.\n\n\n\n\n\n\nChallenge: Pipe Reading Comprehension\n\n\n\nA file called animals.csv (in the shell-lesson-data/exercise-data/animal-counts folder) contains the following data:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nWhat text passes through each of the pipes and the final redirect in the pipeline below? Note, the sort -r command sorts in reverse order.\n$ cat animals.csv | head -n 5 | tail -n 3 | sort -r &gt; final.txt\nHint: build the pipeline up one command at a time to test your understanding\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe head command extracts the first 5 lines from animals.csv. Then, the last 3 lines are extracted from the previous 5 by using the tail command. With the sort -r command those 3 lines are sorted in reverse order. Finally, the output is redirected to a file: final.txt. The content of this file can be checked by executing cat final.txt. The file should contain the following lines:\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-05,raccoon,7\n\n\n\n\n\n\n\n\n\n\n\nChallenge: Pipe Construction\n\n\n\nFor the file animals.csv from the previous exercise, consider the following command:\n$ cut -d , -f 2 animals.csv\nThe cut command is used to remove or ‘cut out’ certain sections of each line in the file, and cut expects the lines to be separated into columns by a Tab character. A character used in this way is called a delimiter. In the example above we use the -d option to specify the comma as our delimiter character. We have also used the -f option to specify that we want to extract the second field (column). This gives the following output:\ndeer\nrabbit\nraccoon\nrabbit\ndeer\nfox\nrabbit\nbear\nThe uniq command filters out adjacent matching lines in a file. How could you extend this pipeline (using uniq and another command) to find out what animals the file contains (without any duplicates in their names)?\n\n\n\n\n\n\nSolution\n\n\n\n\n\n$ cut -d , -f 2 animals.csv | sort | uniq\n\n\n\n\n\n\n\n\n\n\n\nChallenge: Which Pipe?\n\n\n\nThe file animals.csv contains 8 lines of data formatted as follows:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n...\nThe uniq command has a -c option which gives a count of the number of times a line occurs in its input. Assuming your current directory is shell-lesson-data/exercise-data/animal-counts, what command would you use to produce a table that shows the total count of each type of animal in the file?\n\nsort animals.csv | uniq -c\nsort -t, -k2,2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c | wc -l\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4. is the correct answer. If you have difficulty understanding why, try running the commands, or sub-sections of the pipelines (make sure you are in the shell-lesson-data/exercise-data/animal-counts directory).",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#your-pipeline-checking-files",
    "href": "lessons/shell-intro/shell-intro.html#your-pipeline-checking-files",
    "title": "Introduction to the Unix Shell",
    "section": "Your Pipeline: Checking Files",
    "text": "Your Pipeline: Checking Files\nYou have run your samples through the assay machines and created 17 files in the north-pacific-gyre directory described earlier. As a quick check, starting from the shell-lesson-data directory, you type:\n$ cd north-pacific-gyre\n$ wc -l *.txt\nThe output is 18 lines that look like this:\n300 NENE01729A.txt\n300 NENE01729B.txt\n300 NENE01736A.txt\n300 NENE01751A.txt\n300 NENE01751B.txt\n300 NENE01812A.txt\n... ...\nNow you type this:\n$ wc -l *.txt | sort -n | head -n 5\n 240 NENE02018B.txt\n 300 NENE01729A.txt\n 300 NENE01729B.txt\n 300 NENE01736A.txt\n 300 NENE01751A.txt\nWhoops: one of the files is 60 lines shorter than the others. When you go back and check it, you see that you did that assay at 8:00 on a Monday morning — someone was probably in using the machine on the weekend, and you forgot to reset it. Before re-running that sample, you check to see if any files have too much data:\n$ wc -l *.txt | sort -n | tail -n 5\n 300 NENE02040B.txt\n 300 NENE02040Z.txt\n 300 NENE02043A.txt\n 300 NENE02043B.txt\n5040 total\nThose numbers look good — but what’s that ‘Z’ doing there in the third-to-last line? All of your samples should be marked ‘A’ or ‘B’; by convention, your lab uses ‘Z’ to indicate samples with missing information. To find others like it, you do this:\n$ ls *Z.txt\nNENE01971Z.txt    NENE02040Z.txt\nSure enough, when you check the log on your laptop, there’s no depth recorded for either of those samples. Since it’s too late to get the information any other way, you must exclude those two files from your analysis. You could delete them using rm, but there are actually some analyses you might do later where depth doesn’t matter, so instead, youwc counts lines, words, and characters in its inputs.\n\n\n\n\n\n\nKey Points\n\n\n\n\ncat displays the contents of its inputs.\nsort sorts its inputs.\nhead displays the first 10 lines of its input by default without additional arguments.\ntail displays the last 10 lines of its input by default without additional arguments.\ncommand &gt; [file] redirects a command’s output to a file (overwriting any existing content).\ncommand &gt;&gt; [file] appends a command’s output to a file.\n[first] | [second] is a pipeline: the output of the first command is used as the input to the second.\nThe best way to use the shell is to use pipes to combine simple single-purpose programs (filters).’ll have to be careful later on to select files using the wildcard expressions NENE*A.txt NENE*B.txt.",
    "crumbs": [
      "Home",
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html",
    "href": "lessons/r-lessons/r-tidydata.html",
    "title": "R for Data Cleaning",
    "section": "",
    "text": "“How can I summarize my data in R?”\n“How can R help make my research more reproducible?”\n“How can I combine two datasets from different sources?”\n“How can data tidying facilitate answering analysis questions?”\n\n\n“To become familiar with the functions of the dplyr and tidyr packages.”\n“To be able to use dplyr and tidyr to prepare data for analysis.”\n“To be able to combine two different data sources using joins.”\n“To be able to create plots and summary tables to answer analysis questions.”",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#loading-in-the-data",
    "href": "lessons/r-lessons/r-tidydata.html#loading-in-the-data",
    "title": "R for Data Cleaning",
    "section": "Loading in the data",
    "text": "Loading in the data\nThe output in your console shows that by doing this, we attach several useful packages for data wrangling, including readr. Check out these packages and their documentation at tidyverse.org\n\nReminder: Many of these packages, including dplyr , come with “Cheatsheets” found under the Help RStudio menu tab.\n\nReload your data:\nNotice that the output of the read_csv() function is pretty informative. It tells us the name of all of our column headers as well as how it interpreted the data type. This birds-eye-view can help you take a quick look that everything is how we expect it to be.\nNow we have the tools necessary to work through this lesson.",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#get-stats-fast-with-summarize",
    "href": "lessons/r-lessons/r-tidydata.html#get-stats-fast-with-summarize",
    "title": "R for Data Cleaning",
    "section": "Get stats fast with summarize()",
    "text": "Get stats fast with summarize()\nBack to top",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#narrow-down-rows-with-filter",
    "href": "lessons/r-lessons/r-tidydata.html#narrow-down-rows-with-filter",
    "title": "R for Data Cleaning",
    "section": "Narrow down rows with filter()",
    "text": "Narrow down rows with filter()\nBack to top\nNotice how the pipe operator (%&gt;%) allows us to combine these two simple steps into a more complicated data extraction?. We took the data, filtered out the rows, then took the mean value. The argument we pass to filter() needs to be some expression that will return TRUE or FALSE. We can use comparisons like &gt; (greater than) and &lt; (less than) for example. Here we tested for equality using a double equals sign ==. You use == (double equals) when testing if two values are equal, and you use = (single equals) when naming arguments that you are passing to functions. Try changing it to use filter(year = 2007) and see what happens.",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#grouping-rows-using-group_by",
    "href": "lessons/r-lessons/r-tidydata.html#grouping-rows-using-group_by",
    "title": "R for Data Cleaning",
    "section": "Grouping rows using group_by()",
    "text": "Grouping rows using group_by()\nBack to top\nWe see that the life expectancy in 2007 is much larger than the value we got using all of the rows. It seems life expectancy is increasing which is good news. But now we might be interested in calculating the average for each year. Rather that doing a bunch of different filter() statements, we can instead use the group_by() function. The function allows us to tell the code to treat the rows in logical groups, so rather than summarizing over all the rows, we will get one summary value for each group. Here’s what that will look like:\nThe group_by() function expects you to pass in the name of a column (or multiple columns separated by comma) in your data.\nNote that you might get a message about the summarize function regrouping the output by ‘year’. This simply indicates what the function is grouping by.\nYou can also create more than one new column when you call summarize(). To do so, you must separate your columns with a comma. Building on the code from the last exercise, let’s add a new column that calculates the minimum life expectancy for each continent.",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#make-new-variables-with-mutate",
    "href": "lessons/r-lessons/r-tidydata.html#make-new-variables-with-mutate",
    "title": "R for Data Cleaning",
    "section": "Make new variables with mutate()",
    "text": "Make new variables with mutate()\nBack to top\nEach time we ran summarize(), we got back fewer rows than passed in. We either got one row back, or one row per group. But sometimes we want to create a new column in our data without changing the number of rows. The function we use to create new columns is called mutate().\nWe have a column for the population and the GDP per capita. If we wanted to get the total GDP, we could multiply the per capita GDP values by the total population. Here’s what such a mutate() command would look like:\nThis will add a new column called “gdp” to our data. We use the column names as if they were regular values that we want to perform mathematical operations on and provide the name in front of an equals sign like we have done with summarize()",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#subset-columns-using-select",
    "href": "lessons/r-lessons/r-tidydata.html#subset-columns-using-select",
    "title": "R for Data Cleaning",
    "section": "Subset columns using select()",
    "text": "Subset columns using select()\nBack to top\nWe use the filter() function to choose a subset of the rows from our data, but when we want to choose a subset of columns from our data we use select(). For example, if we only wanted to see the population (“pop”) and year values, we can do:\nWe can also use select() to drop/remove particular columns by putting a minus sign (-) in front of the column name. For example, if we want everything but the continent column, we can do:",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#changing-the-shape-of-the-data",
    "href": "lessons/r-lessons/r-tidydata.html#changing-the-shape-of-the-data",
    "title": "R for Data Cleaning",
    "section": "Changing the shape of the data",
    "text": "Changing the shape of the data\nBack to top\nData comes in many shapes and sizes, and one way we classify data is either “wide” or “long.” Data that is “long” has one row per observation. The gapminder_data data is in a long format. We have one row for each country for each year and each different measurement for that country is in a different column. We might describe this data as “tidy” because it makes it easy to work with ggplot2 and dplyr functions (this is where the “tidy” in “tidyverse” comes from). As tidy as it may be, sometimes we may want our data in a “wide” format. Typically in “wide” format each row represents a group of observations and each value is placed in a different column rather than a different row. For example maybe we want only one row per country and want to spread the life expectancy values into different columns (one for each year).\nThe tidyr package contains the functions pivot_wider and pivot_longer that make it easy to switch between the two formats. The tidyr package is included in the tidyverse package so we don’t need to do anything to load it.\nNotice here that we tell pivot_wider() which columns to pull the names we wish our new columns to be named from the year variable, and the values to populate those columns from the lifeExp variable. (Again, neither of which have to be in quotes in the code when there are no special characters or spaces - certainly an incentive not to use special characters or spaces!) We see that the resulting table has new columns by year, and the values populate it with our remaining variables dictating the rows.\nBefore we move on to more data cleaning, let’s create the final gapminder dataframe we will be working with for the rest of the lesson!",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#reviewing-git-and-github",
    "href": "lessons/r-lessons/r-tidydata.html#reviewing-git-and-github",
    "title": "R for Data Cleaning",
    "section": "Reviewing Git and GitHub",
    "text": "Reviewing Git and GitHub\nNow that we have our gapminder data prepared, let’s use what we learned about git and GitHub in the previous lesson to add, commit, and push our changes.\nOpen Terminal/Git Bash, if you do not have it open already. First we’ll need to navigate to our un-report directory.\nLet’s start by print our current working directory and listing the items in the directory, to see where we are.",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  }
]