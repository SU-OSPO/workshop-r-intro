[
  {
    "objectID": "lessons/r-lessons/r-markdown.html",
    "href": "lessons/r-lessons/r-markdown.html",
    "title": "Writing reports with R Markdown",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Writing reports with R Markdown"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-plotting.html",
    "href": "lessons/r-lessons/r-plotting.html",
    "title": "Plotting in R with ggplot2",
    "section": "",
    "text": "While you can make plots with just the packages that come bundled with base R, many R users make their visualizations entirely using the ggplot2 package and an ecosystem of packages designed around it.\n\n# load the ggplot2 package\nlibrary(ggplot2)\n\nAs with the previous session, we’ll be using the Palmer penguins dataset. While we built our own combined dataset in the introduction session, now we’re going to use the built-in raw dataset included in the palmerpenguins package (install this first if you don’t have it yet). First, let’s load the package. By loading the package, it gives us access to the penguins_raw data object that is included (notice that it isn’t shown in our Global Environment, but you can see it in the environment of the palmerpenguins package). Let’s inspect the data using the glimpse() function (we’ll learn more about the dplyr package in the next session).\n\nlibrary(palmerpenguins)\ndplyr::glimpse(penguins_raw)\n\nRows: 344\nColumns: 17\n$ studyName             &lt;chr&gt; \"PAL0708\", \"PAL0708\", \"PAL0708\", \"PAL0708\", \"PAL…\n$ `Sample Number`       &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1…\n$ Species               &lt;chr&gt; \"Adelie Penguin (Pygoscelis adeliae)\", \"Adelie P…\n$ Region                &lt;chr&gt; \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\", \"Anvers\"…\n$ Island                &lt;chr&gt; \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgerse…\n$ Stage                 &lt;chr&gt; \"Adult, 1 Egg Stage\", \"Adult, 1 Egg Stage\", \"Adu…\n$ `Individual ID`       &lt;chr&gt; \"N1A1\", \"N1A2\", \"N2A1\", \"N2A2\", \"N3A1\", \"N3A2\", …\n$ `Clutch Completion`   &lt;chr&gt; \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"No\", …\n$ `Date Egg`            &lt;date&gt; 2007-11-11, 2007-11-11, 2007-11-16, 2007-11-16,…\n$ `Culmen Length (mm)`  &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34…\n$ `Culmen Depth (mm)`   &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18…\n$ `Flipper Length (mm)` &lt;dbl&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190,…\n$ `Body Mass (g)`       &lt;dbl&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 34…\n$ Sex                   &lt;chr&gt; \"MALE\", \"FEMALE\", \"FEMALE\", NA, \"FEMALE\", \"MALE\"…\n$ `Delta 15 N (o/oo)`   &lt;dbl&gt; NA, 8.94956, 8.36821, NA, 8.76651, 8.66496, 9.18…\n$ `Delta 13 C (o/oo)`   &lt;dbl&gt; NA, -24.69454, -25.33302, NA, -25.32426, -25.298…\n$ Comments              &lt;chr&gt; \"Not enough blood for isotopes.\", NA, NA, \"Adult…\n\n\nAs we discovered before, this dataset includes many different measurements for individual penguins from three different studies. The studies cover both sexes of three different species of penguins from three different islands in the Palmer Archipelago.",
    "crumbs": [
      "Plotting in R with ggplot2"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-plotting.html#other-layers",
    "href": "lessons/r-lessons/r-plotting.html#other-layers",
    "title": "Plotting in R with ggplot2",
    "section": "Other layers",
    "text": "Other layers\nThere are many other types of plots that we can make with ggplot2.\n\nHistograms\nWe can visualize the density of values for a single variable with a histogram:\n\nggplot(penguins_raw) +\n  aes(x = `Body Mass (g)`, fill = Species) +\n  geom_histogram() +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nHistograms don’t require a y-axis aesthetic by default. The counts are tabulated for you. If you specify a “fill” aesthetic, the default is to stack the bars which can sometimes be a bit misleading. You can also dodge them to fix this:\n\nggplot(penguins_raw) +\n  aes(x = `Body Mass (g)`, fill = Species) +\n  geom_histogram(position = \"dodge\") +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\n\n\n\n\nBoxplots and Violin Plotss\nWe can visualize the density of values for a single variable across a discrete variable with boxplots or violin plots:\n\nggplot(penguins_raw) +\n  aes(x = Island, y = `Culmen Length (mm)`) +\n  geom_boxplot() +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\n\nggplot(penguins_raw) +\n  aes(x = Island, y = `Culmen Length (mm)`) +\n  geom_violin(scale = \"width\", draw_quantiles = c(0.25, 0.5, 0.75)) +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGeom options\n\n\n\nNote that many of these “geom”s have lots of options. For example, here we’ve decided to scale all of the violin plots to the same width and to draw the quartiles on them (mimicking the boxplots above). You can see all of the options for a geom by checking out it’s help page (?geom_violin) or on the ggplot website.\n\n\n\n\n2D Contours\nWe can also visualize the density of values across two continuous variables using a 2D contour. Here we’ll use the isotope data from the penguins dataset. We’ll expand the axes a little bit to better show the contours:\n\nggplot(penguins_raw) +\n  aes(x = `Delta 15 N (o/oo)`, y = `Delta 13 C (o/oo)`) +\n  geom_density_2d(linewidth = 0.25, colour = \"black\") +\n  scale_x_continuous(limits = c(7, 10.5)) +\n  scale_y_continuous(limits = c(-27.5, -23.5)) +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\n\n\nTime Series\nSince there isn’t really any time series data in the penguins dataset, we’ll take a quick detour and use the built-in economics dataset to explore visualizing a time series. In this case, we are looking at unemployment over time:\n\nggplot(economics, aes(x = date, y = unemploy)) +\n  geom_line() +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\ngeom_path() lets you explore how two variables are related over time. For example, unemployment and personal savings rate:\n\nggplot(economics, aes(x = unemploy / pop, y = psavert)) +\n  geom_path(aes(colour = as.numeric(date))) +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMultiple columns for individual aesthetics\n\n\n\nNote how we’ve used multiple columns of the data to define the x-axis here. You can use any sort of mathetical operators to combine multiple columns into a single aesthetic, as long as you are doing row-wise math. We’ll learn about summary statistics for groups of rows in the next session.",
    "crumbs": [
      "Plotting in R with ggplot2"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-plotting.html#combining-layers",
    "href": "lessons/r-lessons/r-plotting.html#combining-layers",
    "title": "Plotting in R with ggplot2",
    "section": "Combining layers",
    "text": "Combining layers\nWe can also combine multiple layers to show the same data in different ways in the same plot. For example, we could show the raw data for the above contour plot in addition to the contours:\n\nggplot(penguins_raw) +\n  aes(x = `Delta 15 N (o/oo)`, y = `Delta 13 C (o/oo)`) +\n  geom_point() +\n  geom_density_2d_filled(alpha = 0.5) +\n  geom_density_2d(linewidth = 0.25, colour = \"black\") +\n  scale_x_continuous(limits = c(7, 10.5)) +\n  scale_y_continuous(limits = c(-27.5, -23.5)) +\n  coord_cartesian(expand = FALSE) +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLayer order\n\n\n\nWhen combining layers, the layers are added to the plot in order, so in this case the points are the bottom layer and the contour lines are the top layer. We changed the alpha of the middle layer to prevent the points from being blocked. I’ve also used the coord_cartesian() function to remove the default axis expansion. This way the background color reaches both axes and doesn’t have a white gap.",
    "crumbs": [
      "Plotting in R with ggplot2"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-plotting.html#facetting",
    "href": "lessons/r-lessons/r-plotting.html#facetting",
    "title": "Plotting in R with ggplot2",
    "section": "Facetting",
    "text": "Facetting\nLet’s take our scatterplot example from earlier:\n\nggplot(penguins_raw) +\n  aes(x = `Body Mass (g)`, y = `Flipper Length (mm)`,\n      color = Island, shape = Sex) +\n  geom_point() +\n  scale_color_brewer(palette = \"Set1\") +\n  scale_x_continuous(name = \"Body Mass (grams)\") +\n  scale_y_continuous(name = \"Flipper Length (millimeters)\") +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\nNow, what if we wanted to also split the data by the species of the penguins? We’re already using color and shape, so what other aesthetic could we use? We could possible use some shapes that have both a fill and outline color, but that sounds messy. Instead of using another aesthetic, we could also use a facet. This splits the chart into multiple panels:\n\nggplot(penguins_raw) +\n  aes(x = `Body Mass (g)`, y = `Flipper Length (mm)`,\n      color = Island, shape = Sex) +\n  geom_point() +\n  scale_color_brewer(palette = \"Set1\") +\n  scale_x_continuous(name = \"Body Mass (grams)\") +\n  scale_y_continuous(name = \"Flipper Length (millimeters)\") +\n  facet_wrap(vars(Species), ncol = 1) +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\nWe can get even crazier by faceting by multiple variables:\n\nggplot(penguins_raw) +\n  aes(x = `Body Mass (g)`, y = `Flipper Length (mm)`,\n      color = Island, shape = Sex) +\n  geom_point() +\n  scale_color_brewer(palette = \"Set1\") +\n  scale_x_continuous(name = \"Body Mass (grams)\") +\n  scale_y_continuous(name = \"Flipper Length (millimeters)\") +\n  facet_grid(rows = vars(Species), cols = vars(studyName)) +\n  theme_classic() +\n  theme(axis.text = element_text(color = \"black\"))\n\n\n\n\n\n\n\n\nOK, maybe we’ve gone a little too far here, but you get the picture!",
    "crumbs": [
      "Plotting in R with ggplot2"
    ]
  },
  {
    "objectID": "lessons/github/ssh_setup.html",
    "href": "lessons/github/ssh_setup.html",
    "title": "Computing Basics and Intro to R",
    "section": "",
    "text": "In order to push commits to GitHub you need to have authentication setup. While there are a couple of ways to do this, we recommend using ssh keys. The steps below will walk you through how to create an ssh key (if you don’t already have one) and add it to your GitHub account.\nBefore doing step 1, check if you already have a key pair generated. Open a shell and run:\nls ~/.ssh/id_ed25519\nIf a file path is returned, skip step 1. Otherwise, if you get “No such file or directory”, do step 1.\n\nGo to this help article on GitHub, select which operating system you are using for your terminal (either Mac or Linux), then scroll down to “Generating a new SSH key” and follow the instructions there. Stop when you get to “Adding your SSH key to the ssh-agent”.\nThe keygen command should have created a public and private key pair in your ~/.ssh directory. This is a hidden directory that contains your ssh keys, configuration settings, and other files related to ssh. Verify that the keys exist by typing:\n\nls ~/.ssh\nYou should see at least two files in there, one called id_ed25519 and one called id_ed25519.pub. (You may also have other id_* files in there, if you had created key pairs previously.)\nThe id_ed25519 file is your private key. Do not share your private key with anyone! It remains on your computer, and only on your computer. The id_ed25519.pub file is your public key. You can share the contents of your public key with other servers you want to log in to.\n\n\n\n\n\n\nNote: you need a GitHub account to do the following steps. If you do not have a GitHub account, sign up for one by going to https://github.com and following the onscreen instructions. Once you have an account you can proceed.\n\n\n\n\nNow let’s upload your public key to GitHub so that you can use your ssh keypairs when interacting with GitHub. Follow the instructions here: Adding a new SSH key to your GitHub account.\nTo test whether you were successful, in your terminal run\n\nssh -T git@github.com\nYou may be prompted with something like:\n&gt; The authenticity of host 'github.com (IP ADDRESS)' can't be established.\n&gt; ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.\n&gt; Are you sure you want to continue connecting (yes/no)?\nIf so, type yes. You should then get\nHi USERNAME! You've successfully authenticated, but GitHub does not provide shell access.\nwhere USERNAME is your username.\nYou’re now ready to use GitHub!\n\nFor more information on what ssh keys are and how they work, see the lecture on ssh from our summer workshop (Day 2, session 1)."
  },
  {
    "objectID": "lessons/github/ssh_setup.html#create-and-add-an-ssh-key-to-github",
    "href": "lessons/github/ssh_setup.html#create-and-add-an-ssh-key-to-github",
    "title": "Computing Basics and Intro to R",
    "section": "",
    "text": "In order to push commits to GitHub you need to have authentication setup. While there are a couple of ways to do this, we recommend using ssh keys. The steps below will walk you through how to create an ssh key (if you don’t already have one) and add it to your GitHub account.\nBefore doing step 1, check if you already have a key pair generated. Open a shell and run:\nls ~/.ssh/id_ed25519\nIf a file path is returned, skip step 1. Otherwise, if you get “No such file or directory”, do step 1.\n\nGo to this help article on GitHub, select which operating system you are using for your terminal (either Mac or Linux), then scroll down to “Generating a new SSH key” and follow the instructions there. Stop when you get to “Adding your SSH key to the ssh-agent”.\nThe keygen command should have created a public and private key pair in your ~/.ssh directory. This is a hidden directory that contains your ssh keys, configuration settings, and other files related to ssh. Verify that the keys exist by typing:\n\nls ~/.ssh\nYou should see at least two files in there, one called id_ed25519 and one called id_ed25519.pub. (You may also have other id_* files in there, if you had created key pairs previously.)\nThe id_ed25519 file is your private key. Do not share your private key with anyone! It remains on your computer, and only on your computer. The id_ed25519.pub file is your public key. You can share the contents of your public key with other servers you want to log in to.\n\n\n\n\n\n\nNote: you need a GitHub account to do the following steps. If you do not have a GitHub account, sign up for one by going to https://github.com and following the onscreen instructions. Once you have an account you can proceed.\n\n\n\n\nNow let’s upload your public key to GitHub so that you can use your ssh keypairs when interacting with GitHub. Follow the instructions here: Adding a new SSH key to your GitHub account.\nTo test whether you were successful, in your terminal run\n\nssh -T git@github.com\nYou may be prompted with something like:\n&gt; The authenticity of host 'github.com (IP ADDRESS)' can't be established.\n&gt; ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.\n&gt; Are you sure you want to continue connecting (yes/no)?\nIf so, type yes. You should then get\nHi USERNAME! You've successfully authenticated, but GitHub does not provide shell access.\nwhere USERNAME is your username.\nYou’re now ready to use GitHub!\n\nFor more information on what ssh keys are and how they work, see the lecture on ssh from our summer workshop (Day 2, session 1)."
  },
  {
    "objectID": "lessons/github/exercise2.html",
    "href": "lessons/github/exercise2.html",
    "title": "Exercise 2: Using git pull and push with GitHub",
    "section": "",
    "text": "Exercise 2: Using git pull and push with GitHub\nExercise 1 illustrated how to create a new git repository on your local computer. In this exercise we’ll create a new repository on GitHub, clone it to our local computer, make changes, then push it back to GitHub. This is the more common way to create git repositories on GitHub.\n\n\n\n\n\n\nssh key setup\n\n\n\nIn order to do this exercise you will need an ssh key uploaded to GitHub. If you have not done that yet, follow the ssh setup instructions before starting this exercise.\n\n\n\nGo to https://github.com and sign in if you are not already. Then go to https://github.com/new to create a new repository.\nIn the Owner section, click the drop down “Choose an owner” and select yourself.\nYou’ll need to put a name in the “Repository name” field. GitHub will offer a suggestion (where it says “Need inspiration? How about …”). Use the suggested name. That should ensure that the repostiory name is unique, which will make doing Exercise 3 easier.\nUnder “Description” put “My test git repository.”\nMake sure “Public” is selected.\nCheck the box for “Add a README file”. This will cause your repo to be initialized with a README.md file in it. It isn’t strictly necessary, but is good to have, as it’s what GitHub will show by default when people go to your repository.\nUnder “Choose a license” select “GNU General Public License v3.0”. This will cause your repository to be initialized with a LICENSE file that has the GNU Public License v3.0 in it (an open source license). Choosing a license isn’t strictly necessary, but it’s good practice.\nNow click the “Create repository” green button. This will create your repository. You will have the repository webpage open.\nWe want to add things to your repository. You can do that through the web interface, but it’s easier to do it on your local computer, esepcially for code development so that you can test things. To do that we’ll need a local copy of your repository. This is what git clone does: it downloads a local copy of your remote repository (which lives on GitHub) that can track the remote repository.\n\nTo clone the repository, click the Green &lt;&gt; Code button in the upper right, then select the “SSH” tab. We’ll want the SSH version so that we can push changes later.\n\nCopy the URL in the SSH tab. Now open a terminal (you may want to open the terminal side-by-side with your web browser; it’ll make doing the rest of this exercise easier). cd to the directory that you want your local copy of the repository to live, then type:\n\ngit clone SSH_URL\nwhere SSH_URL is the URL you copied from GitHub.\n\nWhen git clone finishes, you will have a new directory that has the same name as your repo on your computer. cd into that and type ls. You should see the README.md file and the LICENSE file.\nThis is your local copy of your repository. It’s setup to track your repo on GitHub, which is called the origin repository. You can verify that by typing:\n\ngit remote -v\nThat will show you the URL of the origin. Note that this is printed twice: once for fetching (i.e., the default repo you will pull new updates from) and one for pushing (i.e., the repo to which you will push changes from your local computer).\n\nNow let’s add a file. In your terminal, use your favorite text editor to create a file called mymath.R and put the following in it:\n\n!#/usr/bin/env R\n\n# Some math functions\n\nadd &lt;- function(a, b) {\n    return (a + b)\n    }\nThis is a simple R program that contains a function to add two numbers.\n\nAdd and commit your file to your repo:\n\ngit add mymath.R\ngit commit -m \"add mymath file\"\nCheck your history to see the commit by typing git log.\n\nNow look at your copy of the repository on GitHub in your web browser. Is mymath.R there? No. Try refreshing the page. Is it there? Still no. This is because you have only commited the file to your local copy of the repository. The origin repository on GitHub doesn’t know about these changes. To get the changes on to your origin repository, type:\n\ngit push\nGo back to your web browser and refresh your repository page. You should now see the mymath.R file there. You can click on it to view it if you like. You can also see your commit history on GitHub (click the icon that looks like a clock just below the green &lt;&gt; Code button on the front page of your repository). Notice that the history on GitHub is the same as your history on your local computer. Your repos are in sync!\n\nLet’s create a branch to do some development work. We could do this on our local computer, but let’s do it on GitHub instead. Click the drop down button that says “main” in the upper left corner of the website. Then click “View all branches”. This will bring you to another page that shows you all your branches. Currently we only have one, main. Create a new branch by clicking the green New branch button in the upper right. In the “New branch name” field type dev1 then click Create new branch. This will create the new branch.\nNow let’s make some changes on the dev1 branch on our local computer. To do that, we’ll need to update our local repo to pickup the new branch. Go to your terminal and type:\n\ngit fetch\nYou’ll see a message telling you about the new branch origin/dev1. You still don’t have this branch on your local repo! If you type git branch, you’ll only see * main. The fetch command just informed your local repo about the existence of the dev1 branch on GitHub. You can verify this by typing git branch -r to see the remote branches.\n\nLet’s checkout a local copy of the dev1 branch. Type:\n\ngit checkout -b dev1 origin/dev1\nAdding the extra origin/dev1 instructs git to make your local dev1 track the remote one. This means that when we git push from this branch it will by default push changes to the dev1 branch on GitHub, not the main branch. You can verify which branch you will push to by typing:\ngit branch -vv\n\nLet’s modify mymath.R on dev1. On your local computer, use your favorite text editor to open mymath.R and add the following to it:\n\n\nsubtract &lt;- function(a, b) {\n    return (a - b)\n    }\nCommit your changes to your local repo:\ngit add -u\ngit commit -m \"add subtraction\"\n\nAgain, your changes to your local dev1 are not on GitHub yet. To do that, push the changes by typing:\n\ngit push\nNote that when you did this, it pushed to the dev1 branch on git hub (you’ll see a message like dev1 -&gt; dev1).\n\nNow look at your web browser. As soon as you typed git push a message popped up that said “dev1 had recent pushes” with a green Compare and pull request button popping up. Click that button. This will open a “pull request” page. The pull request page will automatically have a title that is the message from your last commit. You can optionally add a longer description. Then click the Create pull request button.\nThis will open “Pull request”. Pull requests are GitHub’s way of managing new development. This is particularly useful for collaborating with others on a project. You can use the pull request page to discuss changes before they are merged on to the main branch. You can alos have multiple pull requests open at once.\nLet’s merge your pull request. There’s a green Merge pull request button at the bottom of the page. Click it, then “Confirm merge”. This will merge your changes on dev1 on to main. You now have the option to delete dev1. Feel free to click the delete dev1 branch button.\nNow that your main branch on GitHub has the merged changes, your main branch on your local copy is out of sync. To update it, go to your terminal and switch to your main branch:\n\ngit checkout main\nYou can now bring it up to date with your remote repository by running git pull:\ngit pull\nOnce that’s done, you can also delete your local copy of the dev1 branch by typing:\ngit branch -d dev1\n\n\n\n\n Back to top",
    "crumbs": [
      "<code>git</code> and GitHub",
      "Exercise 2: Using `git pull` and `push` with GitHub"
    ]
  },
  {
    "objectID": "lessons/github/github-intro.html",
    "href": "lessons/github/github-intro.html",
    "title": "git and GitHub",
    "section": "",
    "text": "Objectives\n\n\n\n\n\nLearn how to use git with command-line instructions.\nLearn how to do version control with git.\nUnderstand the differences between git and GitHub.\nUse GitHub to collaborate with others on a project.",
    "crumbs": [
      "<code>git</code> and GitHub"
    ]
  },
  {
    "objectID": "lessons/github/github-intro.html#prerequisites",
    "href": "lessons/github/github-intro.html#prerequisites",
    "title": "git and GitHub",
    "section": "Prerequisites",
    "text": "Prerequisites\nThe following should be done before doing the exercises below.\n\nGitHub ssh keys\nIn exercises 2 and 3 you will be using GitHub to “push” and “pull” commits between your local computer and GitHub’s servers. This requires authentication to be setup. For these purposes we suggest using ssh keys. To set that up, follow the instructions here:\n\nSetup ssh key for GitHub\n\n\n\nGit configuration\nBefore doing the exercises in this session, you’ll need to tell git what your name and email are, so that it creates commits with the appropriate author information. To do that, open a terminal and run the following (it doesn’t matter which directory you run these from), but replacing YOUR NAME with your name and YOUR_EMAIL_ADDRESS with your email address:\ngit config --global user.name \"YOUR NAME\"\ngit config --global user.email \"YOUR_EMAIL_ADDRESS\"\nFor entering longer commit messages (you’ll learn what this means in Exercise 1) we’ll need to tell git what text editor to use. By default git will use vim, which can be tricky to understand for new users. For the purposes of this tutorial, we’ll use the more user-friendly nano. To do that, run the following in your terminal:\ngit config --global core.editor nano\n\n\n\n\n\n\nNote\n\n\n\nIf you wish to reset to the default editor after the tutorial is over, run:\ngit config --global --unset-all core.editor",
    "crumbs": [
      "<code>git</code> and GitHub"
    ]
  },
  {
    "objectID": "lessons/github/github-intro.html#exercises",
    "href": "lessons/github/github-intro.html#exercises",
    "title": "git and GitHub",
    "section": "Exercises",
    "text": "Exercises\n\nExercise1: Practice with git on a local repository\nExercise2: git and GitHub\nExercise3: Collaborating in GitHub using the Fork and Pull Model",
    "crumbs": [
      "<code>git</code> and GitHub"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html",
    "href": "lessons/shell-intro/shell-intro.html",
    "title": "Introduction to the Unix Shell",
    "section": "",
    "text": "What is a command shell and why would I use one?\n\n\nExplain how the shell relates to the keyboard, the screen, the operating system, and users’ programs.\nExplain when and why command-line interfaces should be used instead of graphical interfaces.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#the-prompt",
    "href": "lessons/shell-intro/shell-intro.html#the-prompt",
    "title": "Introduction to the Unix Shell",
    "section": "The prompt",
    "text": "The prompt\nWhen the shell is first opened, you are presented with a prompt, indicating that the shell is waiting for input.\n$\nThe shell typically uses $ as the prompt, but may use a different symbol. In the examples for this lesson, we’ll show the prompt as $. Most importantly, do not type the prompt when typing commands. Only type the command that follows the prompt. This rule applies both in these lessons and in lessons from other sources. Also note that after you type a command, you have to press the Enter key to execute it.\nThe prompt is followed by a text cursor, a character that indicates the position where your typing will appear. The cursor is usually a flashing or solid block, but it can also be an underscore or a pipe. You may have seen it in a text editor program, for example.\nNote that your prompt might look a little different. In particular, most popular shell environments by default put your user name and the host name before the $. Such a prompt might look like, e.g.:\nsklucas@localhost $\nThe prompt might even include more than this. Do not worry if your prompt is not just a short $. This lesson does not depend on this additional information and it should also not get in your way. The only important item to focus on is the $ character itself and we will see later why.\n\n\n\n\n\n\nOPTIONAL: Change your prompt to $\n\n\n\nIf you’d like to simplify your prompt for the purposes of this tutorial, copy and paste the code below into your terminal:\nPS1='$ '\n\n\nSo let’s try our first command, ls, which is short for listing. This command will list the contents of the current directory:\n$ ls\nDesktop     Downloads   Movies      Pictures\nDocuments   Library     Music       Public\n\n\n\n\n\n\nCommand not found\n\n\n\nIf the shell can’t find a program whose name is the command you typed, it will print an error message such as:\n$ ks\nks: command not found\nThis might happen if the command was mis-typed or if the program corresponding to that command is not installed.\n\n\n\nA Typical Problem\nYou are a marine biologist who has just returned from a six-month survey of the North Pacific Gyre, where you have sampled gelatinous marine life in the Great Pacific Garbage Patch. You have 1520 samples that you’ve run through an assay machine to measure the relative abundance of 300 proteins. You need to run these 1520 files through an imaginary program called goostats.sh. In addition to this huge task, you have to write up results by the end of the month, so your paper can appear in a special issue of Aquatic Goo Letters.\nIf you choose to run goostats.sh by hand using a GUI, you’ll have to select and open a file 1520 times. If goostats.sh takes 30 seconds to run each file, the whole process will take more than 12 hours. With the shell, you can instead assign your computer this mundane task while you focuses her attention on writing your paper.\nThe next few lessons will explore the ways you can achieve this. More specifically, the lessons explain how you can use a command shell to run the goostats.sh program, using loops to automate the repetitive steps of entering file names, so that your computer can work while you write your paper.\nAs a bonus, once you have put a processing pipeline together, you will be able to use it again whenever you collect more data.\nIn order to achieve your task, you need to know how to:\n\nnavigate to a file/directory\ncreate a file/directory\ncheck the length of a file\nchain commands together\nretrieve a set of files\niterate over files\nrun a shell script containing your pipeline\n\nDownload files:\nYou need to download some files to follow this lesson.\n\nDownload shell-lesson-data.zip and move the file to your Desktop.\nUnzip/extract the file. Let your instructor know if you need help with this step. You should end up with a new folder called shell-lesson-data on your Desktop.\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA shell is a program whose primary purpose is to read commands and run other programs.\nThis lesson uses Bash, the default shell in many implementations of Unix.\nPrograms can be run in Bash by entering commands at the command-line prompt.\nThe shell’s main advantages are its high action-to-keystroke ratio, its support for automating repetitive tasks, and its capacity to access networked machines.\nA significant challenge when using the shell can be knowing what commands need to be run and how to run them.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#where-am-i",
    "href": "lessons/shell-intro/shell-intro.html#where-am-i",
    "title": "Introduction to the Unix Shell",
    "section": "Where am I?",
    "text": "Where am I?\nFirst, let’s find out where we are by running a command called pwd (which stands for ‘print working directory’). Directories are like places — at any time while we are using the shell, we are in exactly one place called our current working directory. Commands mostly read and write files in the current working directory, i.e. ‘here’, so knowing where you are before running a command is important. pwd shows you where you are:\n$ pwd\n/Users/sklucas\nThe computer’s response is /Users/sklucas, which is my home directory.\n\nThe home directory\nThe home directory will look different on different operating systems.\n\nLinux: /home/sklucas\nWindows: C:\\Users\\sklucas (This may differ based on Windows versions)\n\nIf pwd returns something else, you may need to navigate to your home directory using the command cd.\nLet’s look at how a filesystem is organized:\n\nThe filesystem looks like an upside-down tree. We refer to the topmost directory as the “root directory”. It contains everything else. It is referred to with the / symbol.\nIn this illustration, we have several other directories stemming off of the root. The bin directory often refers to a location where programs are stored. tmp is a common directory on filesystems as a place to hold files that don’t need to be kept long-term. You may recognize the Users directory from the output we had above when typing pwd. We know the path of our home directory, where we currently are, is /Users/sklucas.\n\n\n\n\n\n\nSlashes\n\n\n\nThere are two meanings for the / character. When it appears at the front of a path, it means “root”, when it appears within a path, it acts as a separator.\n\n\n\nThe Users folder may have more than one directory in it. For example, the image below depicts two users, sklucas and Collin. The home directory just as the home directory for sklucas is /Users/sklucas, the home directory for Collin would be /Users/Collin. Typically, when you open a new command prompt, you will start in your home directory by default",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#listing-directory-contents",
    "href": "lessons/shell-intro/shell-intro.html#listing-directory-contents",
    "title": "Introduction to the Unix Shell",
    "section": "Listing directory contents",
    "text": "Listing directory contents\nWe often want to know what a directory contains. To do this, we use the “listing” command ls:\n$ ls\nwhich might return something that looks like this (results will vary):\nApplications  Documents  Library  Music    Public\nDesktop       Downloads  Movies   Pictures  \nls prints the names of the files and directories in your current location. Typing ls -F will give specific notation below based on the\n\nA trailing / indicates that this is a directory\n@ indicates a link\n* indicates an executable\n\nDepending on your shell’s default settings, the shell might also use colors to indicate whether each entry is a file or directory.\n\n\n\n\n\n\nClearing your terminal\n\n\n\nIf your screen gets too cluttered, you can clear your terminal using the clear command. You can still access previous commands using ↑↑ and ↓↓ to move line-by-line, or by scrolling in your terminal.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#getting-help",
    "href": "lessons/shell-intro/shell-intro.html#getting-help",
    "title": "Introduction to the Unix Shell",
    "section": "Getting help",
    "text": "Getting help\nMost bash commands have help menus that tell the user about how the command is used and what options are available for tailoring the function. There are two common ways to get help with commands, which can differ based on the source of the command (built-in or externally installed), and the operating system.\n\nWe can pass a --help option to any command (on linux and Git Bash).\n$ ls --help\nWe can read the manual on a function using the man command (linux and OSX)\n$ man ls\nTo navigate through the man pages, you may use ↑↑ and ↓↓ to move line-by-line, or try bb and SpacebarSpacebar to skip up and down by a full page. To search for a character or word in the man pages, use // followed by the character or word you are searching for. Sometimes a search will result in multiple hits. If so, you can move between hits using NN (for moving forward) and Shift+NShift+N (for moving backward). To **quit** the man pages, press qq.\n\n\n\n\n\n\n\nBash Built-in commands\n\n\n\nSome commands are built in to the Bash shell, rather than existing as separate programs on the filesystem. One example is the cd “change directory” command. If you get a message like No manual entry for cd, try help cd instead. The help command is how you get usage information for Bash built-ins.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#command-options",
    "href": "lessons/shell-intro/shell-intro.html#command-options",
    "title": "Introduction to the Unix Shell",
    "section": "Command options",
    "text": "Command options\nWe’ve seen that commands can have many options associated with them, which can control how the command functions. These are often notated by short and long forms that are typically equal in their meaning, but have conventional use in different scenarios.\nWhen options exist as both short and long options:\n\nUse the short option when typing commands directly into the shell to minimize keystrokes and get your task done faster.\nUse the long option in scripts to provide clarity. It will be read many times and typed once.\n\n\n\n\n\n\n\nUnsupported commandline options\n\n\n\nIf you try to use an option that is not supported, ls and other commands will usually print an error message similar to:\n$ ls -j\nMac zsh output:\nls: invalid option -- j\nusage: ls [-@ABCFGHILOPRSTUWXabcdefghiklmnopqrstuvwxy1%,] [--color=when] [-D format] [file ...]\nother Unix output:\nls: invalid option -- 'j'\nTry 'ls --help' for more information.\n\n\n\nChallenge Questions\nExplore the ls command options to answer the following questions:\n\n\n\n\n\n\nQuestion 1: Listing in long, human-readable format\n\n\n\nWhich options for ls produces output in long format that is human readable? (i.e. displaying something like 5.3K instead of 5369)\n\n\n\n\n\n\nSolution\n\n\n\n\n\nthe options -l and -h can be used with ls to make the output long and human readable. You can use them in two ways:\n\nls -l -h\nor string them together ls -lh\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 2: Listing in Reverse Chronological Order\n\n\n\nBy default, ls lists the contents of a directory in alphabetical order by name. The command ls -t lists items by time of last change instead of alphabetically. The command ls -r lists the contents of a directory in reverse order. Which file is displayed last when you combine the -t and -r options? Hint: You may need to use the -l option to see the last changed dates.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe most recently changed file is listed last when using -rt. This can be very useful for finding your most recent edits or checking to see if a new output file was written.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#exploring-other-directories",
    "href": "lessons/shell-intro/shell-intro.html#exploring-other-directories",
    "title": "Introduction to the Unix Shell",
    "section": "Exploring other directories",
    "text": "Exploring other directories\nNot only can we use ls on the current working directory, but we can use it to list the contents of a different directory. Let’s take a look at our Desktop directory by running ls -F Desktop, i.e., the command ls with the -F option and the argument Desktop. The argument Desktop tells ls that we want a listing of something other than our current working directory:\n$ ls -F Desktop\nYou should see your newly created directory “workshop”\nshell-lesson-data/\nNote that if a directory named Desktop does not exist in your current working directory, this command will return an error. Typically, a Desktop directory exists in your home directory, which we assume is the current working directory of your bash shell.\nYour output should be a list of all the files and sub-directories in your Desktop directory, including the shell-lesson-data directory you downloaded at the setup for this lesson. (On most systems, the contents of the Desktop directory in the shell will show up as icons in a graphical user interface behind all the open windows. See if this is the case for you.)\nOrganizing things hierarchically helps us keep track of our work. While it’s possible to put hundreds of files in our home directory just as it’s possible to pile hundreds of printed papers on our desk, it’s much easier to find things when they’ve been organized into sensibly-named subdirectories.\nNow that we know the shell-lesson-data directory is located in our Desktop directory, we can do two things.\nFirst, using the same strategy as before, we can look at its contents by passing a directory name to ls:\n$ ls -F Desktop/shell-lesson-data\nexercise-data/  north-pacific-gyre/\nSecond, we can actually change our location to a different directory, so we are no longer located in our home directory.\nThe command to change locations is cd followed by a directory name to change our working directory. cd stands for ‘change directory’, which is a bit misleading. The command doesn’t change the directory; it changes the shell’s current working directory. In other words it changes the shell’s settings for what directory we are in. The cd command is akin to double-clicking a folder in a graphical interface to get into that folder.\nLet’s say we want to move into the exercise-data directory we saw above. We can use the following series of commands to get there:\n$ cd Desktop\n$ cd shell-lesson-data\n$ cd exercise-data\nThese commands will move us from our home directory into our Desktop directory, then into the shell-lesson-data directory, then into the exercise-data directory. You will notice that cd doesn’t print anything. This is normal. Many shell commands will not output anything to the screen when successfully executed. But if we run pwd after it, we can see that we are now in /Users/sklucas/Desktop/shell-lesson-data/exercise-data.\nIf we run ls -F without arguments now, it lists the contents of /Users/sklucas/Desktop/shell-lesson-data/exercise-data, because that’s where we now are:\n$ pwd\n/Users/sklucas/Desktop/shell-lesson-data/exercise-data\n$ ls -F\nalkanes/  animal-counts/  creatures/  numbers.txt  writing/\nWe now know how to go down the directory tree (i.e. how to go into a subdirectory), but how do we go up (i.e. how do we leave a directory and go into its parent directory)? We might try the following:\n$ cd shell-lesson-data\n-bash: cd: shell-lesson-data: No such file or directory\nBut we get an error! Why is this?\nWith our methods so far, cd can only see sub-directories inside your current directory. There are different ways to see directories above your current location; we’ll start with the simplest.\nThere is a shortcut in the shell to move up one directory level. It works as follows:\n$ cd ..\n.. is a special directory name meaning “the directory containing this one”, or more succinctly, the parent of the current directory. Sure enough, if we run pwd after running cd .., we’re back in /Users/sklucas/Desktop/shell-lesson-data:\n$ pwd\n/Users/sklucas/Desktop/shell-lesson-data\nThe special directory .. doesn’t usually show up when we run ls. If we want to display it, we can add the -a option to ls -F:\n$ ls -F -a\n./  ../  exercise-data/  north-pacific-gyre/\n-a stands for ‘show all’ (including hidden files); it forces ls to show us file and directory names that begin with ., such as .. (which, if we’re in /Users/sklucas, refers to the /Users directory). As you can see, it also displays another special directory that’s just called ., which means ‘the current working directory’. It may seem redundant to have a name for it, but we’ll see some uses for it soon.\nNote that in most command line tools, multiple options can be combined with a single - and no spaces between the options; ls -F -a is equivalent to ls -Fa.\n\n\n\n\n\n\nOther Hidden Files\n\n\n\nIn addition to the hidden directories .. and ., you may also see a file called .bash_profile. This file usually contains shell configuration settings. You may also see other files and directories beginning with .. These are usually files and directories that are used to configure different programs on your computer. The prefix . is used to prevent these configuration files from cluttering the terminal when a standard ls command is used.\n\n\nThese three commands are the basic commands for navigating the filesystem on your computer: pwd, ls, and cd. Let’s explore some variations on those commands. What happens if you type cd on its own, without giving a directory?\n$ cd\nHow can you check what happened? pwd gives us the answer!\n$ pwd\n/Users/sklucas\nIt turns out that cd without an argument will return you to your home directory, which is great if you’ve got lost in your own filesystem.\nLet’s try returning to the exercise-data directory from before. Last time, we used three commands, but we can actually string together the list of directories to move to exercise-data in one step:\n$ cd Desktop/shell-lesson-data/exercise-data\nCheck that we’ve moved to the right place by running pwd and ls -F.\nIf we want to move up one level from the data directory, we could use cd ... But there is another way to move to any directory, regardless of your current location.\nSo far, when specifying directory names, or even a directory path (as above), we have been using relative paths. When you use a relative path with a command like ls or cd, it tries to find that location from where we are, rather than from the root of the file system.\nHowever, it is possible to specify the absolute path to a directory by including its entire path from the root directory, which is indicated by a leading slash. The leading / tells the computer to follow the path from the root of the file system, so it always refers to exactly one directory, no matter where we are when we run the command.\nThis allows us to move to our shell-lesson-data directory from anywhere on the filesystem (including from inside exercise-data). To find the absolute path we’re looking for, we can use pwd and then extract the piece we need to move to shell-lesson-data.\n$ pwd\n/Users/sklucas/Desktop/shell-lesson-data/exercise-data\n$ cd /Users/sklucas/Desktop/shell-lesson-data\nRun pwd and ls -F to ensure that we’re in the directory we expect.\n\n\n\n\n\n\nTwo more shortcuts\n\n\n\nThe shell interprets a tilde (~) character at the start of a path to mean “the current user’s home directory”. For example, if your home directory is /Users/sklucas, then ~/data is equivalent to /Users/sklucas/data. This only works if it is the first character in the path; here/there/~/elsewhere is not here/there/Users/sklucas/elsewhere.\nAnother shortcut is the - (dash) character. cd will translate - into the previous directory I was in, which is faster than having to remember, then type, the full path. This is a very efficient way of moving back and forth between two directories – i.e. if you execute cd - twice, you end up back in the starting directory.\nThe difference between cd .. and cd - is that the former brings you up, while the latter brings you back.\n\nTry it!\nFirst navigate to ~/Desktop/shell-lesson-data (you should already be there).\n$ cd ~/Desktop/shell-lesson-data\nThen cd into the exercise-data/creatures directory\n$ cd exercise-data/creatures\nNow if you run\n$ cd -\nyou’ll see you’re back in ~/Desktop/shell-lesson-data. Run cd - again and you’re back in ~/Desktop/shell-lesson-data/exercise-data/creatures\n\n\n\n\nChallenge Questions\n\n\n\n\n\n\nQuestion 3: Absolute vs Relative Paths\n\n\n\nStarting from /Users/sklucas/data, which of the following commands could sklucas use to navigate to her home directory, which is /Users/sklucas?\n\ncd .\ncd /\ncd /home/sklucas\ncd ../..\ncd ~\ncd home\ncd ~/data/..\ncd\ncd ..\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: . stands for the current directory.\nNo: / stands for the root directory.\nNo: sklucas’s home directory is /Users/sklucas.\nNo: this command goes up two levels, i.e. ends in /Users.\nYes: ~ stands for the user’s home directory, in this case /Users/sklucas.\nNo: this command would navigate into a directory home in the current directory if it exists.\nYes: unnecessarily complicated, but correct.\nYes: shortcut to go back to the user’s home directory.\nYes: goes up one level.\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 4: Relative Path Resolution\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/thing, what will ls -F ../backup display?\n\n\n../backup: No such file or directory\n2012-12-01 2013-01-08 2013-01-27\n2012-12-01/ 2013-01-08/ 2013-01-27/\noriginal/ pnas_final/ pnas_sub/\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: there is a directory backup in /Users.\nNo: this is the content of Users/thing/backup, but with .., we asked for one level further up.\nNo: see previous explanation.\nYes: ../backup/ refers to /Users/backup/.\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 4: ls reading comprehension\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/backup, and -r tells ls to display things in reverse order, what command(s) will result in the following output:\npnas_sub/ pnas_final/ original/\n\n\nls pwd\nls -r -F\nls -r -F /Users/backup\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: pwd is not the name of a directory.\nYes: ls without directory argument lists files and directories in the current directory.\nYes: uses the absolute path explicitly.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#general-syntax-of-a-shell-command",
    "href": "lessons/shell-intro/shell-intro.html#general-syntax-of-a-shell-command",
    "title": "Introduction to the Unix Shell",
    "section": "General Syntax of a Shell Command",
    "text": "General Syntax of a Shell Command\nWe have now encountered commands, options, and arguments, but it is perhaps useful to formalise some terminology.\nConsider the command below as a general example of a command, which we will dissect into its component parts:\n$ ls -F /\n\nls is the command, with an option -F and an argument /. We’ve already encountered options which either start with a single dash (-), known as short options, or two dashes (--), known as long options. Options change the behavior of a command and arguments tell the command what to operate on (e.g. files and directories). Sometimes options and arguments are referred to as parameters. A command can be called with more than one option and more than one argument, but a command doesn’t always require an argument or an option.\nYou might sometimes see options being referred to as switches or flags, especially for options that take no argument. In this lesson we will stick with using the term option.\nEach part is separated by spaces. If you omit the space between ls and -F the shell will look for a command called ls-F, which doesn’t exist. Also, capitalization can be important. For example, ls -s will display the size of files and directories alongside the names, while ls -S will sort the files and directories by size, as shown below:\n$ cd ~/Desktop/shell-lesson-data\n$ ls -s exercise-data\ntotal 28\n 4 animal-counts   4 creatures  12 numbers.txt   4 alkanes   4 writing\nNote that the sizes returned by ls -s are in blocks. As these are defined differently for different operating systems, you may not obtain the same figures as in the example.\n$ ls -S exercise-data\nanimal-counts  creatures  alkanes  writing  numbers.txt\nPutting all that together, our command ls -F / above gives us a listing of files and directories in the root directory /. An example of the output you might get from the above command is given below:\n$ ls -F /\nApplications/         System/\nLibrary/              Users/\nNetwork/              Volumes/\n\nYour Task: Organizing Files\nKnowing this much about files and directories, You are ready to organize the files that the protein assay machine will create.\nYou create a directory called north-pacific-gyre (to remind yourself where the data came from), which will contain the data files from the assay machine and your data processing scripts.\nEach of your physical samples is labelled according to your lab’s convention with a unique ten-character ID, such as ‘NENE01729A’. This ID is what you used in your collection log to record the location, time, depth, and other characteristics of the sample, so you decide to use it within the filename of each data file. Since the output of the assay machine is plain text, you will call your files NENE01729A.txt, NENE01812A.txt, and so on. All 1520 files will go into the same directory.\nNow in your current directory shell-lesson-data, you can see what files you have using the command:\n$ ls north-pacific-gyre/\nThis command is a lot to type, but you can let the shell do most of the work through what is called tab completion. If you types:\n$ ls nor\nand then presses Tab (the tab key on her keyboard), the shell automatically completes the directory name for you:\n$ ls north-pacific-gyre/\nPressing Tab again does nothing, since there are multiple possibilities; pressing Tab twice brings up a list of all the files.\nIf you then presses G and then presses Tab again, the shell will append ‘goo’ since all files that start with ‘g’ share the first three characters ‘goo’.\n$ ls north-pacific-gyre/goo\nTo see all of those files, you can press Tab twice more.\nls north-pacific-gyre/goo\ngoodiff.sh   goostats.sh\nThis is called tab completion, and we will see it in many other tools as we go on.\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nThe file system is responsible for managing information on the disk.\nInformation is stored in files, which are stored in directories (folders).\nDirectories can also store other directories, which then form a directory tree.\npwd prints the user’s current working directory.\nls [path] prints a listing of a specific file or directory; ls on its own lists the current working directory.\ncd [path] changes the current working directory.\nMost commands take options that begin with a single -.\nDirectory names in a path are separated with / on Unix, but \\ on Windows.\n/ on its own is the root directory of the whole file system.\nAn absolute path specifies a location from the root of the file system.\nA relative path specifies a location starting from the current location.\n. on its own means ‘the current directory’; .. means ‘the directory above the current one’.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#creating-directories-and-files",
    "href": "lessons/shell-intro/shell-intro.html#creating-directories-and-files",
    "title": "Introduction to the Unix Shell",
    "section": "Creating Directories and Files",
    "text": "Creating Directories and Files\nWe now know how to explore files and directories, but how do we create them in the first place?\nIn this episode we will learn about creating and moving files and directories, using the exercise-data/writing directory as an example.\n\nStep one: see where we are and what we already have\nWe should still be in the shell-lesson-data directory on the Desktop, which we can check using:\n$ pwd\n/Users/sklucas/Desktop/shell-lesson-data\nNext we’ll move to the exercise-data/writing directory and see what it contains:\n$ cd exercise-data/writing/\n$ ls -F\nhaiku.txt  LittleWomen.txt\n\n\nCreate a directory\nLet’s create a new directory called thesis using the command mkdir thesis (which has no output):\n$ mkdir thesis\nAs you might guess from its name, mkdir means ‘make directory’. Since thesis is a relative path (i.e., does not have a leading slash, like /what/ever/thesis), the new directory is created in the current working directory:\n$ ls -F\nhaiku.txt  LittleWomen.txt  thesis/\nSince we’ve just created the thesis directory, there’s nothing in it yet:\n$ ls -F thesis\nNote that mkdir is not limited to creating single directories one at a time. The -p option allows mkdir to create a directory with nested subdirectories in a single operation:\n$ mkdir -p ../project/data ../project/results\nThe -R option to the ls command will list all nested subdirectories within a directory. Let’s use ls -FR to recursively list the new directory hierarchy we just created in the project directory:\n$ ls -FR ../project\n../project/:\ndata/  results/\n\n../project/data:\n\n../project/results:\n\n\n\n\n\n\nTwo ways of doing the same thing\n\n\n\nUsing the shell to create a directory is no different than using a file explorer. If you open the current directory using your operating system’s graphical file explorer, the thesis directory will appear there too. While the shell and the file explorer are two different ways of interacting with the files, the files and directories themselves are the same.\n\n\n\n\n\n\n\n\nGood names for files and directories\n\n\n\nComplicated names of files and directories can make your life painful when working on the command line. Here we provide a few useful tips for the names of your files and directories.\n\nDon’t use spaces.\n\nSpaces can make a name more meaningful, but since spaces are used to separate arguments on the command line it is better to avoid them in names of files and directories. You can use - or _ instead (e.g. north-pacific-gyre/ rather than north pacific gyre/). To test this out, try typing mkdir north pacific gyre and see what directory (or directories!) are made when you check with ls -F.\n\nDon’t begin the name with - (dash).\n\nCommands treat names starting with - as options.\n\nStick with letters, numbers, . (period or ‘full stop’), - (dash) and _ (underscore).\n\nMany other characters have special meanings on the command line. We will learn about some of these during this lesson. There are special characters that can cause your command to not work as expected and can even result in data loss.\nIf you need to refer to names of files or directories that have spaces or other special characters, you should surround the name in single quotes ('').\n\n\n\n\nCreate a text file\nLet’s change our working directory to thesis using cd, then run a text editor called Nano to create a file called draft.txt:\n$ cd thesis\n$ nano draft.txt\n\n\n\n\n\n\nWhich editor?\n\n\n\nWhen we say, ‘nano is a text editor’ we really do mean ‘text’. It can only work with plain character data, not tables, images, or any other human-friendly media. We use it in examples because it is one of the least complex text editors. However, because of this trait, it may not be powerful enough or flexible enough for the work you need to do after this workshop. On Unix systems (such as Linux and macOS), many programmers use Emacs or Vim (both of which require more time to learn), or a graphical editor such as Gedit or VScode. On Windows, you may wish to use Notepad++. Windows also has a built-in editor called notepad that can be run from the command line in the same way as nano for the purposes of this lesson.\nNo matter what editor you use, you will need to know where it searches for and saves files. If you start it from the shell, it will (probably) use your current working directory as its default location. If you use your computer’s start menu, it may want to save files in your Desktop or Documents directory instead. You can change this by navigating to another directory the first time you ‘Save As…’\n\n\nLet’s type a few lines of text:\n\nOnce we’re happy with our text, we can press Ctrl+O (press the Ctrl or Control key and, while holding it down, press the O key) to write our data to disk. We will be asked to provide a name for the file that will contain our text. Press Return to accept the suggested default of draft.txt.\nOnce our file is saved, we can use Ctrl+X to quit the editor and return to the shell.\n\n\n\n\n\n\nControl, Ctrl, or ^ Key\n\n\n\nThe Control key is also called the ‘Ctrl’ key. There are various ways in which using the Control key may be described. For example, you may see an instruction to press the Control key and, while holding it down, press the X key, described as any of:\n\nControl-X\nControl+X\nCtrl-X\nCtrl+X\n^X\nC-x\n\nIn nano, along the bottom of the screen you’ll see ^G Get Help ^O WriteOut. This means that you can use Control-G to get help and Control-O to save your file.\n\n\nnano doesn’t leave any output on the screen after it exits, but ls now shows that we have created a file called draft.txt:\n$ ls\ndraft.txt\n\n\n\n\n\n\nChallenge: Creating Files a Different Way\n\n\n\nWe have seen how to create text files using the nano editor. Now, try the following command:\n$ touch my_file.txt\n\nWhat did the touch command do? When you look at your current directory using the GUI file explorer, does the file show up?\nUse ls -l to inspect the files. How large is my_file.txt?\nWhen might you want to create a file this way?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThe touch command generates a new file called my_file.txt in your current directory. You can observe this newly generated file by typing ls at the command line prompt. my_file.txt can also be viewed in your GUI file explorer.\nWhen you inspect the file with ls -l, note that the size of my_file.txt is 0 bytes. In other words, it contains no data. If you open my_file.txt using your text editor it is blank.\nSome programs do not generate output files themselves, but instead require that empty files have already been generated. When the program is run, it searches for an existing file to populate with its output. The touch command allows you to efficiently generate a blank text file to be used by such programs.\n\n\n\n\nTo avoid confusion later on, we suggest removing the file you’ve just created before proceeding with the rest of the episode, otherwise future outputs may vary from those given in the lesson. To do this, use the following command:\n$ rm my_file.txt\n\n\n\nWhat’s in a name?\nYou may have noticed that all of your files are named ‘something dot something’, and in this part of the lesson, we always used the extension .txt. This is just a convention; we can call a file mythesis or almost anything else we want. However, most people use two-part names most of the time to help them (and their programs) tell different kinds of files apart. The second part of such a name is called the filename extension and indicates what type of data the file holds: .txt signals a plain text file, .pdf indicates a PDF document, .cfg is a configuration file full of parameters for some program or other, .png is a PNG image, and so on.\nThis is just a convention, albeit an important one. Files merely contain bytes; it’s up to us and our programs to interpret those bytes according to the rules for plain text files, PDF documents, configuration files, images, and so on.\nNaming a PNG image of a whale as whale.mp3 doesn’t somehow magically turn it into a recording of whale song, though it might cause the operating system to associate the file with a music player program. In this case, if someone double-clicked whale.mp3 in a file explorer program, the music player will automatically (and erroneously) attempt to open the whale.mp3 file.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#moving-files-and-directories",
    "href": "lessons/shell-intro/shell-intro.html#moving-files-and-directories",
    "title": "Introduction to the Unix Shell",
    "section": "Moving Files and Directories",
    "text": "Moving Files and Directories\nReturning to the shell-lesson-data/exercise-data/writing directory,\n$ cd ~/Desktop/shell-lesson-data/exercise-data/writing\nIn our thesis directory we have a file draft.txt which isn’t a particularly informative name, so let’s change the file’s name using mv, which is short for ‘move’:\n$ mv thesis/draft.txt thesis/quotes.txt\nThe first argument tells mv what we’re ‘moving’, while the second is where it’s to go. In this case, we’re moving thesis/draft.txt to thesis/quotes.txt, which has the same effect as renaming the file. Sure enough, ls shows us that thesis now contains one file called quotes.txt:\n$ ls thesis\nquotes.txt\nOne must be careful when specifying the target file name, since mv will silently overwrite any existing file with the same name, which could lead to data loss. By default, mv will not ask for confirmation before overwriting files. However, an additional option, mv -i (or mv --interactive), will cause mv to request such confirmation.\nNote that mv also works on directories.\nLet’s move quotes.txt into the current working directory. We use mv once again, but this time we’ll use just the name of a directory as the second argument to tell mv that we want to keep the filename but put the file somewhere new. (This is why the command is called ‘move’.) In this case, the directory name we use is the special directory name . that we mentioned earlier.\n$ mv thesis/quotes.txt .\nThe effect is to move the file from the directory it was in to the current working directory. ls now shows us that thesis is empty:\n$ ls thesis\n$\nAlternatively, we can confirm the file quotes.txt is no longer present in the thesis directory by explicitly trying to list it:\n$ ls thesis/quotes.txt\nls: cannot access 'thesis/quotes.txt': No such file or directory\nls with a filename or directory as an argument only lists the requested file or directory. If the file given as the argument doesn’t exist, the shell returns an error as we saw above. We can use this to see that quotes.txt is now present in our current directory:\n$ ls quotes.txt\nquotes.txt\n\n\n\n\n\n\nChallenge: Moving files to a new folder\n\n\n\nAfter running the following commands, Jamie realizes that she put the files sucrose.dat and maltose.dat into the wrong folder. The files should have been placed in the raw folder.\n$ ls -F\n analyzed/ raw/\n$ ls -F analyzed\nfructose.dat glucose.dat maltose.dat sucrose.dat\n$ cd analyzed\nFill in the blanks to move these files to the raw/ folder (i.e. the one she forgot to put them in)\n$ mv sucrose.dat maltose.dat ____/____\n\n\n\n\n\n\nSolution\n\n\n\n\n\n$ mv sucrose.dat maltose.dat ../raw\nRecall that .. refers to the parent directory (i.e. one above the current directory) and that . refers to the current directory.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#copying-files-and-directories",
    "href": "lessons/shell-intro/shell-intro.html#copying-files-and-directories",
    "title": "Introduction to the Unix Shell",
    "section": "Copying Files and Directories",
    "text": "Copying Files and Directories\nThe cp command works very much like mv, except it copies a file instead of moving it. We can check that it did the right thing using ls with two paths as arguments — like most Unix commands, ls can be given multiple paths at once:\n$ cp quotes.txt thesis/quotations.txt\n$ ls quotes.txt thesis/quotations.txt\nquotes.txt   thesis/quotations.txt\nWe can also copy a directory and all its contents by using the recursive option -r, e.g. to back up a directory:\n$ cp -r thesis thesis_backup\nWe can check the result by listing the contents of both the thesis and thesis_backup directory:\n$ ls thesis thesis_backup\nthesis:\nquotations.txt\n\nthesis_backup:\nquotations.txt\nIt is important to include the -r flag. If you want to copy a directory and you omit this option you will see a message that the directory has been omitted because -r not specified.\n$ cp thesis thesis_backup\ncp: -r not specified; omitting directory 'thesis'\n\n\n\n\n\n\nChallenge: Renaming files\n\n\n\nSuppose that you created a plain-text file in your current directory to contain a list of the statistical tests you will need to do to analyze your data, and named it statstics.txt\nAfter creating and saving this file you realize you misspelled the filename! You want to correct the mistake, which of the following commands could you use to do so?\n\ncp statstics.txt statistics.txt\nmv statstics.txt statistics.txt\nmv statstics.txt .\ncp statstics.txt .\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo. While this would create a file with the correct name, the incorrectly named file still exists in the directory and would need to be deleted.\nYes, this would work to rename the file.\nNo, the period(.) indicates where to move the file, but does not provide a new file name; identical file names cannot be created.\nNo, the period(.) indicates where to copy the file, but does not provide a new file name; identical file names cannot be created.\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge: Moving and copying\n\n\n\nWhat is the output of the closing ls command in the sequence shown below?\n$ pwd\n/Users/jamie/data\n$ ls\nproteins.dat\n$ mkdir recombined\n$ mv proteins.dat recombined/\n$ cp recombined/proteins.dat ../proteins-saved.dat\n$ ls\n\nproteins-saved.dat recombined\nrecombined\nproteins.dat recombined\nproteins-saved.dat\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe start in the /Users/jamie/data directory, and create a new folder called recombined. The second line moves (mv) the file proteins.dat to the new folder (recombined). The third line makes a copy of the file we just moved. The tricky part here is where the file was copied to. Recall that .. means ‘go up a level’, so the copied file is now in /Users/jamie. Notice that .. is interpreted with respect to the current working directory, not with respect to the location of the file being copied. So, the only thing that will show using ls (in /Users/jamie/data) is the recombined folder.\n\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie\nYes\nNo, see explanation above. proteins.dat is located at /Users/jamie/data/recombined\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#removing-files-and-directories",
    "href": "lessons/shell-intro/shell-intro.html#removing-files-and-directories",
    "title": "Introduction to the Unix Shell",
    "section": "Removing files and directories",
    "text": "Removing files and directories\nReturning to the shell-lesson-data/exercise-data/writing directory, let’s tidy up this directory by removing the quotes.txt file we created. The Unix command we’ll use for this is rm (short for ‘remove’):\n$ rm quotes.txt\nWe can confirm the file has gone using ls:\n$ ls quotes.txt\nls: cannot access 'quotes.txt': No such file or directory\n\n\n\n\n\n\nDeleting is forever\n\n\n\nThe Unix shell doesn’t have a trash bin that we can recover deleted files from (though most graphical interfaces to Unix do). Instead, when we delete files, they are unlinked from the file system so that their storage space on disk can be recycled. Tools for finding and recovering deleted files do exist, but there’s no guarantee they’ll work in any particular situation, since the computer may recycle the file’s disk space right away.\n\n\n\n\n\n\n\n\nChallenge: Using rm Safely\n\n\n\nWhat happens when we execute rm -i thesis_backup/quotations.txt? Why would we want this protection when using rm?\n\n\n\n\n\n\nSolution\n\n\n\n\n\nrm: remove regular file 'thesis_backup/quotations.txt'? y\nThe -i option will prompt before (every) removal (use Y to confirm deletion or N to keep the file). The Unix shell doesn’t have a trash bin, so all the files removed will disappear forever. By using the -i option, we have the chance to check that we are deleting only the files that we want to remove.\n\n\n\n\n\nIf we try to remove the thesis directory using rm thesis, we get an error message:\n$ rm thesis\nrm: cannot remove 'thesis': Is a directory\nThis happens because rm by default only works on files, not directories.\nrm can remove a directory and all its contents if we use the recursive option -r, and it will do so without any confirmation prompts:\n$ rm -r thesis\nGiven that there is no way to retrieve files deleted using the shell, rm -r should be used with great caution (you might consider adding the interactive option rm -r -i).",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#operations-with-multiple-filenames",
    "href": "lessons/shell-intro/shell-intro.html#operations-with-multiple-filenames",
    "title": "Introduction to the Unix Shell",
    "section": "Operations with Multiple Filenames",
    "text": "Operations with Multiple Filenames\nOftentimes one needs to copy or move several files at once. This can be done by providing a list of individual filenames, or specifying a naming pattern using wildcards. Wildcards are special characters that can be used to represent unknown characters or sets of characters when navigating the Unix file system.\n\n\n\n\n\n\nChallenge: Copy with Multiple Filenames\n\n\n\nFor this exercise, you can test the commands in the shell-lesson-data/exercise-data directory.\nIn the example below, what does cp do when given several filenames and a directory name?\n$ mkdir backup\n$ cp creatures/minotaur.dat creatures/unicorn.dat backup/\nIn the example below, what does cp do when given three or more file names?\n$ cd creatures\n$ ls -F\nbasilisk.dat  minotaur.dat  unicorn.dat\n$ cp minotaur.dat unicorn.dat basilisk.dat\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIf given more than one file name followed by a directory name (i.e. the destination directory must be the last argument), cp copies the files to the named directory.\nIf given three file names, cp throws an error such as the one below, because it is expecting a directory name as the last argument.\ncp: target 'basilisk.dat' is not a directory",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#using-wildcards-for-accessing-multiple-files-at-once",
    "href": "lessons/shell-intro/shell-intro.html#using-wildcards-for-accessing-multiple-files-at-once",
    "title": "Introduction to the Unix Shell",
    "section": "Using Wildcards for Accessing Multiple Files at Once",
    "text": "Using Wildcards for Accessing Multiple Files at Once\n* is a wildcard, which represents zero or more other characters. Let’s consider the shell-lesson-data/exercise-data/alkanes directory: *.pdb represents ethane.pdb, propane.pdb, and every file that ends with ‘.pdb’. On the other hand, p*.pdb only represents pentane.pdb and propane.pdb, because the ‘p’ at the front can only represent filenames that begin with the letter ‘p’.\n? is also a wildcard, but it represents exactly one character. So ?ethane.pdb could represent methane.pdb whereas *ethane.pdb represents both ethane.pdb and methane.pdb.\nWildcards can be used in combination with each other. For example, ???ane.pdb indicates three characters followed by ane.pdb, giving cubane.pdb  ethane.pdb  octane.pdb.\nWhen the shell sees a wildcard, it expands the wildcard to create a list of matching filenames before running the preceding command. As an exception, if a wildcard expression does not match any file, Bash will pass the expression as an argument to the command as it is. For example, typing ls *.pdf in the alkanes directory (which contains only files with names ending with .pdb) results in an error message that there is no file called *.pdf. However, generally commands like wc and ls see the lists of file names matching these expressions, but not the wildcards themselves. It is the shell, not the other programs, that expands the wildcards.\n\n\n\n\n\n\nChallenge: List filenames matching a pattern\n\n\n\nWhen run in the alkanes directory, which ls command(s) will produce this output?\nethane.pdb   methane.pdb\n\nls *t*ane.pdb\nls *t?ne.*\nls *t??ne.pdb\nls ethane.*\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe solution is 3.\n1. shows all files whose names contain zero or more characters (*) followed by the letter t, then zero or more characters (*) followed by ane.pdb. This gives ethane.pdb  methane.pdb  octane.pdb  pentane.pdb.\n2. shows all files whose names start with zero or more characters (*) followed by the letter t, then a single character (?), then ne. followed by zero or more characters (*). This will give us octane.pdb and pentane.pdb but doesn’t match anything which ends in thane.pdb.\n3. fixes the problems of option 2 by matching two characters (??) between t and ne. This is the solution.\n4. only shows files starting with ethane..\n\n\n\n\n\n\n\n\n\n\n\nChallenge: More on wildcards\n\n\n\nSam has a directory containing calibration data, datasets, and descriptions of the datasets:\n.\n├── 2015-10-23-calibration.txt\n├── 2015-10-23-dataset1.txt\n├── 2015-10-23-dataset2.txt\n├── 2015-10-23-dataset_overview.txt\n├── 2015-10-26-calibration.txt\n├── 2015-10-26-dataset1.txt\n├── 2015-10-26-dataset2.txt\n├── 2015-10-26-dataset_overview.txt\n├── 2015-11-23-calibration.txt\n├── 2015-11-23-dataset1.txt\n├── 2015-11-23-dataset2.txt\n├── 2015-11-23-dataset_overview.txt\n├── backup\n│   ├── calibration\n│   └── datasets\n└── send_to_bob\n    ├── all_datasets_created_on_a_23rd\n    └── all_november_files\nBefore heading off to another field trip, she wants to back up her data and send some datasets to her colleague Bob. Sam uses the following commands to get the job done:\n$ cp *dataset* backup/datasets\n$ cp ____calibration____ backup/calibration\n$ cp 2015-____-____ send_to_bob/all_november_files/\n$ cp ____ send_to_bob/all_datasets_created_on_a_23rd/\nHelp Sam by filling in the blanks.\nThe resulting directory structure should look like this\n.\n├── 2015-10-23-calibration.txt\n├── 2015-10-23-dataset1.txt\n├── 2015-10-23-dataset2.txt\n├── 2015-10-23-dataset_overview.txt\n├── 2015-10-26-calibration.txt\n├── 2015-10-26-dataset1.txt\n├── 2015-10-26-dataset2.txt\n├── 2015-10-26-dataset_overview.txt\n├── 2015-11-23-calibration.txt\n├── 2015-11-23-dataset1.txt\n├── 2015-11-23-dataset2.txt\n├── 2015-11-23-dataset_overview.txt\n├── backup\n│   ├── calibration\n│   │   ├── 2015-10-23-calibration.txt\n│   │   ├── 2015-10-26-calibration.txt\n│   │   └── 2015-11-23-calibration.txt\n│   └── datasets\n│       ├── 2015-10-23-dataset1.txt\n│       ├── 2015-10-23-dataset2.txt\n│       ├── 2015-10-23-dataset_overview.txt\n│       ├── 2015-10-26-dataset1.txt\n│       ├── 2015-10-26-dataset2.txt\n│       ├── 2015-10-26-dataset_overview.txt\n│       ├── 2015-11-23-dataset1.txt\n│       ├── 2015-11-23-dataset2.txt\n│       └── 2015-11-23-dataset_overview.txt\n└── send_to_bob\n    ├── all_datasets_created_on_a_23rd\n    │   ├── 2015-10-23-dataset1.txt\n    │   ├── 2015-10-23-dataset2.txt\n    │   ├── 2015-10-23-dataset_overview.txt\n    │   ├── 2015-11-23-dataset1.txt\n    │   ├── 2015-11-23-dataset2.txt\n    │   └── 2015-11-23-dataset_overview.txt\n    └── all_november_files\n        ├── 2015-11-23-calibration.txt\n        ├── 2015-11-23-dataset1.txt\n        ├── 2015-11-23-dataset2.txt\n        └── 2015-11-23-dataset_overview.txt\n\n\n\n\n\n\nSolution\n\n\n\n\n\n$ cp *calibration.txt backup/calibration\n$ cp 2015-11-* send_to_bob/all_november_files/\n$ cp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/\n\n\n\n\n\n\n\n\n\n\n\nChallenge: Organizing directories and files\n\n\n\nJamie is working on a project, and she sees that her files aren’t very well organized:\n$ ls -F\nanalyzed/  fructose.dat    raw/   sucrose.dat\nThe fructose.dat and sucrose.dat files contain output from her data analysis. What command(s) covered in this lesson does she need to run so that the commands below will produce the output shown?\n$ ls -F\nanalyzed/   raw/\n$ ls analyzed\nfructose.dat    sucrose.dat\n\n\n\n\n\n\nSolution\n\n\n\n\n\nmv *.dat analyzed\nJamie needs to move her files fructose.dat and sucrose.dat to the analyzed directory. The shell will expand *.dat to match all .dat files in the current directory. The mv command then moves the list of .dat files to the ‘analyzed’ directory.\n\n\n\n\n\n\n\n\n\n\n\nChallenge: Reproduce a folder structure\n\n\n\nYou’re starting a new experiment and would like to duplicate the directory structure from your previous experiment so you can add new data.\nAssume that the previous experiment is in a folder called 2016-05-18, which contains a data folder that in turn contains folders named raw and processed that contain data files. The goal is to copy the folder structure of the 2016-05-18 folder into a folder called 2016-05-20 so that your final directory structure looks like this:\n2016-05-20/\n└── data\n   ├── processed\n   └── raw\nWhich of the following set of commands would achieve this objective? What would the other commands do?\n$ mkdir 2016-05-20\n$ mkdir 2016-05-20/data\n$ mkdir 2016-05-20/data/processed\n$ mkdir 2016-05-20/data/raw\n$ mkdir 2016-05-20\n$ cd 2016-05-20\n$ mkdir data\n$ cd data\n$ mkdir raw processed\n$ mkdir 2016-05-20/data/raw\n$ mkdir 2016-05-20/data/processed\n$ mkdir -p 2016-05-20/data/raw\n$ mkdir -p 2016-05-20/data/processed\n$ mkdir 2016-05-20\n$ cd 2016-05-20\n$ mkdir data\n$ mkdir raw processed\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe first two sets of commands achieve this objective. The first set uses relative paths to create the top-level directory before the subdirectories.\nThe third set of commands will give an error because the default behavior of mkdir won’t create a subdirectory of a non-existent directory: the intermediate level folders must be created first.\nThe fourth set of commands achieve this objective. Remember, the -p option, followed by a path of one or more directories, will cause mkdir to create any intermediate subdirectories as required.\nThe final set of commands generates the ‘raw’ and ‘processed’ directories at the same level as the ‘data’ directory.\n\n\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\ncp [old] [new] copies a file.\nmkdir [path] creates a new directory.\nmv [old] [new] moves (renames) a file or directory.\nrm [path] removes (deletes) a file.\n* matches zero or more characters in a filename, so *.txt matches all files ending in .txt.\n? matches any single character in a filename, so ?.txt matches a.txt but not any.txt.\nUse of the Control key may be described in many ways, including Ctrl-X, Control-X, and ^X.\nThe shell does not have a trash bin: once something is deleted, it’s really gone.\nMost files’ names are something.extension. The extension isn’t required, and doesn’t guarantee anything, but is normally used to indicate the type of data in the file.\nDepending on the type of work you do, you may need a more powerful text editor than Nano.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#capturing-output-from-commands",
    "href": "lessons/shell-intro/shell-intro.html#capturing-output-from-commands",
    "title": "Introduction to the Unix Shell",
    "section": "Capturing output from commands",
    "text": "Capturing output from commands\n\nOutput page by page with less\nWe’ll continue to use cat in this lesson, for convenience and consistency, but it has the disadvantage that it always dumps the whole file onto your screen. More useful in practice is the command less (e.g. less lengths.txt). This displays a screenful of the file, and then stops. You can go forward one screenful by pressing the spacebar, or back one by pressing b. Press q to quit.\nWhich of these files contains the fewest lines? It’s an easy question to answer when there are only six files, but what if there were 6000? Our first step toward a solution is to run the command:\n$ wc -l *.pdb &gt; lengths.txt\nThe greater than symbol, &gt;, tells the shell to redirect the command’s output to a file instead of printing it to the screen. This command prints no screen output, because everything that wc would have printed has gone into the file lengths.txt instead. If the file doesn’t exist prior to issuing the command, the shell will create the file. If the file exists already, it will be silently overwritten, which may lead to data loss. Thus, redirect commands require caution.\nls lengths.txt confirms that the file exists:\n$ ls lengths.txt\nlengths.txt\nWe can now send the content of lengths.txt to the screen using cat lengths.txt. The cat command gets its name from ‘concatenate’ i.e. join together, and it prints the contents of files one after another. There’s only one file in this case, so cat just shows us what it contains:\n$ cat lengths.txt\n  20  cubane.pdb\n  12  ethane.pdb\n   9  methane.pdb\n  30  octane.pdb\n  21  pentane.pdb\n  15  propane.pdb\n 107  total\n\n\nFiltering output\nNext we’ll use the sort command to sort the contents of the lengths.txt file. But first we’ll do an exercise to learn a little about the sort command:\n\n\n\n\n\n\nChallenge: What does sort -n do?\n\n\n\nThe file shell-lesson-data/exercise-data/numbers.txt contains the following lines:\n10\n2\n19\n22\n6\nIf we run sort on this file, the output is:\n10\n19\n2\n22\n6\nIf we run sort -n on the same file, we get this instead:\n2\n6\n10\n19\n22\nExplain why -n has this effect.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -n option specifies a numerical rather than an alphanumerical sort.\n\n\n\n\n\nWe will also use the -n option to specify that the sort is numerical instead of alphanumerical. This does not change the file; instead, it sends the sorted result to the screen:\n$ sort -n lengths.txt\n  9  methane.pdb\n 12  ethane.pdb\n 15  propane.pdb\n 20  cubane.pdb\n 21  pentane.pdb\n 30  octane.pdb\n107  total\nWe can put the sorted list of lines in another temporary file called sorted-lengths.txt by putting &gt; sorted-lengths.txt after the command, just as we used &gt; lengths.txt to put the output of wc into lengths.txt. Once we’ve done that, we can run another command called head to get the first few lines in sorted-lengths.txt:\n$ sort -n lengths.txt &gt; sorted-lengths.txt\n$ head -n 1 sorted-lengths.txt\n  9  methane.pdb\nUsing -n 1 with head tells it that we only want the first line of the file; -n 20 would get the first 20, and so on. Since sorted-lengths.txt contains the lengths of our files ordered from least to greatest, the output of head must be the file with the fewest lines.\n\n\n\n\n\n\nRedirecting to the same file\n\n\n\nIt’s a very bad idea to try redirecting the output of a command that operates on a file to the same file. For example:\n$ sort -n lengths.txt &gt; lengths.txt\nDoing something like this may give you incorrect results and/or delete the contents of lengths.txt.\n\n\n\n\n\n\n\n\nChallenge: What Does &gt;&gt; Mean?\n\n\n\nWe have seen the use of &gt;, but there is a similar operator &gt;&gt; which works slightly differently. We’ll learn about the differences between these two operators by printing some strings. We can use the echo command to print strings e.g.\n$ echo The echo command prints text\nThe echo command prints text\nNow test the commands below to reveal the difference between the two operators:\n$ echo hello &gt; testfile01.txt\nand:\n$ echo hello &gt;&gt; testfile02.txt\nHint: Try executing each command twice in a row and then examining the output files.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIn the first example with &gt;, the string ‘hello’ is written to testfile01.txt, but the file gets overwritten each time we run the command.\nWe see from the second example that the &gt;&gt; operator also writes ‘hello’ to a file (in this case testfile02.txt), but appends the string to the file if it already exists (i.e. when we run it for the second time).\n\n\n\n\n\n\n\n\n\n\n\nChallenge: appending data\n\n\n\nWe have already met the head command, which prints lines from the start of a file. tail is similar, but prints lines from the end of a file instead.\nConsider the file shell-lesson-data/exercise-data/animal-counts/animals.csv. After these commands, select the answer that corresponds to the file animals-subset.csv:\n$ head -n 3 animals.csv &gt; animals-subset.csv\n$ tail -n 2 animals.csv &gt;&gt; animals-subset.csv\n\nThe first three lines of animals.csv\nThe last two lines of animals.csv\nThe first three lines and the last two lines of animals.csv\nThe second and third lines of animals.csv\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 3 is correct. For option 1 to be correct we would only run the head command. For option 2 to be correct we would only run the tail command. For option 4 to be correct we would have to pipe the output of head into tail -n 2 by doing head -n 3 animals.csv | tail -n 2 &gt; animals-subset.csv",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#passing-output-to-another-command",
    "href": "lessons/shell-intro/shell-intro.html#passing-output-to-another-command",
    "title": "Introduction to the Unix Shell",
    "section": "Passing output to another command",
    "text": "Passing output to another command\nIn our example of finding the file with the fewest lines, we are using two intermediate files lengths.txt and sorted-lengths.txt to store output. This is a confusing way to work because even once you understand what wc, sort, and head do, those intermediate files make it hard to follow what’s going on. We can make it easier to understand by running sort and head together:\n$ sort -n lengths.txt | head -n 1\n  9  methane.pdb\nThe vertical bar, |, between the two commands is called a pipe. It tells the shell that we want to use the output of the command on the left as the input to the command on the right.\nThis has removed the need for the sorted-lengths.txt file.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#combining-multiple-commands",
    "href": "lessons/shell-intro/shell-intro.html#combining-multiple-commands",
    "title": "Introduction to the Unix Shell",
    "section": "Combining multiple commands",
    "text": "Combining multiple commands\nNothing prevents us from chaining pipes consecutively. We can for example send the output of wc directly to sort, and then send the resulting output to head. This removes the need for any intermediate files.\nWe’ll start by using a pipe to send the output of wc to sort:\n$ wc -l *.pdb | sort -n\n   9 methane.pdb\n  12 ethane.pdb\n  15 propane.pdb\n  20 cubane.pdb\n  21 pentane.pdb\n  30 octane.pdb\n 107 total\nWe can then send that output through another pipe, to head, so that the full pipeline becomes:\n$ wc -l *.pdb | sort -n | head -n 1\n   9  methane.pdb\nThis is exactly like a mathematician nesting functions like log(3x) and saying ‘the log of three times x’. In our case, the algorithm is ‘head of sort of line count of *.pdb’.\nThe redirection and pipes used in the last few commands are illustrated below:\n\n\n\n\n\n\n\nChallenge: Piping commands together\n\n\n\nIn our current directory, we want to find the 3 files which have the least number of lines. Which command listed below would work?\n\nwc -l * &gt; sort -n &gt; head -n 3\nwc -l * | sort -n | head -n 1-3\nwc -l * | head -n 3 | sort -n\nwc -l * | sort -n | head -n 3\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4 is the solution. The pipe character | is used to connect the output from one command to the input of another. &gt; is used to redirect standard output to a file. Try it in the shell-lesson-data/exercise-data/alkanes directory!",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#tools-designed-to-work-together",
    "href": "lessons/shell-intro/shell-intro.html#tools-designed-to-work-together",
    "title": "Introduction to the Unix Shell",
    "section": "Tools designed to work together",
    "text": "Tools designed to work together\nThis idea of linking programs together is why Unix has been so successful. Instead of creating enormous programs that try to do many different things, Unix programmers focus on creating lots of simple tools that each do one job well, and that work well with each other. This programming model is called ‘pipes and filters’. We’ve already seen pipes; a filter is a program like wc or sort that transforms a stream of input into a stream of output. Almost all of the standard Unix tools can work this way. Unless told to do otherwise, they read from standard input, do something with what they’ve read, and write to standard output.\nThe key is that any program that reads lines of text from standard input and writes lines of text to standard output can be combined with every other program that behaves this way as well. You can and should write your programs this way so that you and other people can put those programs into pipes to multiply their power.\n\n\n\n\n\n\nChallenge: Pipe Reading Comprehension\n\n\n\nA file called animals.csv (in the shell-lesson-data/exercise-data/animal-counts folder) contains the following data:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nWhat text passes through each of the pipes and the final redirect in the pipeline below? Note, the sort -r command sorts in reverse order.\n$ cat animals.csv | head -n 5 | tail -n 3 | sort -r &gt; final.txt\nHint: build the pipeline up one command at a time to test your understanding\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe head command extracts the first 5 lines from animals.csv. Then, the last 3 lines are extracted from the previous 5 by using the tail command. With the sort -r command those 3 lines are sorted in reverse order. Finally, the output is redirected to a file: final.txt. The content of this file can be checked by executing cat final.txt. The file should contain the following lines:\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-05,raccoon,7\n\n\n\n\n\n\n\n\n\n\n\nChallenge: Pipe Construction\n\n\n\nFor the file animals.csv from the previous exercise, consider the following command:\n$ cut -d , -f 2 animals.csv\nThe cut command is used to remove or ‘cut out’ certain sections of each line in the file, and cut expects the lines to be separated into columns by a Tab character. A character used in this way is called a delimiter. In the example above we use the -d option to specify the comma as our delimiter character. We have also used the -f option to specify that we want to extract the second field (column). This gives the following output:\ndeer\nrabbit\nraccoon\nrabbit\ndeer\nfox\nrabbit\nbear\nThe uniq command filters out adjacent matching lines in a file. How could you extend this pipeline (using uniq and another command) to find out what animals the file contains (without any duplicates in their names)?\n\n\n\n\n\n\nSolution\n\n\n\n\n\n$ cut -d , -f 2 animals.csv | sort | uniq\n\n\n\n\n\n\n\n\n\n\n\nChallenge: Which Pipe?\n\n\n\nThe file animals.csv contains 8 lines of data formatted as follows:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n...\nThe uniq command has a -c option which gives a count of the number of times a line occurs in its input. Assuming your current directory is shell-lesson-data/exercise-data/animal-counts, what command would you use to produce a table that shows the total count of each type of animal in the file?\n\nsort animals.csv | uniq -c\nsort -t, -k2,2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c | wc -l\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4. is the correct answer. If you have difficulty understanding why, try running the commands, or sub-sections of the pipelines (make sure you are in the shell-lesson-data/exercise-data/animal-counts directory).",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#your-pipeline-checking-files",
    "href": "lessons/shell-intro/shell-intro.html#your-pipeline-checking-files",
    "title": "Introduction to the Unix Shell",
    "section": "Your Pipeline: Checking Files",
    "text": "Your Pipeline: Checking Files\nYou have run your samples through the assay machines and created 17 files in the north-pacific-gyre directory described earlier. As a quick check, starting from the shell-lesson-data directory, you type:\n$ cd north-pacific-gyre\n$ wc -l *.txt\nThe output is 18 lines that look like this:\n300 NENE01729A.txt\n300 NENE01729B.txt\n300 NENE01736A.txt\n300 NENE01751A.txt\n300 NENE01751B.txt\n300 NENE01812A.txt\n... ...\nNow you type this:\n$ wc -l *.txt | sort -n | head -n 5\n 240 NENE02018B.txt\n 300 NENE01729A.txt\n 300 NENE01729B.txt\n 300 NENE01736A.txt\n 300 NENE01751A.txt\nWhoops: one of the files is 60 lines shorter than the others. When you go back and check it, you see that you did that assay at 8:00 on a Monday morning — someone was probably in using the machine on the weekend, and you forgot to reset it. Before re-running that sample, you check to see if any files have too much data:\n$ wc -l *.txt | sort -n | tail -n 5\n 300 NENE02040B.txt\n 300 NENE02040Z.txt\n 300 NENE02043A.txt\n 300 NENE02043B.txt\n5040 total\nThose numbers look good — but what’s that ‘Z’ doing there in the third-to-last line? All of your samples should be marked ‘A’ or ‘B’; by convention, your lab uses ‘Z’ to indicate samples with missing information. To find others like it, you do this:\n$ ls *Z.txt\nNENE01971Z.txt    NENE02040Z.txt\nSure enough, when you check the log on your laptop, there’s no depth recorded for either of those samples. Since it’s too late to get the information any other way, you must exclude those two files from your analysis. You could delete them using rm, but there are actually some analyses you might do later where depth doesn’t matter, so instead, you’ll have to be careful later on to select files using the wildcard expressions NENE*A.txt NENE*B.txt.\n\n\n\n\n\n\nKey Points\n\n\n\n\nwc counts lines, words, and characters in its inputs.\ncat displays the contents of its inputs.\nsort sorts its inputs.\nhead displays the first 10 lines of its input by default without additional arguments.\ntail displays the last 10 lines of its input by default without additional arguments.\ncommand &gt; [file] redirects a command’s output to a file (overwriting any existing content).\ncommand &gt;&gt; [file] appends a command’s output to a file.\n[first] | [second] is a pipeline: the output of the first command is used as the input to the second.\nThe best way to use the shell is to use pipes to combine simple single-purpose programs (filters).’ll have to be careful later on to select files using the wildcard expressions NENE*A.txt NENE*B.txt.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#your-pipeline-processing-files",
    "href": "lessons/shell-intro/shell-intro.html#your-pipeline-processing-files",
    "title": "Introduction to the Unix Shell",
    "section": "Your pipeline: Processing files",
    "text": "Your pipeline: Processing files\nYou are now ready to process your data files using goostats.sh — a shell script written by your supervisor. This calculates some statistics from a protein sample file and takes two arguments:\n\nan input file (containing the raw data)\nan output file (to store the calculated statistics)\n\nSince you are still learning how to use the shell, you decides to build up the required commands in stages. Your first step is to make sure that you can select the right input files — remember, these are ones whose names end in ‘A’ or ‘B’, rather than ‘Z’. Moving to the north-pacific-gyre directory, you type:\n$ cd\n$ cd Desktop/shell-lesson-data/north-pacific-gyre\n$ for datafile in NENE*A.txt NENE*B.txt\n&gt; do\n&gt;     echo $datafile\n&gt; done\nNENE01729A.txt\nNENE01736A.txt\nNENE01751A.txt\n\n...\nNENE02040B.txt\nNENE02043B.txt\nYour next step is to decide what to call the files that the goostats.sh analysis program will create. Prefixing each input file’s name with ‘stats’ seems simple, so you modify your loop to do that:\n$ for datafile in NENE*A.txt NENE*B.txt\n&gt; do\n&gt;     echo $datafile stats-$datafile\n&gt; done\nNENE01729A.txt stats-NENE01729A.txt\nNENE01736A.txt stats-NENE01729A.txt\nNENE01751A.txt stats-NENE01729A.txt\n...\nNENE02040B.txt stats-NENE02040B.txt\nNENE02043B.txt stats-NENE02043B.txt\nYou haven’t actually run goostats.sh yet, but now you’re sure you can select the right files and generate the right output filenames.\nTyping in commands over and over again is becoming tedious, though, and you are worried about making mistakes, so instead of re-entering your loop, you press ↑. In response, the shell re-displays the whole loop on one line (using semi-colons to separate the pieces):\n$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\nUsing the ←, you navigate to the echo command and change it to bash goostats.sh:\n$ for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\nWhen you press Enter, the shell runs the modified command. However, nothing appears to happen — there is no output. After a moment, you realize that since your script doesn’t print anything to the screen any longer, you has no idea whether it is running, much less how quickly. You kill the running command by typing Ctrl+C, uses ↑ to repeat the command, and edit it to read:\n$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile;\nbash goostats.sh $datafile stats-$datafile; done\n\n\n\n\n\n\nBeginning and end\n\n\n\nWe can move to the beginning of a line in the shell by typing Ctrl+A and to the end using Ctrl+E.\n\n\nWhen you run your program now, it produces one line of output every five seconds or so:\nNENE01729A.txt\nNENE01736A.txt\nNENE01751A.txt\n...\n1518 times 5 seconds, divided by 60, tells her that her script will take about two hours to run. As a final check, you open another terminal window, go into north-pacific-gyre, and uses cat stats-NENE01729B.txt to examine one of the output files. It looks good, so you decides to get some coffee and catch up on your reading.\n\n\n\n\n\n\nThose who know history can choose to repeat it\n\n\n\nAnother way to repeat previous work is to use the history command to get a list of the last few hundred commands that have been executed, and then to use !123 (where ‘123’ is replaced by the command number) to repeat one of those commands. For example, if you types this:\n$ history | tail -n 5\n456  for datafile in NENE*A.txt NENE*B.txt; do   echo $datafile stats-$datafile; done\n457  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\n458  for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\n459  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile; bash goostats.sh $datafile\nstats-$datafile; done\n460  history | tail -n 5\nthen you can re-run goostats.sh on the files simply by typing !459.\n\n\n\n\n\n\n\n\nMore history commands\n\n\n\nThere are a number of other shortcut commands for getting at the history.\n\nCtrl+R enters a history search mode ‘reverse-i-search’ and finds the most recent command in your history that matches the text you enter next. Press Ctrl+R one or more additional times to search for earlier matches. You can then use the left and right arrow keys to choose that line and edit it then hit Return to run the command.\n!! retrieves the immediately preceding command (you may or may not find this more convenient than using ↑)\n!$ retrieves the last word of the last command. That’s useful more often than you might expect: after bash goostats.sh NENE01729B.txt stats-NENE01729B.txt, you can type less !$ to look at the file stats-NENE01729B.txt, which is quicker than doing ↑ and editing the command-line.\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA for loop repeats commands once for every thing in a list.\nEvery for loop needs a variable to refer to the thing it is currently operating on.\nUse $name to expand a variable (i.e., get its value). ${name} can also be used.\nDo not use spaces, quotes, or wildcard characters such as ‘*’ or ‘?’ in filenames, as it complicates variable expansion.\nGive files consistent names that are easy to match with wildcard patterns to make it easy to select them for looping.\nUse the up-arrow key to scroll up through previous commands to edit and repeat them.\nUse Ctrl+R to search through the previously entered commands.\nUse history to display recent commands, and ![number] to repeat a command by number.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#your-pipeline-creating-a-script",
    "href": "lessons/shell-intro/shell-intro.html#your-pipeline-creating-a-script",
    "title": "Introduction to the Unix Shell",
    "section": "Your pipeline: Creating a script",
    "text": "Your pipeline: Creating a script\nYour supervisor insisted that all your analytics must be reproducible. The easiest way to capture all the steps is in a script.\nFirst we return to your project directory:\n$ cd ../../north-pacific-gyre/\nYou create a file using nano …\n$ nano do-stats.sh\n…which contains the following:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone\nYou save this in a file called do-stats.sh so that you can now re-do the first stage of your analysis by typing:\n$ bash do-stats.sh NENE*A.txt NENE*B.txt\nYou can also do this:\n$ bash do-stats.sh NENE*A.txt NENE*B.txt | wc -l\nso that the output is just the number of files processed rather than the names of the files that were processed.\nOne thing to note about your script is that it lets the person running it decide what files to process. You could have written it as:\n# Calculate stats for Site A and Site B data files.\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone\nThe advantage is that this always selects the right files: you doesn’t have to remember to exclude the ‘Z’ files. The disadvantage is that it always selects just those files — you can’t run it on all files (including the ‘Z’ files), or on the ‘G’ or ‘H’ files your colleagues in Antarctica are producing, without editing the script. If you wanted to be more adventurous, you could modify your script to check for command-line arguments, and use NENE*A.txt NENE*B.txt if none were provided. Of course, this introduces another tradeoff between flexibility and complexity.\n\n\n\n\n\n\nChallenge: Variables in shell scripts\n\n\n\nIn the alkanes directory, imagine you have a shell script called script.sh containing the following commands:\nhead -n $2 $1\ntail -n $3 $1\nWhile you are in the alkanes directory, you type the following command:\n$ bash script.sh '*.pdb' 1 1\nWhich of the following outputs would you expect to see?\n\nAll of the lines between the first and the last lines of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file in the alkanes directory\nAn error because of the quotes around *.pdb\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe correct answer is 2.\nThe special variables $1, $2 and $3 represent the command line arguments given to the script, such that the commands run are:\n$ head -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\n$ tail -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\nThe shell does not expand '*.pdb' because it is enclosed by quote marks. As such, the first argument to the script is '*.pdb' which gets expanded within the script by head and tail\n\n\n\n\n\n\n\n\n\n\n\nChallenge: Find the longest file with a given extension\n\n\n\nWrite a shell script called longest.sh that takes the name of a directory and a filename extension as its arguments, and prints out the name of the file with the most lines in that directory with that extension. For example:\n$ bash longest.sh shell-lesson-data/exercise-data/alkanes pdb\nwould print the name of the .pdb file in shell-lesson-data/exercise-data/alkanes that has the most lines.\nFeel free to test your script on another directory e.g.\n$ bash longest.sh shell-lesson-data/exercise-data/writing txt\n\n\n\n\n\n\nSolution\n\n\n\n\n\n# Shell script which takes two arguments:\n#    1. a directory name\n#    2. a file extension\n# and prints the name of the file in that directory\n# with the most lines which matches the file extension.\n\nwc -l $1/*.$2 | sort -n | tail -n 2 | head -n 1\nThe first part of the pipeline, wc -l $1/*.$2 | sort -n, counts the lines in each file and sorts them numerically (largest last). When there’s more than one file, wc also outputs a final summary line, giving the total number of lines across all files. We use tail -n 2 | head -n 1 to throw away this last line.\nWith wc -l $1/*.$2 | sort -n | tail -n 1 we’ll see the final summary line: we can build our pipeline up in pieces to be sure we understand the output.\n\n\n\n\n\n\n\n\n\n\n\nChallenge: Script reading comprehension\n\n\n\nFor this question, consider the shell-lesson-data/exercise-data/alkanes directory once again. This contains a number of .pdb files in addition to any other files you may have created. Explain what each of the following three scripts would do when run as bash script1.sh *.pdb, bash script2.sh *.pdb, and bash script3.sh *.pdb respectively.\n# Script 1\necho *.*\n# Script 2\nfor filename in $1 $2 $3\ndo\n    cat $filename\ndone\n# Script 3\necho $@.pdb\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIn each case, the shell expands the wildcard in *.pdb before passing the resulting list of file names as arguments to the script.\nScript 1 would print out a list of all files containing a dot in their name. The arguments passed to the script are not actually used anywhere in the script.\nScript 2 would print the contents of the first 3 files with a .pdb file extension. $1, $2, and $3 refer to the first, second, and third argument respectively.\nScript 3 would print all the arguments to the script (i.e. all the .pdb files), followed by .pdb. $@ refers to all the arguments given to a shell script.\ncubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb.pdb\n\n\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nSave commands in files (usually called shell scripts) for re-use.\nbash [filename] runs the commands saved in a file.\n$@ refers to all of a shell script’s command-line arguments.\n$1, $2, etc., refer to the first command-line argument, the second command-line argument, etc.\nPlace variables in quotes if the values might have spaces in them.\nLetting users decide what files to process is more flexible and more consistent with built-in Unix commands.",
    "crumbs": [
      "Introduction to the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/github/exercise1.html",
    "href": "lessons/github/exercise1.html",
    "title": "Exercise 1: Practice with git on a local repository",
    "section": "",
    "text": "In this exercise you will initialize a git repository on your computer and explore various git commands with it.\n\nPart 1: Initializing and adding files\n\nGo to your home directory by typing:\ncd\nCreate a directory called test-git-repo and cd into it:\nmkdir test-git-repo\ncd test-git-repo\nAt the moment, test-git-repo is just a normal directory, like any others. We want to turn this into a git repository and track changes to files made in this directory. To do that, run:\ngit init\nNote that you have to run this from within the directory you want to turn into a repository.\ntest-git-repo is now tracked by git. Run:\ngit status\nto see what the status of the repo is. You should get:\nOn branch main\n\nNo commits yet\n\nnothing to commit (create/copy files and use \"git add\" to track)\nLet’s add some files for git to track. Use your favorite text editor to create a file called story.txt and add the following to it:\nOnce upon a time, in a land far,\nfar away...\nSave and exit the file, then type ls to verify it’s there. Now run\ngit status\nagain. You should have:\nOn branch main\n\nNo commits yet\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n    story.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\ngit knows you have a file in the directory called story.txt, but it isn’t tracked by git yet!\nTell git to start tracking story.txt by using git add. Run the following:\ngit add story.txt\nNow type git status. You’ll see:\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached &lt;file&gt;...\" to unstage)\n    new file:   story.txt\nNotice that it still says there are no commits, but that on the next commit the file story.txt will be added. This means that story.txt is staged for the next commit.\nCommit the change by running:\ngit commit -m \"add story idea\"\nNow run git status. You should get nothing to commit, working tree clean. Congratulations, you’ve made your first commit! To verify, run:\ngit log\nto see the history of your commits. Since this is your first commit, there will only be one entry.\n\n\n\nPart 2: Making changes to files\n\nYou’re not happy with your story opening. You don’t want to write fairy tales, you want to write SciFi! Use your favorite text editor to open story.txt and change the line Once upon a time, in a land far, to A long time ago in a galaxy far, so that your file now reads:\nA long time ago in a galaxy far,\nfar away...\nMuch better. Now type git status; you should see:\nOn branch main\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n    modified:   story.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\ngit recognizes that story.txt has changed, but your changes have not been committed yet. You can see how the file differs from the last commit you did by typing:\ngit diff\nLet’s commit your changes so you don’t lose them! We’ll stage the changes by running git add again:\ngit add story.txt\n(Alternatively, you can just run git add -u to stage changes to all tracked files that have changed.) Now we’ll commit the change, however, we’ll do it slightly differently than we did above. Just run:\ngit commit\n(i.e., don’t include the -m argument). This will cause a text editor to open. The text editor that is used depends on your git settings. Since we set git’s global core.editor to nano in the intro, nano will open up for you. Now you can type in a commit message. Type “change opening” then save by hitting &lt;Ctrl&gt;+O. When nano asks where to save to, just hit &lt;Enter&gt; to save to the default. Then hit &lt;Ctrl&gt;+X to exit. This will complete the commit; you will be returned to the command line. To verify that the commit worked, run:\ngit log\nYou’ll now see 2 commits in your history.\n\n\n\n\n\n\n\nNote\n\n\n\nNote that there are two different ways to provide a commit message:\n\nProvide the -m argument along with a short message in quotes when you run git commit on the command line, like we did in Part 1, step 7 above; i.e, run:\ngit commit -m \"YOUR MESSAGE\"\nIn that case, the commit will be completed on the command line; no text editor will be opened.\nDo not provide the -m argument. In that case, a text editor will open with which you can type the commit message. The commit will be created as soon as you save and exit from the editor. Note that if you exit the editor without saving, the commit will not be created. (You will be returned to the command line with the file changes still in the staged state.)\n\nEither way is fine. Typically the second method is used if you want to write a more elaborate commit message that spans multiple lines, which is difficult to do on the command line.\n\n\n\n\nPart 3: Branches\nYou want to start working on titles for your stories, but you want to do it independently of your work on the story itself. To do that, let’s create a branch to specifically work on titles.\n\nRun git branch. You should get back:\n* main\nThis means there is currently only one branch, called main. The * next to main means that you are currently on the main branch. Let’s create a new branch for working on the titles. Run:\ngit checkout -b title-dev\nYou’ll get Switched to a new branch 'title-dev'. To verify, run git branch again. Now you should see:\n  main\n* title-dev\nNotice that story.txt is still here (type ls) and that your git history is the same as before (type git log). This is because when you create a branch, the branch will have all the same history and files as the main branch.\nLet’s create a file to store our title idea. Use your favorite text editor to create a file called title.txt and put in it:\nSTAR FIGHT!\n(You can also use echo and the &gt; operator on the command line to do this.) The title’s not great, but you can’t think of anything better at the moment.\nNow that you’ve created the file, run git status; you should see that title.txt is untracked. Add it to be tracked and commit:\ngit add title.txt\ngit commit -m \"add title idea\"\nNow type git log; you’ll see you have 3 commits in your history.\nSatisfied with your title for now, go back to your main branch to work on your story some more. Switch back to the main branch by running:\ngit checkout main\n(Notice that we don’t include the -b flag this time. This is because main already exists; we only add the -b when we want to create a new branch.) Verify that you’re on main by running git branch; you should get:\n* main\n  title-dev\nNote that the * is now next to main.\nNow type ls. The title.txt file is gone! To see why, type git log. Your last commit is no longer in your history; you just have the first two commits. This is because your last commit (and the file it created, title.txt) only exists on the title-dev branch. To verify that it’s still there, you check the history of the title-dev branch by running:\ngit log title-dev\nIn graph form, your repository currently looks like this:\n\nHere, each dot represents a commit, and the different lines represent a different branch. Following a line illustrates the history as seen by that branch. Since the commits on title-dev live on their own branch, changes you make on main won’t affect title-dev and vice versa (at least not until we merge the branches; more on that below).\n\n\n\n\n\n\n\nTip\n\n\n\nYou can git graphs like the above in your terminal if you add --graph to the git log command; i.e.\ngit log --graph\n\n\n\nLet’s make some more changes to story.txt. Use your favorite text editor to open story.txt and add the following lines:\n\nIt is period of civil war.\nRebel spaceships, striking\nfrom a hidden base, have won\ntheir first victory against\nthe evil Galactic Empire.\nStage the change and commit it:\ngit add -u\ngit commit -m \"add intro paragraph\"\nNow type git log: you should have 3 commits, none of which include the commits to title-dev branch.\nIn a flash of brilliance, you get an idea for the title of your story. Quick! Switch to your title-dev branch by typing:\ngit checkout title-dev\nYou can verify that you’re on the title-dev branch by typing git branch. Now use your favorite text editor to open title.txt and change STAR FIGHT! to:\nStar Wars\nA NEW HOPE\n\nby\nGeorge Lucas\nNice work, George! Now save and exit. Stage the change and commit it:\ngit add -u\ngit commit -m \"update title\"\nType git log to check your history. Note that there are 4 commits here: the first two from main (before you branched off), and the last two on title-dev. In graph form, your repo looks like this:\n\nSatisfied that your title is perfect, you no longer feel the need to keep the title development on a separate branch. It’s ready to be merged on to the main branch. To do that, switch to the main branch:\ngit checkout main\nand merge in the changes on title-dev by typing:\ngit merge title-dev\nThis will open up your text editor (which we set to nano in the intro). Don’t change the commit message, just save and exit to return to your terminal.\nNow type git log. You should see 6 commits: the initial two commits on main, the first commit on title-dev, the add paragraph commit on main, and the update title commit you made on title-dev, followed by an additional “Merge” commit. This final “merge” commit is to indicate that some of the commits in the history came from another branch (and what the name of the branch was).\nIf you type:\nls\nyou’ll see that both story.txt and title.txt are in your directory (on the main branch), and if you look in them, you’ll see the most up-to-date versions of both. In graph form, your main branch now looks like:\n\n\n\n\n\n\n\n\nNote\n\n\n\nThere is another way to merge branches called rebasing. Rebasing changes the history of the development branch to make it look like all the commits came after the last commit on main. This makes for a cleaner history when merging, but can be more challenging to do correctly. See the Appendix (below) for more information.\n\n\n\nNow that you’ve merged your title-dev branch, you can delete it to save space. To do that, run:\ngit branch -d title-dev\n\n\n\n\n\n\n\nNote\n\n\n\nIf you had not merged everything on title-dev into main, you would have gotten an error preventing you from deleting the branch. The fact that you could delete it gives you confidence that everything on the development branch has been merged.\n\n\n\n\nChallenge Questions: Editing the same file on different branches\nIn the above example we only made changes to different files on our two branches: on main we only edited story.txt, while on title-dev we only edited title.txt. However, there is nothing stopping us from editing the same file concurrently on two different branches. The following questions will illustrate how that works.\n\n\n\n\n\n\nQuestion 1: Setup\n\n\n\nCreate a file called list.txt that initially contains the following three lines:\nalpha\nbravo\ncharlie\nNow use the git commands you learned above to do the following:\n\nAdd and commit list.txt to main.\nCreate a branch called dev1.\nOn dev1 change the first line of list.txt to delta then commit the change.\nGo back to main and change the third line to foxtrot, then commit it.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nRun:\ngit add list.txt\ngit commit -m \"add list.txt\"\nRun:\ngit checkout -b dev1\nUse nano (or your favorite text editor) to edit list.txt and change the first line to delta. Then run:\ngit add list.txt\ngit commit -m \"change the first item of list\"\nFirst run:\ngit checkout main\nThen use nano (or your favorite text editor) to edit list.txt and change the third line to foxtrot. To commit, run:\ngit add list.txt\ngit commit -m \"change the last item of list\"\n\n\n\n\nWhen you are done, list.txt should look like the following on main:\nalpha\nbravo\nfoxtrot\nwhile on dev1 it should look like:\ndelta\nbravo\ncharlie\nYou can check the differences by running git diff main dev1.\n\n\n\n\n\n\n\n\nQuestion 2: Editing different lines\n\n\n\nNow suppose you merge dev1 into main. What happens to list.txt?\nA. main takes precedence since it’s the branch being merged into; list.txt will look like:\nalpha\nbravo\nfoxtrot\nB. dev1 takes precedence since it’s the branch being merged; list.txt will look like:\ndelta\nbravo\ncharlie\nC. The changes from both are adopted; list.txt will look like:\ndelta\nbravo\nfoxtrot\nD. An error is raised because the same file was modified.\nIf you’re not sure, try it yourself and see what happens!\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe answer is C. Since different lines have been modified, git is able to merge the changes together without issue. To do it yourself, run:\ngit checkout main\ngit merge dev1\n\n\n\n\n\n\n\n\n\n\n\nQuestion 3: Editing the same lines\n\n\n\nAfter merging dev1 on to main, suppose you create another branch called dev2. On dev2 you change the second line of list.txt to be echo while on main you change the second line to easy; i.e. on main list.txt looks like:\ndelta\neasy\nfoxtrot\nOn dev2 list.txt looks like:\ndelta\necho\nfoxtrot\nWhat happens if you merge dev2 into main in this case?\nA. main takes precedence since it’s the branch being merged into; list.txt will look like:\ndelta\neasy\nfoxtrot\nB. dev2 takes precedence since it’s the branch being merged; list.txt will look like:\ndelta\necho\nfoxtrot\nC. The changes from both branches are adopted; list.txt will look like:\ndelta\neasy\necho\nfoxtrot\nD. An error is raised because the same line is modified.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe answer is D, an error is raised. Since the same line has been modified in the same file, git cannot tell how to reconcile the differences. This is known as a merge conflict. In this case, git will leave it up to the user to reconcile the differences. How to do that is discussed in the next section.\n\n\n\n\n\n\n\nPart 4: Resolving merge conflicts\nAs illustrated in the Challenge Questions, if the same lines in the same file are modified on two different branches, git will not know how to merge the changes. This is called a merge conflict. In this case, git will ask you to reconcile the differences. To illustrate, let’s try merging dev2 into main after making the changes to list.txt discussed in Question 3 above:\n\nIf you have not done so, try to merge dev2 into main after making the changes to the second line of list.txt discussed in Question 3:\ngit checkout main\ngit merge dev2\nYou should get the following:\nAuto-merging list.txt\nCONFLICT (content): Merge conflict in list.txt\nAutomatic merge failed; fix conflicts and then commit the result.\nTo resolve the merge conflict, we must edit list.txt ourselves. Use nano (or your favorite text editor) to open list.txt. You should see the following:\ndelta\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\neasy\n=======\necho\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev2\nfoxtrot\ngit has added the conflicting lines from both branches to the file, along with information about the two branches. The line as it appears on main is prefaced with &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD. This indicates that the following line(s) is (are) how it appears on the branch being merged into. The line(s) is (are) followed by a =======.\nAfter the ======= the line(s) as it/they appear(s) on the branch being merged are shown. These are followed by &gt;&gt;&gt;&gt;&gt;&gt;&gt; BRANCH_NAME (here, BRANCH_NAME is dev2).\nWe are free to edit the file anyway we like to resolve the conflict. You should remove the &lt;&lt;&lt;&lt;, ====, and &gt;&gt;&gt;&gt; lines that git has added, along with the edit you want to make to resolve the conflict.\nIn this case, let’s keep the edit as it appears on dev2, and remove the edit on main. Delete the appropriate lines so that the file looks like:\ndelta\necho\nfoxtrot\nThen save and exit the file.\nNow that we are happy with the way list.txt appears, add the file:\ngit add list.txt\nNow commit without the -m:\ngit commit\nThis will open up your text editor. The commit message will already be set to Merge branch 'dev2'. While you are free to modify this, it’s usually best to leave it as-is, as it indicates the merge. Save and exit the file.\nThe merge conflict is resolved! If you type git log you will see the history with all the commits in it, as if you had a merged without any issue.\n\nMerge conflicts happen, but can be fixed fairly easy. If there were multiple areas in a file that caused a conflict, the conflicting areas would all be surrounded by the same &lt;&lt;&lt;&lt;&lt;&lt;&lt;/=======/&gt;&gt;&gt;&gt;&gt;&gt;&gt; lines that we saw above. You’ll want to search through the file for those to make sure you got all the conflicts. If multiple files had conflicts, git will make you resolve all of them before allowing the merge to complete.\n\n\nSummary\nThat’s the basics of how to use git. In the following parts we’ll see how to use this with GitHub and how to collaborate with partners using git and GitHub.\n\n\nAppendix: Rebasing\nBefore merging title-dev into master in step 8 above, we could have first done a rebase. If you rebase a development branch against its parent branch (in this case main) it will incorporate all the commits that were made on the parent after the development branch was originally created. To do so, the development branch’s history is rearranged so that the additional commits from the parent are placed before all commits that were made on the development branch.\nFor example, if we had run git rebase main while on the title-dev branch in Part 3, step 8 above, title-dev’s history would have been rearranged from:\n\nto:\n\nThe advantage to rebasing is that when we merge a rebased development branch back into main no “Merge” commit is created, and the history on main is much simpler. So, in our story example, if we had done the following in step 8:\ngit checkout title-dev\ngit rebase main\ngit checkout main\ngit merge title-dev\nThen main’s history would have looked like:\n\nrather than the more complicated graph above.\nThe disadvantage to rebasing is it can be more challenging to handle merge conflicts. When rebasing, conflicts need to be handled at the point they are created in the development branch, rather once at the end when the merge occurs. If resolving a conflict affects a later commit on the development branch, it can cause a cascading series of conflicts that can be a challenge to untangle. The other challenge with rebasing is it can cause issues when collaborating with others on a development branch. Since rebasing changes the history of the branch, it can make it a challenge for your colleagues to keep their clones in sync with yours. For these reasons, rebasing is best for more advanced users.\nFor more on rebasing, see this article by the Atlassian corporation: Merging vs. rebasing.\n\n\n\n\n Back to top",
    "crumbs": [
      "<code>git</code> and GitHub",
      "Exercise 1: Practice with `git` on a local repository"
    ]
  },
  {
    "objectID": "lessons/github/exercise3.html",
    "href": "lessons/github/exercise3.html",
    "title": "Exercise 3: Collaborating in GitHub using the Fork and Pull Model",
    "section": "",
    "text": "Exercise 3: Collaborating in GitHub using the Fork and Pull Model\nIn this exercise you will learn how to collaborate with others using GitHub. You will work with a partner to contribute to the test repository they created on GitHub in Exercise 2 (and they will do the same with your repository!).\n\nFind a partner to work with. Get the web address of the test repository they created in Exercise 2. This is the URL of their repository website (not the ssh URL that they used to clone their repository). The URL should be something like https://github.com/THEIR_USERNAME/THEIR_REPO_NAME where THEIR_USERNAME is your partner’s GitHub username and THEIR_REPO_NAME is the name of the repository they created in Exercise 2. Again, you are going to the website for your partner’s repository, not your own.\nClick the Fork button in the upper right of their website. This will open the “Create a new fork” page.\nOn the “Create a new fork” page:\n\nUnder “Owner” select your username.\nLeave the repository name the same. The Owner / respository name should look like YOUR_USERNAME / THEIR_REPO_NAME.\n\nNow click the green Create fork button in the lower right. This will create a “fork” of your partner’s repository under your own GitHub account. You will be redirected to your fork. Note the URL at the top of the webpage: it should be something like https://github.com/YOUR_USERNAME/THEIR_REPO_NAME.\n\n\n\n\n\n\n\nAbout forks\n\n\n\nA fork is a copy of another user’s GitHub repository. When you create the fork, you create copy of the repository under your GitHub account. The copy of the repository has the entire commit history of the repository up until that point. It is, for all intents and purposes, an exact replica of the original repository, except that the copy is now under your account.\nFrom this point on, your fork is independent of the original. Since it is under your account, you are free to make any changes that you like to — add commits or branches, delete things, etc. — without affecting the original repository. Changes to the original repository also won’t affect your fork unless you actively sync it by using git fetch (more on that below).\nYou can create a fork of any public repository on GitHub!\nThe advantage of using forks is it allows you to develop things without breaking the original repository while you do. This is incredibly useful if you want to contribute to another project that is widely used: you create a fork of that project under your own GitHub account; clone your fork to your local computer; develop your fork by pushing/pulling between your local computer and GitHub. Then, when you are content that your new addition is ready, you fill out a pull request to merge the changes in your fork into the original repository (usually on its main branch). The original repo’s owner(s) can then review your changes, and, if they accept them, merge it into their repository for widespread adoption. This is known as the fork and pull model.\nThe diagram below illustrates the relationship between a fork (on GitHub) and a clone: \n\n\n\nYou want to contribute a new development to your partner’s repository. To do so, first clone your fork of their repository to your local computer:\n\nIf you are not already there, go to your fork’s website on GitHub. The web address should be something like https://github.com/YOUR_USERNAME/THEIR_REPO_NAME.\nOn your fork’s website, click the green &lt;&gt; Code button, then copy the SSH URL. It should be something like git@github.com:YOUR_USERNAME/THEIR_REPO_NAME.git\nGo to your terminal, cd to the directory you want to store your fork, and type:\n\ngit clone SSH_URL\nwhere SSH_URL is the SSH URL you copied.\ncd into the repository you just cloned and type\n\ngit remote -v\nto see the origin URL. Note that the origin for this repository is your fork on GitHub, not your partner’s repository.\n\nNow let’s create a branch called dev2 to add a new feature to the mymath.R file. Create the branch on your local computer by typing:\n\ngit checkout -b dev2\nThis will create and switch to a new branch called dev2. You can verify you’re on the new branch by typing git branch.\n\nUse your favorite text editor to open mymath.R and add the following lines to it:\n\n\nmultiply &lt;- function(a, b) {\n    return (a*b)\n    }\nSave the changes.\n\nCommit your changes by running:\n\ngit add -u\ngit commit -m \"add multiplication function to mymath file\"\n\nThis commit (and the dev2 branch) currently only exists on your local copy of your fork. Push the branch to your fork on GitHub by running:\n\ngit push -u origin dev2\nNote that we had to provide the -u origin dev2 arguments to git push. This is because the dev2 branch does not currently exist on our fork in GitHub. Adding the extra arguments tells git to create a dev2 branch on your fork on GitHub and push the new changes there.\n\nLook at your web browser. As soon as you pushed your changes, you should see a box pop up on your fork’s website on GitHub asking if you would like to file a pull request.\nClick the green Compare & pull request button. This will open up the “Comparing changes” page. Note that in the gray box at the top of the web page the “base” repository is your partner’s* original repository and the base branch is their main branch. This means that you will create a Pull Request on your partner’s repository, and that it will be for merging your changes onto their main branch. You want that!\nFill out the description box if you like and/or change the the “Add a title” box. Then click the green Create pull request button at the bottom.\nAfter you click Create pull request, your partner will see a Pull Request pop up on the GitHub website for their repository. Have them click on the the “Pull Requests” tab at the very top of their website, then click on the pull request.\nYour partner can review your pull request on their GitHub website. If they are satisfied with it, have them click the green button at the bottom of the page, then Confirm, to merge the pull request.\n\nCongratulations! You and your partner have now collaborated on a new feature.\n\nOnce your partner merges the changes, their main branch will update with your new commit. The main branch of your fork will now be out of sync with theirs. To sync it, go to to your GitHub website for your fork (the one with URL https://github.com/YOUR_USERNAME/THEIR_REPO_NAME). You should see a gray dialog box at the top that starts with “This branch is 1 commit behind …”. Click the Sync fork button, then the green Update branch button. This will update your fork’s main branch to be the same as your partner’s.\nUpdate your local copy of your fork. Go to your terminal and, in the repository directory, switch back to the main branch:\n\ngit checkout main\nNow update your main branch by typing:\ngit pull\nThis will update your main to be the same the one on GitHub, which is also the same as your partner’s main branch.\n\nNow that your changes have been merged on to your partner’s main branch and you’ve synced your fork both on GitHub and your computer, you’re free to delete your development branch on your computer. To do so run:\n\ngit branch -d dev2\n\n\n\n\n Back to top",
    "crumbs": [
      "<code>git</code> and GitHub",
      "Exercise 3: Collaborating in GitHub using the Fork and Pull Model"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-intro.html",
    "href": "lessons/r-lessons/r-intro.html",
    "title": "Introduction to R and RStudio",
    "section": "",
    "text": "Today we will use R, but we could have also used Python for the same reasons we chose R (and we teach workshops for both languages). Both R and Python are freely available, the instructions you use to do analyses are easily shared, and by using reproducible practices, it’s straightforward to add more data or to change settings like colors or the size of a plotting symbol.\n\n\n\n\n\n\nWhy R and not Python?\n\n\n\nThere’s no great reason. Although there are subtle differences between the languages, it’s ultimately a matter of personal preference. Both are powerful and popular languages that have very well developed and welcoming communities of scientists that use them. As you learn more about R, you may find things that are annoying in R that aren’t so annoying in Python; the same could be said of learning Python. If the community you work in uses R, then you’re in the right place.\n\n\nTo run R, all you really need is the R program, which is available for computers running the Windows, Mac OS X, or Linux operating systems. You should have downloaded R while getting for this workshop.\n\n\nRStudio\nTo make your life in R easier, there is a great (and free!) program called RStudio that you also downloaded and used during set up. As we work today, we’ll use features that are available in RStudio for writing and running code, managing projects, installing packages, getting help, and much more. It is important to remember that R and RStudio are different, but complementary programs. You need R to use RStudio.\n\n\n\n\n\n\nBonus Exercise: Can you think of a reason you might not want to use RStudio?\n\n\n\n\n\nOn some high-performance computer systems (e.g., Amazon Web Services) you typically can’t get a display like RStudio to open. Your university may have an interactive cluster available, but Syracuse University’s Zest HPC cluster does not permit interactive development. If you need to use RStudio, Syracuse affiliates should check out Google Colab.\n\n\n\nTo get started, we’ll spend a little time getting familiar with the RStudio environment and setting it up to suit your tastes. When you start RStudio, you’ll have three panels.\n\nOn the left you’ll have a panel with three tabs - Console, Terminal, and Jobs. The Console tab is what running R from the command line looks like. This is where you can enter R code. Try typing in 2+2 at the prompt (&gt;). In the upper right panel are tabs indicating the Environment, History, and a few other things. If you click on the History tab, you’ll see the command you ran at the R prompt.\n\nIn the lower right panel are tabs for Files, Plots, Packages, Help, and Viewer. Click on the “Packages” tab. Packages are add-on libraries developed by R community members. Each package contains a suite of functions that, once loaded, can be used within your code. As an exercise, we’ll install the “tidyverse” package, which we’ll end up using a lot in our future sessions. Click the Install button, then type “tidyverse” in the empty box and click the Install button. The installation process may take a few minutes since this is actually installing more than 10 packages and their dependencies (the packages that provide functions that are then used in these packages).\n\n\n\n\n\n\n\nThe tidyverse vs Base R\n\n\n\nIf you’ve used R before, you may have learned commands that are different than the ones we will be using during this workshop. We will be focusing on functions from the tidyverse. The “tidyverse” is a collection of R packages that have been designed to work well together and offer many convenient features that do not come with a fresh install of R (aka “base R”). These packages are very popular and have a lot of developer support including many staff members from RStudio. These functions generally help you to write code that is easier to read and maintain. We believe learning these tools will help you become more productive more quickly.\n\n\nYou can use the Pane Layout menu (accessed from the button that look like a top-down view of a 2x2 ice cube tray) to change where different tabs live. For example, I like to have the plots in the top right panel, so I can see the help docs and the plots at the same time. I also usually switch the positions of the console and editor so that the editor is on the bottom.\n\nWe’ll spend more time in each of these tabs as we go through the workshop, so we won’t spend a lot of time discussing them now.\nYou might want to alter the appearance of your RStudio window. The default appearance has a white background with black text. If you go to the Tools menu at the top of your screen, you’ll see a “Global options” menu at the bottom of the drop down; select that.\n\nFrom there you will see the ability to alter numerous things about RStudio. Under the Appearances tab you can select the theme you like most. As you can see there’s a lot in Global options that you can set to improve your experience in RStudio. Most of these settings are a matter of personal preference.\n\n\n\n\nProjects\nOne of the helpful features in RStudio is the ability to create a project. Projects make it straightforward to divide your work into multiple contexts, each with their own working directory, workspace, history, and scripts. You can create a fresh project, base one on an existing directory, or even build one based on a git repository. Since we’re all git experts now, let’s go with that option.\nFirst, we’ll need to create a GitHub repository. For the rest of the workshop, we’ll be using data collected about adult male and female Adélie (P. adeliae), chinstrap (P. antarcticus), and gentoo (P. papua) penguins on three islands (Biscoe, Dream, and Torgersen) within the Palmer Archipelago. For more information about the collection and handling of these data, see Gorman et al. 2014 and Horst et al. 2022.\nI’ve hosted these data within a fresh repository on GitHub. Like you did in the git and Github session, go ahead and fork this repository so that you have your own personal copy of it.\n\nOnce you’ve forked the repository, copy the URL of the repo and return to RStudio. At the top of your screen you’ll see the “File” menu. Select that menu and then the menu for “New Project…”. (You could also use the second button on the second menu row or even the Project: (None) button in the top right)\n\nWhen the smaller window opens, select “Version Control” and then “Git” in the next window.\n\n\nNow paste your repository URL in the first box, then name your new repo directory in the second box (i.e., the name of the folder containing the repo on your computer; “penguins” is probably a good choice), and finally use the Browse button to select the local directory that you want to create this new directory within (i.e., the parent directory).\n\nThen click the Create Project button.\nDid you notice anything change?\nIn the lower right corner of your RStudio session, you should notice that your Files tab is now your project directory. You’ll also see a file called penguins.Rproj in that directory.\nFrom now on, you should start RStudio by double clicking on that file. This will make sure you are in the correct directory when you run your analysis.\n\n\n\nScripts\nUsing the console is fine, but we’d ideally like to be able to save the R code that we write. This is where scripts and the Editor come in.\nBack in the “File” menu, you’ll see the first option is “New File”. Selecting “New File” opens another menu to the right and the first option is “R Script”. Select “R Script”.\nNow we have a fourth panel in the upper left corner of RStudio that includes an Editor tab with an untitled R Script. Let’s save this file as penguins.R within the “code” directory.\nWe will now be entering all of our R code into the Editor tab to then run it in our Console panel.\nOn line 1 of penguins.R, type 2 + 2.\nWith your cursor on the line with the 2 + 2, click the button that says Run. You should be able to see that 2 + 2 was run in the Console.\nAs you write more code, you can highlight multiple lines and then click Run to run all of the lines you have selected.\nLet’s delete the line with 2+2 and replace it with library(tidyverse).\nGo ahead and run that line in the Console by clicking the Run button on the top right of the Editor tab and choosing Run Selected Lines. This loads a set of useful functions and sample data that makes it easier for us to do complex analyses and create professional visualizations in R.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\n\n\n\n\n\nWhat’s with all those messages???\n\n\n\nWhen you loaded the tidyverse package, you probably got a message like the one we got above. Don’t panic! These messages are just giving you more information about what happened when you loaded tidyverse. The tidyverse is actually a collection of several different packages, so the first section of the message tells us what packages were installed when we loaded tidyverse (these include ggplot2, which we’ll be using a lot in the plotting lesson, and dyplr, which you’ll be introduced to in the data cleaning lesson).\nThe second section of messages gives a list of “conflicts.” Sometimes, the same function name will be used in two different packages, and R has to decide which function to use. For example, our message says that:\ndplyr::filter() masks stats::filter()\nThis means that two different packages (dyplr from tidyverse and stats from base R) have a function named filter(). By default, R uses the function that was most recently loaded, so if we try using the filter() function after loading tidyverse, we will be using the filter() function from dplyr().\n\n\n\n\n\n\n\n\nPro-tip\n\n\n\nThose of us that use R on a daily basis use cheat sheets to help us remember how to use various R functions. If you haven’t already, print out the PDF versions of the cheat sheets that were in the setup instructions.\nYou can also find them in RStudio by going to the “Help” menu and selecting “Cheat Sheets”. The cheat sheets that will be most helpful in this workshop are “Data Visualization with ggplot2”, “Data Transformation with dplyr”, “R Markdown Cheat Sheet”, and “R Markdown Reference Guide”.\nFor things that aren’t on the cheat sheets, Google is your best friend. Even expert coders use Google when they’re stuck or trying something new!\n\n\n\n\n\nLoading and reviewing data\nOne of the most useful aspects of R (and other coding languages) is its ability to work with existing data. We will import one of the penguin data files from the “data” directory called chinstrap_data.csv. There are many ways to import data into R but for your first time we will use RStudio’s file menu to import and display this data. As we move through this process, RStudio will translate these point and click commands into code for us.\nIn RStudio select “File” &gt; “Import Dataset” &gt; “From Text (readr)”.\n\nAs mentioned, the file is located in the “data” directory. Click the Browse button and select the file named chinstrap_data.csv. A preview of the data will appear in the window. You can see there are a lot of Import Options listed, but R has chosen the correct defaults for this particular file.\n\nWe can see in that box that our data will be imported with the Name: “chinstrap_data”. Also note that this screen will show you all the code that will be run when you import your data in the lower right “Code Preview”. Since everything looks good, click the Import button to bring your data into R.\nAfter you’ve imported your data, a table will open in a new tab in the top left corner of RStudio. This is a quick way to browse your data to make sure everything looks like it has been imported correctly. To review the data, click on the new tab.\nAfter you’ve reviewed the data, you’ll want to make sure to click the tab in the upper left to return to your penguins.R file so we can start writing some code.\nNow look in the Environment tab in the upper right corner of RStudio. Here you will see a list of all the objects you’ve created or imported during your R session. You will now see chinstrap_data listed here as well.\nFinally, take a look at the Console at the bottom left part of the RStudio screen. Here you will see the commands that were run for you to import your data in addition to associated metadata and warnings.\n\n\n\n\n\n\nData objects\n\n\n\nThere are many different ways to store data in R. Most objects have a table-like structure with rows and columns. We will refer to these objects generally as “data objects”. If you’ve used R before, you may be used to calling them “data.frames”. Functions from the “tidyverse” such as read_csv work with objects called “tibbles”, which are a specialized kind of “data.frame.” Another common way to store data is a “data.table”. All of these types of data objects (tibbles, data.frames, and data.tables) can be used with the commands we will learn in these. We may sometimes use these terms interchangeably.\n\n\n\n\n\nUnderstanding commands\nLet’s start by looking at the code RStudio ran for us by copying and pasting the second line from the console into our penguins.R file that is open in the Editor window.\n\nchinstrap_data &lt;- read_csv(\"data/chinstrap_data.csv\")\n\nYou should now have a line of text in your code file that started with chinstrap and ends with a ) symbol.\nWhat if we want to run this command from our code file?\nIn order to run code that you’ve typed in the editor, you have a few options. We can click Run again from the right side of the Editor tab but the quickest way to run the code is by pressing Ctrl+Enter on your keyboard (Cmd+Return on Mac).\nThis will run the line of code that currently contains your cursor and will move your cursor to the next line. Note that when Rstudio runs your code, it basically just copies your code from the Editor window to the Console window, just like what happened when we selected Run Selected Line(s).\nLet’s take a closer look at the parts of this command.\nStarting from the left, the first thing we see is chinstrap_data. We viewed the contents of this file after it was imported so we know that chinstrap_data acts as a placeholder for our data.\nIf we highlight just chinstrap_data within our code file and press Ctrl+Enter on our keyboard, what do we see?\nWe should see a data table outputted, similar to what we saw in the Viewer tab.\n\n\n# A tibble: 68 × 17\n   studyName `Sample Number` Species         Region Island Stage `Individual ID`\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n 1 PAL0708                 1 Chinstrap peng… Anvers Dream  Adul… N61A1          \n 2 PAL0708                 2 Chinstrap peng… Anvers Dream  Adul… N61A2          \n 3 PAL0708                 3 Chinstrap peng… Anvers Dream  Adul… N62A1          \n 4 PAL0708                 4 Chinstrap peng… Anvers Dream  Adul… N62A2          \n 5 PAL0708                 5 Chinstrap peng… Anvers Dream  Adul… N64A1          \n 6 PAL0708                 6 Chinstrap peng… Anvers Dream  Adul… N64A2          \n 7 PAL0708                 7 Chinstrap peng… Anvers Dream  Adul… N66A1          \n 8 PAL0708                 8 Chinstrap peng… Anvers Dream  Adul… N66A2          \n 9 PAL0708                 9 Chinstrap peng… Anvers Dream  Adul… N67A1          \n10 PAL0708                10 Chinstrap peng… Anvers Dream  Adul… N67A2          \n# ℹ 58 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\nIn R terms, chinstrap_data is a named object that references or stores something. In this case, chinstrap_data stores a specific table of data.\nLooking back at the command in our code file, the second thing we see is a &lt;- symbol, which is the assignment operator. It assigns values generated or typed on the right to objects on the left. An alternative symbol that you might see used as an assignment operator is the = but it is clearer to only use &lt;- for assignment. We use this symbol so often that RStudio has a keyboard short cut for it: Alt+- on Windows, and Option+- on Mac.\n\n\n\n\n\n\nAssigning values to objects\n\n\n\nTry to assign values to some objects and observe each object after you have assigned a new value. What do you notice?\n\nname &lt;- \"Ben\"\nname\nage &lt;- 26\nage\nname &lt;- \"Harry Potter\"\nname\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWhen we assign a value to an object, the object stores that value so we can access it later. However, if we store a new value in an object we have already created (like when we stored “Harry Potter” in the name object), it replaces the old value. The age object does not change, because we never assign it a new value.\n\n\n\n\n\n\n\n\n\n\n\nGuidelines on naming objects\n\n\n\n\nYou want your object names to be explicit and not too long.\nThey cannot start with a number (2x is not valid, but x2 is).\nR is case sensitive, so for example, weight_kg is different from Weight_kg.\nYou cannot use spaces in the name.\nThere are some names that cannot be used because they are the names of fundamental functions in R (e.g., if, else, for; see here for a complete list). If in doubt, check the help to see if the name is already in use (?function_name).\nIt’s best to avoid dots (.) within names. Many function names in R itself have them and dots also have a special meaning (methods) in R and other programming languages.\nIt is recommended to use nouns for object names and verbs for function names.\nBe consistent in the styling of your code, such as where you put spaces, how you name objects, etc. Using a consistent coding style makes your code clearer to read for your future self and your collaborators. One popular style guide can be found through the tidyverse.\n\n\n\n\n\n\n\n\n\nBonus Exercise: Bad names for objects\n\n\n\nTry to assign values to some new objects. What do you notice? After running all four lines of code bellow, what value do you think the object Flower holds?\n\n1number &lt;- 3\nFlower &lt;- \"marigold\"\nflower &lt;- \"rose\"\nfavorite number &lt;- 12\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nNotice that we get an error when we try to assign values to 1number and favorite number. This is because we cannot start an object name with a numeral and we cannot have spaces in object names. The object Flower still holds “marigold.” This is because R is case-sensitive, so running flower &lt;- \"rose\" does NOT change the Flower object. This can get confusing, and is why we generally avoid having objects with the same name and different capitalization.\n\n\n\n\n\nThe next part of the command is read_csv(\"data/chinstrap_data.csv\"). This has a few different key parts. The first part is the read_csv function. You call a function in R by typing it’s name followed by opening then closing parenthesis. Each function has a purpose, which is often hinted at by the name of the function. Let’s try to run the function without anything inside the parenthesis.\n\nread_csv()\n\nError in read_csv(): argument \"file\" is missing, with no default\n\n\nWe get an error message. Don’t panic! Error messages pop up all the time, and can be super helpful in debugging code.\nIn this case, the message tells us “argument”file” is missing, with no default.” Many functions, including read_csv, require additional pieces of information to do their job. We call these additional values “arguments” or “parameters.” You pass arguments to a function by placing values in between the parenthesis. A function takes in these arguments and does a bunch of “magic” behind the scenes to output something we’re interested in.\nFor example, when we loaded in our data, the command contained \"chinstrap_data.csv\" inside the read_csv() function. This is the value we assigned to the file argument. But we didn’t say that that was the file. How does that work?\n\n\n\n\n\n\nPro-tip\n\n\n\nEach function has a help page that documents what arguments the function expects and what value it will return. You can bring up the help page a few different ways. If you have typed the function name in the Editor windows, you can put your cursor on the function name and press F1 to open help page in the Help viewer in the lower right corner of RStudio. You can also type ? followed by the function name in the console.\nFor example, try running ?read_csv. A help page should pop up with information about what the function is used for and how to use it, as well as useful examples of the function in action. As you can see, the first argument of read_csv is the file path.\n\n\nThe read_csv() function took the file path we provided, did who-knows-what behind the scenes, and then outputted an R object with the data stored in that csv file. All that, with one short line of code!\n\n\n\n\n\n\nBehind the curtain of functions\n\n\n\nIf you call a function without parentheses, it will often show you the source code of the function, demystifying its seemingly “black box” behavior. This can often be useful if a function is not behaving as you expect (but of course requires knowledge of what the functions in the source code do). Doing this will also tell you which package the function comes from (although you can also see this in the function’s help page).\n\n\nDo all functions need arguments? Let’s test some other functions:\n\nSys.Date()\n\n[1] \"2025-01-17\"\n\ngetwd()\n\n[1] \"C:/Users/willg/OneDrive - Syracuse University/Syracuse/ospo-workshop-r-intro\"\n\n\nWhile some functions, like those above, don’t need any arguments, in other functions we may want to use multiple arguments. When we’re using multiple arguments, we separate the arguments with commas. For example, we can use the sum() function to add numbers together:\n\nsum(5, 6)\n\n[1] 11\n\n\n\n\n\n\n\n\nLearning more about functions\n\n\n\nLook up the function round. What does it do? What will you get as output for the following lines of code?\n\nround(3.1415)\nround(3.1415, 3)\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nround rounds a number. By default, it rounds it to zero digits (in our example above, to 3). If you give it a second number, it rounds it to that number of digits (in our example above, to 3.142)\n\n\n\n\n\nNotice how in this example, we didn’t include any argument names. But you can use argument names if you want:\n\nread_csv(file = 'data/chinstrap_data.csv')\n\n\n\n\n\n\n\nPosition of the arguments in functions\n\n\n\nWhich of the following lines of code will give you an output of 3.14? For the one(s) that don’t give you 3.14, what do they give you?\n\nround(x = 3.1415)\nround(x = 3.1415, digits = 2)\nround(digits = 2, x = 3.1415)\nround(2, 3.1415)\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe 2nd and 3rd lines will give you the right answer because the arguments are named, and when you use names the order doesn’t matter. The 1st line will give you 3 because the default number of digits is 0. Then 4th line will give you 2 because, since you didn’t name the arguments, x=2 and digits=3.1415.\n\n\n\n\n\nSometimes it is helpful - or even necessary - to include the argument name, but often we can skip the argument name, if the argument values are passed in a certain order. If all this function stuff sounds confusing, don’t worry! We’ll see a bunch of examples as we go that will make things clearer.\n\n\n\n\n\n\nReading in an excel file\n\n\n\nSay you have an excel file and not a csv - how would you read that in? Hint: Use the Internet to help you figure it out!\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOne way is using the read_excel function in the readxl package. There are other ways, but this is our preferred method because the output will be the same as the output of read_csv.\n\n\n\n\n\n\n\n\n\n\n\nComments\n\n\n\nSometimes you may want to write comments in your code to help you remember what your code is doing, but you don’t want R to think these comments are a part of the code you want to evaluate. That’s where comments come in! Anything after a # symbol in your code will be ignored by R. For example, let’s say we wanted to make a note of what each of the functions we just used do:\n\nSys.Date()  # outputs the current date\ngetwd()     # outputs our current working directory (folder)\nsum(5, 6)   # adds numbers\nread_csv(file = 'data/chinstrap_data.csv') # reads in csv file\n\n\n\n\n\nCombining data\nThe last step before we can move on to plotting is reading in the other two data files and combining all three datasets into a single data object.\nFirst let’s read in the “adelie_data.csv” file. While you may be tempted to use the RStudio GUI again, let’s take a stab at writing the code ourselves. We’ll use the same code as before, but with the filename changed:\n\nadelie_data &lt;- read_csv(file = 'data/adelie_data.csv')\n\n\n\nRows: 152 Columns: 17\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (9): studyName, Species, Region, Island, Stage, Individual ID, Clutch C...\ndbl  (7): Sample Number, Culmen Length (mm), Culmen Depth (mm), Flipper Leng...\ndate (1): Date Egg\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nYou should see that this new object is now listed in our environment. Also remember that we must always use the relative path to the file. While our script is located in our “code” directory, our working directory is actually the main directory of our project (as is the default for all projects). The relative path to the data file therefore must start with “data/”.\nNow we can combine our two data objects together. The bind_rows() function binds two data frames together rowwise, resulting in a single data.frame. Since we may want the separate data objects later, we save this as a new object.\n\npenguin_data &lt;- bind_rows(adelie_data, chinstrap_data)\n\nWe can use the table() function to count how many of each penguin species are now in our combined data.frame. Here we use the $ symbol to extract a single column of the data.frame:\n\ntable(penguin_data$Species)\n\n\n      Adelie Penguin (Pygoscelis adeliae) \n                                      152 \nChinstrap penguin (Pygoscelis antarctica) \n                                       68 \n\n\nNow go ahead and read in the last data file and combine it with the existing combined data.\n\ngentoo_data &lt;- read_csv(file = 'data/gentoo_data.csv')\npenguin_data &lt;- bind_rows(penguin_data, gentoo_data)\n\n\n\nRows: 124 Columns: 17\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (9): studyName, Species, Region, Island, Stage, Individual ID, Clutch C...\ndbl  (7): Sample Number, Culmen Length (mm), Culmen Depth (mm), Flipper Leng...\ndate (1): Date Egg\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nYour resulting data.frame should give the following counts:\n\ntable(penguin_data$Species)\n\n\n      Adelie Penguin (Pygoscelis adeliae) \n                                      152 \nChinstrap penguin (Pygoscelis antarctica) \n                                       68 \n        Gentoo penguin (Pygoscelis papua) \n                                      124 \n\n\nEverything looks good, so we can save our combined data object to a new csv file. To keep our repository clean and organized, we’ll make sure to save it in our “data” directory.\n\nwrite_csv(penguin_data, \"data/penguin_data.csv\")\n\n\n\nCommitting and pushing changes to GitHub\nNow we’ll use the Git interface in RStudio to commit our new files to our forked GitHub repoitory. Click on the “Git” tab in the top right panel. Clicking this tab will show you all of the files that have been modified since we last committed. In this case, you should see a file created by RStudio for your project, your new “penguins.R” script, and your new “penguins_data.csv” data file.\n\nClick the boxes next to these three files to queue them for committing. Then click the Commit button. A new window should open where you can enter a commit message. Remember that commit messages should be both informative and concise. Once you are satisfied with your commit message, click the Commit button, and then Push. And that’s that!\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Introduction to R and RStudio"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html",
    "href": "lessons/r-lessons/r-tidydata.html",
    "title": "R for Data Cleaning",
    "section": "",
    "text": "“How can R help make my research more reproducible?”\n“How can data tidying facilitate answering analysis questions?”\n“How can I summarize my data in R?”\n\n\n“To become familiar with the functions of dplyr and the tidyverse suite of packages.”\n“To use dplyr and the tidyverse packages to prepare data for analysis.”\n“To be able to create summary tables to answer analysis questions.”",
    "crumbs": [
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#selecting-columns",
    "href": "lessons/r-lessons/r-tidydata.html#selecting-columns",
    "title": "R for Data Cleaning",
    "section": "Selecting columns",
    "text": "Selecting columns\nWe can select specific columns in our dataset with the select() function. All dplyr wrangling verbs take a data frame as their first argument—in this case, the columns we want to select are the other arguments.\n\nselect(penguins_raw, Species, Island, `Individual ID`)\n\n# A tibble: 344 × 3\n   Species                             Island    `Individual ID`\n   &lt;chr&gt;                               &lt;chr&gt;     &lt;chr&gt;          \n 1 Adelie Penguin (Pygoscelis adeliae) Torgersen N1A1           \n 2 Adelie Penguin (Pygoscelis adeliae) Torgersen N1A2           \n 3 Adelie Penguin (Pygoscelis adeliae) Torgersen N2A1           \n 4 Adelie Penguin (Pygoscelis adeliae) Torgersen N2A2           \n 5 Adelie Penguin (Pygoscelis adeliae) Torgersen N3A1           \n 6 Adelie Penguin (Pygoscelis adeliae) Torgersen N3A2           \n 7 Adelie Penguin (Pygoscelis adeliae) Torgersen N4A1           \n 8 Adelie Penguin (Pygoscelis adeliae) Torgersen N4A2           \n 9 Adelie Penguin (Pygoscelis adeliae) Torgersen N5A1           \n10 Adelie Penguin (Pygoscelis adeliae) Torgersen N5A2           \n# ℹ 334 more rows\n\n\nThis is a good moment to talk about “pipes.” Notice how the code below produces the same output as the one above, but with a slightly different syntax. Pipes (|&gt; or %&gt;%) “kick” the object on the left of the pipe to the first argument of the function on the right. One can read pipes as “then,” so the code below can be read as “take penguins_raw, then select the columns Species, Island and Individual ID.” Pipes are very powerful and can be used to link multiple operations, as we will see in a moment.\n\npenguins_raw |&gt; \n  select(Species, Island, `Individual ID`) \n\n# A tibble: 344 × 3\n   Species                             Island    `Individual ID`\n   &lt;chr&gt;                               &lt;chr&gt;     &lt;chr&gt;          \n 1 Adelie Penguin (Pygoscelis adeliae) Torgersen N1A1           \n 2 Adelie Penguin (Pygoscelis adeliae) Torgersen N1A2           \n 3 Adelie Penguin (Pygoscelis adeliae) Torgersen N2A1           \n 4 Adelie Penguin (Pygoscelis adeliae) Torgersen N2A2           \n 5 Adelie Penguin (Pygoscelis adeliae) Torgersen N3A1           \n 6 Adelie Penguin (Pygoscelis adeliae) Torgersen N3A2           \n 7 Adelie Penguin (Pygoscelis adeliae) Torgersen N4A1           \n 8 Adelie Penguin (Pygoscelis adeliae) Torgersen N4A2           \n 9 Adelie Penguin (Pygoscelis adeliae) Torgersen N5A1           \n10 Adelie Penguin (Pygoscelis adeliae) Torgersen N5A2           \n# ℹ 334 more rows\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can insert a pipe with the Cmd/Ctrl + Shift + M shortcut. If you have not changed the default RStudio settings, an “old” pipe (%&gt;%) might appear. While most of the functionality is the same, the |&gt; “new” pipes are more readable and don’t need any extra packages (to use %&gt;% you need the tidyverse or one of its packages). You can change this RStudio option in Tools &gt; Global Options &gt; Code &gt; Use native pipe operator.\n\n\nGoing back to selecting columns, you can select ranges:\n\npenguins_raw |&gt; \n  select(Species:`Individual ID`)\n\n# A tibble: 344 × 5\n   Species                             Region Island    Stage    `Individual ID`\n   &lt;chr&gt;                               &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;    &lt;chr&gt;          \n 1 Adelie Penguin (Pygoscelis adeliae) Anvers Torgersen Adult, … N1A1           \n 2 Adelie Penguin (Pygoscelis adeliae) Anvers Torgersen Adult, … N1A2           \n 3 Adelie Penguin (Pygoscelis adeliae) Anvers Torgersen Adult, … N2A1           \n 4 Adelie Penguin (Pygoscelis adeliae) Anvers Torgersen Adult, … N2A2           \n 5 Adelie Penguin (Pygoscelis adeliae) Anvers Torgersen Adult, … N3A1           \n 6 Adelie Penguin (Pygoscelis adeliae) Anvers Torgersen Adult, … N3A2           \n 7 Adelie Penguin (Pygoscelis adeliae) Anvers Torgersen Adult, … N4A1           \n 8 Adelie Penguin (Pygoscelis adeliae) Anvers Torgersen Adult, … N4A2           \n 9 Adelie Penguin (Pygoscelis adeliae) Anvers Torgersen Adult, … N5A1           \n10 Adelie Penguin (Pygoscelis adeliae) Anvers Torgersen Adult, … N5A2           \n# ℹ 334 more rows\n\n\nYou can also deselect columns using a minus sign:\n\npenguins_raw |&gt; \n  select(-Species)\n\n# A tibble: 344 × 16\n   studyName `Sample Number` Region Island    Stage              `Individual ID`\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;              &lt;chr&gt;          \n 1 PAL0708                 1 Anvers Torgersen Adult, 1 Egg Stage N1A1           \n 2 PAL0708                 2 Anvers Torgersen Adult, 1 Egg Stage N1A2           \n 3 PAL0708                 3 Anvers Torgersen Adult, 1 Egg Stage N2A1           \n 4 PAL0708                 4 Anvers Torgersen Adult, 1 Egg Stage N2A2           \n 5 PAL0708                 5 Anvers Torgersen Adult, 1 Egg Stage N3A1           \n 6 PAL0708                 6 Anvers Torgersen Adult, 1 Egg Stage N3A2           \n 7 PAL0708                 7 Anvers Torgersen Adult, 1 Egg Stage N4A1           \n 8 PAL0708                 8 Anvers Torgersen Adult, 1 Egg Stage N4A2           \n 9 PAL0708                 9 Anvers Torgersen Adult, 1 Egg Stage N5A1           \n10 PAL0708                10 Anvers Torgersen Adult, 1 Egg Stage N5A2           \n# ℹ 334 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\nAnd use a few helper functions, like matches():\n\npenguins_raw |&gt; \n  select(Species, matches(\"Length\"))\n\n# A tibble: 344 × 3\n   Species                            `Culmen Length (mm)` `Flipper Length (mm)`\n   &lt;chr&gt;                                             &lt;dbl&gt;                 &lt;dbl&gt;\n 1 Adelie Penguin (Pygoscelis adelia…                 39.1                   181\n 2 Adelie Penguin (Pygoscelis adelia…                 39.5                   186\n 3 Adelie Penguin (Pygoscelis adelia…                 40.3                   195\n 4 Adelie Penguin (Pygoscelis adelia…                 NA                      NA\n 5 Adelie Penguin (Pygoscelis adelia…                 36.7                   193\n 6 Adelie Penguin (Pygoscelis adelia…                 39.3                   190\n 7 Adelie Penguin (Pygoscelis adelia…                 38.9                   181\n 8 Adelie Penguin (Pygoscelis adelia…                 39.2                   195\n 9 Adelie Penguin (Pygoscelis adelia…                 34.1                   193\n10 Adelie Penguin (Pygoscelis adelia…                 42                     190\n# ℹ 334 more rows\n\n\nOr everything(), which we usually use to reorder columns:\n\npenguins_raw |&gt; \n  select(Species, everything())\n\n# A tibble: 344 × 17\n   Species         studyName `Sample Number` Region Island Stage `Individual ID`\n   &lt;chr&gt;           &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n 1 Adelie Penguin… PAL0708                 1 Anvers Torge… Adul… N1A1           \n 2 Adelie Penguin… PAL0708                 2 Anvers Torge… Adul… N1A2           \n 3 Adelie Penguin… PAL0708                 3 Anvers Torge… Adul… N2A1           \n 4 Adelie Penguin… PAL0708                 4 Anvers Torge… Adul… N2A2           \n 5 Adelie Penguin… PAL0708                 5 Anvers Torge… Adul… N3A1           \n 6 Adelie Penguin… PAL0708                 6 Anvers Torge… Adul… N3A2           \n 7 Adelie Penguin… PAL0708                 7 Anvers Torge… Adul… N4A1           \n 8 Adelie Penguin… PAL0708                 8 Anvers Torge… Adul… N4A2           \n 9 Adelie Penguin… PAL0708                 9 Anvers Torge… Adul… N5A1           \n10 Adelie Penguin… PAL0708                10 Anvers Torge… Adul… N5A2           \n# ℹ 334 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\n\n\n\n\n\n\nTip\n\n\n\nNotice that all these commands have not edited our existent objects—they have just printed the requested outputs to the screen. In order to modify objects, you need to use the assignment operator (&lt;-). For example:\n\npenguins_raw_reduced &lt;- penguins_raw |&gt; \n  select(Species, matches(\"Length\"))\n\n\npenguins_raw_reduced\n\n# A tibble: 344 × 3\n   Species                            `Culmen Length (mm)` `Flipper Length (mm)`\n   &lt;chr&gt;                                             &lt;dbl&gt;                 &lt;dbl&gt;\n 1 Adelie Penguin (Pygoscelis adelia…                 39.1                   181\n 2 Adelie Penguin (Pygoscelis adelia…                 39.5                   186\n 3 Adelie Penguin (Pygoscelis adelia…                 40.3                   195\n 4 Adelie Penguin (Pygoscelis adelia…                 NA                      NA\n 5 Adelie Penguin (Pygoscelis adelia…                 36.7                   193\n 6 Adelie Penguin (Pygoscelis adelia…                 39.3                   190\n 7 Adelie Penguin (Pygoscelis adelia…                 38.9                   181\n 8 Adelie Penguin (Pygoscelis adelia…                 39.2                   195\n 9 Adelie Penguin (Pygoscelis adelia…                 34.1                   193\n10 Adelie Penguin (Pygoscelis adelia…                 42                     190\n# ℹ 334 more rows\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nSelect the variables Species, Stage, Individual ID, Clutch Completion, and Date Egg from the data frame.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\npenguins_raw |&gt; \n  select(Species, Stage, `Individual ID`, `Clutch Completion`, `Date Egg`)\n\n# A tibble: 344 × 5\n   Species                  Stage `Individual ID` `Clutch Completion` `Date Egg`\n   &lt;chr&gt;                    &lt;chr&gt; &lt;chr&gt;           &lt;chr&gt;               &lt;date&gt;    \n 1 Adelie Penguin (Pygosce… Adul… N1A1            Yes                 2007-11-11\n 2 Adelie Penguin (Pygosce… Adul… N1A2            Yes                 2007-11-11\n 3 Adelie Penguin (Pygosce… Adul… N2A1            Yes                 2007-11-16\n 4 Adelie Penguin (Pygosce… Adul… N2A2            Yes                 2007-11-16\n 5 Adelie Penguin (Pygosce… Adul… N3A1            Yes                 2007-11-16\n 6 Adelie Penguin (Pygosce… Adul… N3A2            Yes                 2007-11-16\n 7 Adelie Penguin (Pygosce… Adul… N4A1            No                  2007-11-15\n 8 Adelie Penguin (Pygosce… Adul… N4A2            No                  2007-11-15\n 9 Adelie Penguin (Pygosce… Adul… N5A1            Yes                 2007-11-09\n10 Adelie Penguin (Pygosce… Adul… N5A2            Yes                 2007-11-09\n# ℹ 334 more rows",
    "crumbs": [
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#renaming-columns",
    "href": "lessons/r-lessons/r-tidydata.html#renaming-columns",
    "title": "R for Data Cleaning",
    "section": "Renaming columns",
    "text": "Renaming columns\nWe can use the rename() function to rename columns, with the syntax new_name = old_name. This is especially useful for datasets like this one, where the column names are long, have spaces in them, or other special characters that require ` in order to call the column name. Here is an example of how we rename a column:\n\npenguins_raw |&gt; \n  rename(id = `Individual ID`, \n         flipper_length = `Flipper Length (mm)`)\n\n# A tibble: 344 × 17\n   studyName `Sample Number` Species                   Region Island Stage id   \n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;                     &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;\n 1 PAL0708                 1 Adelie Penguin (Pygoscel… Anvers Torge… Adul… N1A1 \n 2 PAL0708                 2 Adelie Penguin (Pygoscel… Anvers Torge… Adul… N1A2 \n 3 PAL0708                 3 Adelie Penguin (Pygoscel… Anvers Torge… Adul… N2A1 \n 4 PAL0708                 4 Adelie Penguin (Pygoscel… Anvers Torge… Adul… N2A2 \n 5 PAL0708                 5 Adelie Penguin (Pygoscel… Anvers Torge… Adul… N3A1 \n 6 PAL0708                 6 Adelie Penguin (Pygoscel… Anvers Torge… Adul… N3A2 \n 7 PAL0708                 7 Adelie Penguin (Pygoscel… Anvers Torge… Adul… N4A1 \n 8 PAL0708                 8 Adelie Penguin (Pygoscel… Anvers Torge… Adul… N4A2 \n 9 PAL0708                 9 Adelie Penguin (Pygoscel… Anvers Torge… Adul… N5A1 \n10 PAL0708                10 Adelie Penguin (Pygoscel… Anvers Torge… Adul… N5A2 \n# ℹ 334 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   flipper_length &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\nThis is a good occasion to show how pipes allow us to chain operations. How do we read the following code out loud? (Remember that pipes are read as “then”).\n\npenguins_raw |&gt; \n  select(Species, `Individual ID`, matches(\"Length\")) |&gt; \n  rename(id = `Individual ID`, \n         flipper_length = `Flipper Length (mm)`)\n\n# A tibble: 344 × 4\n   Species                             id    `Culmen Length (mm)` flipper_length\n   &lt;chr&gt;                               &lt;chr&gt;                &lt;dbl&gt;          &lt;dbl&gt;\n 1 Adelie Penguin (Pygoscelis adeliae) N1A1                  39.1            181\n 2 Adelie Penguin (Pygoscelis adeliae) N1A2                  39.5            186\n 3 Adelie Penguin (Pygoscelis adeliae) N2A1                  40.3            195\n 4 Adelie Penguin (Pygoscelis adeliae) N2A2                  NA               NA\n 5 Adelie Penguin (Pygoscelis adeliae) N3A1                  36.7            193\n 6 Adelie Penguin (Pygoscelis adeliae) N3A2                  39.3            190\n 7 Adelie Penguin (Pygoscelis adeliae) N4A1                  38.9            181\n 8 Adelie Penguin (Pygoscelis adeliae) N4A2                  39.2            195\n 9 Adelie Penguin (Pygoscelis adeliae) N5A1                  34.1            193\n10 Adelie Penguin (Pygoscelis adeliae) N5A2                  42              190\n# ℹ 334 more rows",
    "crumbs": [
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#creating-columns",
    "href": "lessons/r-lessons/r-tidydata.html#creating-columns",
    "title": "R for Data Cleaning",
    "section": "Creating columns",
    "text": "Creating columns\nIt is common to want to create columns based on existing ones. We can use mutate() to do so. For example, we could want to express the main length variables (length of the penguin’s flipper and culmen, the dorsal ridge of their bill) in centimeters instead of millimeters:\n\npenguins_raw |&gt; \n  select(Species, matches(\"Length\")) |&gt; # select just for clarity\n    rename(flipper_length = `Flipper Length (mm)`) |&gt;\n  #mutate length variables\n  mutate(flipper_length_cm = flipper_length * 0.1,\n         culmen_length_cm = `Culmen Length (mm)` * 0.1)\n\n# A tibble: 344 × 5\n   Species                 `Culmen Length (mm)` flipper_length flipper_length_cm\n   &lt;chr&gt;                                  &lt;dbl&gt;          &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie Penguin (Pygosc…                 39.1            181              18.1\n 2 Adelie Penguin (Pygosc…                 39.5            186              18.6\n 3 Adelie Penguin (Pygosc…                 40.3            195              19.5\n 4 Adelie Penguin (Pygosc…                 NA               NA              NA  \n 5 Adelie Penguin (Pygosc…                 36.7            193              19.3\n 6 Adelie Penguin (Pygosc…                 39.3            190              19  \n 7 Adelie Penguin (Pygosc…                 38.9            181              18.1\n 8 Adelie Penguin (Pygosc…                 39.2            195              19.5\n 9 Adelie Penguin (Pygosc…                 34.1            193              19.3\n10 Adelie Penguin (Pygosc…                 42              190              19  \n# ℹ 334 more rows\n# ℹ 1 more variable: culmen_length_cm &lt;dbl&gt;\n\n\nWe can also use multiple columns for creating a new one. For example, let’s calculate the flipper to culmen length ratio:\n\npenguins_raw |&gt; \n select(Species,  matches(\"Length\")) |&gt; # select just for clarity\n    rename(flipper_length = `Flipper Length (mm)`) |&gt;\n  mutate(flipper_culmen_ratio = flipper_length/`Culmen Length (mm)`)\n\n# A tibble: 344 × 4\n   Species              `Culmen Length (mm)` flipper_length flipper_culmen_ratio\n   &lt;chr&gt;                               &lt;dbl&gt;          &lt;dbl&gt;                &lt;dbl&gt;\n 1 Adelie Penguin (Pyg…                 39.1            181                 4.63\n 2 Adelie Penguin (Pyg…                 39.5            186                 4.71\n 3 Adelie Penguin (Pyg…                 40.3            195                 4.84\n 4 Adelie Penguin (Pyg…                 NA               NA                NA   \n 5 Adelie Penguin (Pyg…                 36.7            193                 5.26\n 6 Adelie Penguin (Pyg…                 39.3            190                 4.83\n 7 Adelie Penguin (Pyg…                 38.9            181                 4.65\n 8 Adelie Penguin (Pyg…                 39.2            195                 4.97\n 9 Adelie Penguin (Pyg…                 34.1            193                 5.66\n10 Adelie Penguin (Pyg…                 42              190                 4.52\n# ℹ 334 more rows",
    "crumbs": [
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#filtering-rows",
    "href": "lessons/r-lessons/r-tidydata.html#filtering-rows",
    "title": "R for Data Cleaning",
    "section": "Filtering rows",
    "text": "Filtering rows\nAnother common operation is to filter rows based on logical conditions. We can do so with the filter() function. For example, we can filter to only get penguins of a certain species:\n\npenguins_raw |&gt; \n  filter(Species == \"Gentoo penguin (Pygoscelis papua)\")\n\n# A tibble: 124 × 17\n   studyName `Sample Number` Species         Region Island Stage `Individual ID`\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n 1 PAL0708                 1 Gentoo penguin… Anvers Biscoe Adul… N31A1          \n 2 PAL0708                 2 Gentoo penguin… Anvers Biscoe Adul… N31A2          \n 3 PAL0708                 3 Gentoo penguin… Anvers Biscoe Adul… N32A1          \n 4 PAL0708                 4 Gentoo penguin… Anvers Biscoe Adul… N32A2          \n 5 PAL0708                 5 Gentoo penguin… Anvers Biscoe Adul… N33A1          \n 6 PAL0708                 6 Gentoo penguin… Anvers Biscoe Adul… N33A2          \n 7 PAL0708                 7 Gentoo penguin… Anvers Biscoe Adul… N34A1          \n 8 PAL0708                 8 Gentoo penguin… Anvers Biscoe Adul… N34A2          \n 9 PAL0708                 9 Gentoo penguin… Anvers Biscoe Adul… N35A1          \n10 PAL0708                10 Gentoo penguin… Anvers Biscoe Adul… N35A2          \n# ℹ 114 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\nNotice that == here is a logical operator, read as “is equal to.” So our full chain of operations says the following: take penguins_raw, then filter it to get rows where the Species is equal to “Gentoo penguin (Pygoscelis papua)”.\nThere are other logical operators, also called boolean operators:\n\n\n\nLogical operator\nMeaning\n\n\n\n\n==\n“is equal to”\n\n\n!=\n“is not equal to”\n\n\n&gt;\n“is greater than”\n\n\n&lt;\n“is less than”\n\n\n&gt;=\n“is greater than or equal to”\n\n\n&lt;=\n“is less than or equal to”\n\n\n%in%\n“is contained in”\n\n\n&\n“and” (intersection)\n\n\n|\n“or” (union)\n\n\n\nLet’s see a couple of other examples.\n\npenguins_raw |&gt; \n  filter(Island %in% c(\"Torgersen\", \"Biscoe\"))\n\n# A tibble: 220 × 17\n   studyName `Sample Number` Species         Region Island Stage `Individual ID`\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n 1 PAL0708                 1 Adelie Penguin… Anvers Torge… Adul… N1A1           \n 2 PAL0708                 2 Adelie Penguin… Anvers Torge… Adul… N1A2           \n 3 PAL0708                 3 Adelie Penguin… Anvers Torge… Adul… N2A1           \n 4 PAL0708                 4 Adelie Penguin… Anvers Torge… Adul… N2A2           \n 5 PAL0708                 5 Adelie Penguin… Anvers Torge… Adul… N3A1           \n 6 PAL0708                 6 Adelie Penguin… Anvers Torge… Adul… N3A2           \n 7 PAL0708                 7 Adelie Penguin… Anvers Torge… Adul… N4A1           \n 8 PAL0708                 8 Adelie Penguin… Anvers Torge… Adul… N4A2           \n 9 PAL0708                 9 Adelie Penguin… Anvers Torge… Adul… N5A1           \n10 PAL0708                10 Adelie Penguin… Anvers Torge… Adul… N5A2           \n# ℹ 210 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\n\npenguins_raw |&gt; \n  filter(Island == \"Torgersen\" & Sex == \"MALE\")\n\n# A tibble: 23 × 17\n   studyName `Sample Number` Species         Region Island Stage `Individual ID`\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n 1 PAL0708                 1 Adelie Penguin… Anvers Torge… Adul… N1A1           \n 2 PAL0708                 6 Adelie Penguin… Anvers Torge… Adul… N3A2           \n 3 PAL0708                 8 Adelie Penguin… Anvers Torge… Adul… N4A2           \n 4 PAL0708                14 Adelie Penguin… Anvers Torge… Adul… N7A2           \n 5 PAL0708                15 Adelie Penguin… Anvers Torge… Adul… N8A1           \n 6 PAL0708                18 Adelie Penguin… Anvers Torge… Adul… N9A2           \n 7 PAL0708                20 Adelie Penguin… Anvers Torge… Adul… N10A2          \n 8 PAL0809                70 Adelie Penguin… Anvers Torge… Adul… N32A2          \n 9 PAL0809                72 Adelie Penguin… Anvers Torge… Adul… N34A2          \n10 PAL0809                74 Adelie Penguin… Anvers Torge… Adul… N35A2          \n# ℹ 13 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\n\npenguins_raw |&gt; \n  filter(`Flipper Length (mm)` &gt; 200)\n\n# A tibble: 148 × 17\n   studyName `Sample Number` Species         Region Island Stage `Individual ID`\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n 1 PAL0809                91 Adelie Penguin… Anvers Dream  Adul… N45A1          \n 2 PAL0809                92 Adelie Penguin… Anvers Dream  Adul… N45A2          \n 3 PAL0809                96 Adelie Penguin… Anvers Dream  Adul… N48A2          \n 4 PAL0910               102 Adelie Penguin… Anvers Biscoe Adul… N47A2          \n 5 PAL0910               124 Adelie Penguin… Anvers Torge… Adul… N67A2          \n 6 PAL0910               130 Adelie Penguin… Anvers Torge… Adul… N72A2          \n 7 PAL0910               152 Adelie Penguin… Anvers Dream  Adul… N85A2          \n 8 PAL0708                 1 Gentoo penguin… Anvers Biscoe Adul… N31A1          \n 9 PAL0708                 2 Gentoo penguin… Anvers Biscoe Adul… N31A2          \n10 PAL0708                 3 Gentoo penguin… Anvers Biscoe Adul… N32A1          \n# ℹ 138 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\n\n\n\n\n\n\nTip\n\n\n\nConfused about when to use filter() and when to use select()? You use filter() to select rows (i.e., specific observations) with specific attributes, and you use select() to select columns (i.e., specific variables). To help keep it straight, remember that the letter “c” for column is in select() and the letter “r” for row is in filter().\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\nAdd a new column to the data frame, called length_mass_ratio, which calculates the ratio of the penguin’s flipper length Flipper Length (mm) and their body mass Body Mass (g). How would you calculate length_cm_mass_ratio, where the flipper length is expressed as centimeters instead of millimeters?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nTo calculate length_mass_ratio:\n\n## Length to mass ratio:\npenguins_raw |&gt; \n select(Species, `Body Mass (g)`, matches(\"Length\")) |&gt; # select just for clarity\n    rename(flipper_length = `Flipper Length (mm)`) |&gt;\n  mutate(length_mass_ratio = flipper_length/`Body Mass (g)`)\n\n# A tibble: 344 × 5\n   Species `Body Mass (g)` `Culmen Length (mm)` flipper_length length_mass_ratio\n   &lt;chr&gt;             &lt;dbl&gt;                &lt;dbl&gt;          &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie…            3750                 39.1            181            0.0483\n 2 Adelie…            3800                 39.5            186            0.0489\n 3 Adelie…            3250                 40.3            195            0.06  \n 4 Adelie…              NA                 NA               NA           NA     \n 5 Adelie…            3450                 36.7            193            0.0559\n 6 Adelie…            3650                 39.3            190            0.0521\n 7 Adelie…            3625                 38.9            181            0.0499\n 8 Adelie…            4675                 39.2            195            0.0417\n 9 Adelie…            3475                 34.1            193            0.0555\n10 Adelie…            4250                 42              190            0.0447\n# ℹ 334 more rows\n\n\nThere are two ways to calculate length_cm_mass_ratio in centimeters, you could either generate a new length variable in centimeters, or just apply the unit transformation to the ratio equation:\n\npenguins_raw |&gt; \n select(Species, `Body Mass (g)`, matches(\"Length\")) |&gt; # select just for clarity\n    rename(flipper_length = `Flipper Length (mm)`) |&gt;\n  mutate(flipper_cm = flipper_length * 0.1, \n      length_cm_mass_ratio = flipper_cm/`Body Mass (g)`)\n\n# A tibble: 344 × 6\n   Species        `Body Mass (g)` `Culmen Length (mm)` flipper_length flipper_cm\n   &lt;chr&gt;                    &lt;dbl&gt;                &lt;dbl&gt;          &lt;dbl&gt;      &lt;dbl&gt;\n 1 Adelie Pengui…            3750                 39.1            181       18.1\n 2 Adelie Pengui…            3800                 39.5            186       18.6\n 3 Adelie Pengui…            3250                 40.3            195       19.5\n 4 Adelie Pengui…              NA                 NA               NA       NA  \n 5 Adelie Pengui…            3450                 36.7            193       19.3\n 6 Adelie Pengui…            3650                 39.3            190       19  \n 7 Adelie Pengui…            3625                 38.9            181       18.1\n 8 Adelie Pengui…            4675                 39.2            195       19.5\n 9 Adelie Pengui…            3475                 34.1            193       19.3\n10 Adelie Pengui…            4250                 42              190       19  \n# ℹ 334 more rows\n# ℹ 1 more variable: length_cm_mass_ratio &lt;dbl&gt;\n\npenguins_raw |&gt; \n select(Species, `Body Mass (g)`, matches(\"Length\")) |&gt; # select just for clarity\n    rename(flipper_length = `Flipper Length (mm)`) |&gt;\n  mutate(length_cm_mass_ratio = flipper_length/`Body Mass (g)` * 0.1)\n\n# A tibble: 344 × 5\n   Species                   `Body Mass (g)` `Culmen Length (mm)` flipper_length\n   &lt;chr&gt;                               &lt;dbl&gt;                &lt;dbl&gt;          &lt;dbl&gt;\n 1 Adelie Penguin (Pygoscel…            3750                 39.1            181\n 2 Adelie Penguin (Pygoscel…            3800                 39.5            186\n 3 Adelie Penguin (Pygoscel…            3250                 40.3            195\n 4 Adelie Penguin (Pygoscel…              NA                 NA               NA\n 5 Adelie Penguin (Pygoscel…            3450                 36.7            193\n 6 Adelie Penguin (Pygoscel…            3650                 39.3            190\n 7 Adelie Penguin (Pygoscel…            3625                 38.9            181\n 8 Adelie Penguin (Pygoscel…            4675                 39.2            195\n 9 Adelie Penguin (Pygoscel…            3475                 34.1            193\n10 Adelie Penguin (Pygoscel…            4250                 42              190\n# ℹ 334 more rows\n# ℹ 1 more variable: length_cm_mass_ratio &lt;dbl&gt;\n\n\n\n\n\n\nFilter the data frame to only get penguins with nests observed with a fully completed clutch.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\npenguins_raw |&gt; \n  filter(`Clutch Completion` == \"Yes\")\n\n# A tibble: 308 × 17\n   studyName `Sample Number` Species         Region Island Stage `Individual ID`\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n 1 PAL0708                 1 Adelie Penguin… Anvers Torge… Adul… N1A1           \n 2 PAL0708                 2 Adelie Penguin… Anvers Torge… Adul… N1A2           \n 3 PAL0708                 3 Adelie Penguin… Anvers Torge… Adul… N2A1           \n 4 PAL0708                 4 Adelie Penguin… Anvers Torge… Adul… N2A2           \n 5 PAL0708                 5 Adelie Penguin… Anvers Torge… Adul… N3A1           \n 6 PAL0708                 6 Adelie Penguin… Anvers Torge… Adul… N3A2           \n 7 PAL0708                 9 Adelie Penguin… Anvers Torge… Adul… N5A1           \n 8 PAL0708                10 Adelie Penguin… Anvers Torge… Adul… N5A2           \n 9 PAL0708                11 Adelie Penguin… Anvers Torge… Adul… N6A1           \n10 PAL0708                12 Adelie Penguin… Anvers Torge… Adul… N6A2           \n# ℹ 298 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\n\n\n\n\nFilter the data frame to only get penguins with nests observed with a fully completed clutch on the Island of Torgersen.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\npenguins_raw |&gt; \n  filter(`Clutch Completion` == \"Yes\" & Island == \"Torgersen\")\n\n# A tibble: 44 × 17\n   studyName `Sample Number` Species         Region Island Stage `Individual ID`\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n 1 PAL0708                 1 Adelie Penguin… Anvers Torge… Adul… N1A1           \n 2 PAL0708                 2 Adelie Penguin… Anvers Torge… Adul… N1A2           \n 3 PAL0708                 3 Adelie Penguin… Anvers Torge… Adul… N2A1           \n 4 PAL0708                 4 Adelie Penguin… Anvers Torge… Adul… N2A2           \n 5 PAL0708                 5 Adelie Penguin… Anvers Torge… Adul… N3A1           \n 6 PAL0708                 6 Adelie Penguin… Anvers Torge… Adul… N3A2           \n 7 PAL0708                 9 Adelie Penguin… Anvers Torge… Adul… N5A1           \n 8 PAL0708                10 Adelie Penguin… Anvers Torge… Adul… N5A2           \n 9 PAL0708                11 Adelie Penguin… Anvers Torge… Adul… N6A1           \n10 PAL0708                12 Adelie Penguin… Anvers Torge… Adul… N6A2           \n# ℹ 34 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;",
    "crumbs": [
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#ordering-rows",
    "href": "lessons/r-lessons/r-tidydata.html#ordering-rows",
    "title": "R for Data Cleaning",
    "section": "Ordering rows",
    "text": "Ordering rows\nThe arrange() function allows us to order rows according to values. The default arranges from smallest to largest if numeric, or from A to Z if a character. For example, let’s order based on the Body Mass (g) variable:\n\npenguins_raw |&gt; \n  arrange(`Body Mass (g)`)\n\n# A tibble: 344 × 17\n   studyName `Sample Number` Species         Region Island Stage `Individual ID`\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n 1 PAL0809                39 Chinstrap peng… Anvers Dream  Adul… N72A1          \n 2 PAL0809                59 Adelie Penguin… Anvers Biscoe Adul… N25A1          \n 3 PAL0809                65 Adelie Penguin… Anvers Biscoe Adul… N29A1          \n 4 PAL0809                55 Adelie Penguin… Anvers Biscoe Adul… N23A1          \n 5 PAL0809                99 Adelie Penguin… Anvers Dream  Adul… N50A1          \n 6 PAL0910               117 Adelie Penguin… Anvers Torge… Adul… N63A1          \n 7 PAL0708                23 Chinstrap peng… Anvers Dream  Adul… N85A1          \n 8 PAL0910               105 Adelie Penguin… Anvers Biscoe Adul… N51A1          \n 9 PAL0708                48 Adelie Penguin… Anvers Dream  Adul… N29A2          \n10 PAL0708                45 Adelie Penguin… Anvers Dream  Adul… N28A1          \n# ℹ 334 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\nMaybe we only want penguins from the island of Biscoe. Remember that we can chain operations:\n\npenguins_raw |&gt; \n  filter(Island == \"Biscoe\") |&gt; \n  arrange(`Body Mass (g)`)\n\n# A tibble: 168 × 17\n   studyName `Sample Number` Species         Region Island Stage `Individual ID`\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n 1 PAL0809                59 Adelie Penguin… Anvers Biscoe Adul… N25A1          \n 2 PAL0809                65 Adelie Penguin… Anvers Biscoe Adul… N29A1          \n 3 PAL0809                55 Adelie Penguin… Anvers Biscoe Adul… N23A1          \n 4 PAL0910               105 Adelie Penguin… Anvers Biscoe Adul… N51A1          \n 5 PAL0910               103 Adelie Penguin… Anvers Biscoe Adul… N49A1          \n 6 PAL0708                29 Adelie Penguin… Anvers Biscoe Adul… N18A1          \n 7 PAL0809                61 Adelie Penguin… Anvers Biscoe Adul… N27A1          \n 8 PAL0910               109 Adelie Penguin… Anvers Biscoe Adul… N55A1          \n 9 PAL0708                28 Adelie Penguin… Anvers Biscoe Adul… N17A2          \n10 PAL0910               113 Adelie Penguin… Anvers Biscoe Adul… N60A1          \n# ℹ 158 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\nBy default, arrange() uses increasing order (like sort()). To use decreasing order, add a minus sign:\n\npenguins_raw |&gt; \n  filter(Island == \"Biscoe\") |&gt; \n  arrange(-`Body Mass (g)`)\n\n# A tibble: 168 × 17\n   studyName `Sample Number` Species         Region Island Stage `Individual ID`\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n 1 PAL0708                18 Gentoo penguin… Anvers Biscoe Adul… N39A2          \n 2 PAL0708                34 Gentoo penguin… Anvers Biscoe Adul… N56A2          \n 3 PAL0809                78 Gentoo penguin… Anvers Biscoe Adul… N58A2          \n 4 PAL0910               118 Gentoo penguin… Anvers Biscoe Adul… N36A2          \n 5 PAL0809                80 Gentoo penguin… Anvers Biscoe Adul… N60A2          \n 6 PAL0910               112 Gentoo penguin… Anvers Biscoe Adul… N32A2          \n 7 PAL0708                14 Gentoo penguin… Anvers Biscoe Adul… N37A2          \n 8 PAL0708                16 Gentoo penguin… Anvers Biscoe Adul… N38A2          \n 9 PAL0910               116 Gentoo penguin… Anvers Biscoe Adul… N35A2          \n10 PAL0809                68 Gentoo penguin… Anvers Biscoe Adul… N51A2          \n# ℹ 158 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\nYou can also order rows by more than one variable. What this does is to order by the first variable, and resolve any ties by ordering by the second variable (and so forth if you have more than two ordering variables). For example, let’s first order our data frame by sex, and then within sex order by body mass:\n\npenguins_raw |&gt; \n  filter(Island == \"Biscoe\") |&gt; \n  arrange(Sex, `Body Mass (g)`)\n\n# A tibble: 168 × 17\n   studyName `Sample Number` Species         Region Island Stage `Individual ID`\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n 1 PAL0809                59 Adelie Penguin… Anvers Biscoe Adul… N25A1          \n 2 PAL0809                65 Adelie Penguin… Anvers Biscoe Adul… N29A1          \n 3 PAL0809                55 Adelie Penguin… Anvers Biscoe Adul… N23A1          \n 4 PAL0910               105 Adelie Penguin… Anvers Biscoe Adul… N51A1          \n 5 PAL0910               103 Adelie Penguin… Anvers Biscoe Adul… N49A1          \n 6 PAL0708                29 Adelie Penguin… Anvers Biscoe Adul… N18A1          \n 7 PAL0809                61 Adelie Penguin… Anvers Biscoe Adul… N27A1          \n 8 PAL0910               109 Adelie Penguin… Anvers Biscoe Adul… N55A1          \n 9 PAL0708                28 Adelie Penguin… Anvers Biscoe Adul… N17A2          \n10 PAL0910               113 Adelie Penguin… Anvers Biscoe Adul… N60A1          \n# ℹ 158 more rows\n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\n\n\n\n\n\n\nExercise\n\n\n\nArrange the data by length_mass_ratio, the ratio of the penguin’s flipper length (in mm) and the penguin’s body mass (in g). (You should have code on how to create this variable from the last exercise). Save this as an object called `penguins_ratio_data\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\npenguins_raw |&gt; \n select(Species, `Body Mass (g)`, matches(\"Length\")) |&gt; # select just for clarity\n    rename(flipper_length = `Flipper Length (mm)`) |&gt;\n  mutate(length_mass_ratio = flipper_length/`Body Mass (g)`) |&gt;\n  arrange(length_mass_ratio)\n\n# A tibble: 344 × 5\n   Species `Body Mass (g)` `Culmen Length (mm)` flipper_length length_mass_ratio\n   &lt;chr&gt;             &lt;dbl&gt;                &lt;dbl&gt;          &lt;dbl&gt;             &lt;dbl&gt;\n 1 Gentoo…            6300                 49.2            221            0.0351\n 2 Gentoo…            5850                 48.4            213            0.0364\n 3 Gentoo…            6000                 51.1            220            0.0367\n 4 Gentoo…            6000                 48.8            222            0.037 \n 5 Gentoo…            5850                 49.3            217            0.0371\n 6 Gentoo…            5950                 45.2            223            0.0375\n 7 Gentoo…            5500                 48.1            209            0.038 \n 8 Gentoo…            6050                 59.6            230            0.0380\n 9 Gentoo…            5650                 47.8            215            0.0381\n10 Gentoo…            5700                 50              218            0.0382\n# ℹ 334 more rows\n\n## Now save it as an object \npenguins_ratio_data &lt;- penguins_raw |&gt; \n select(Species, `Body Mass (g)`, matches(\"Length\")) |&gt; # select just for clarity\n    rename(flipper_length = `Flipper Length (mm)`) |&gt;\n  mutate(length_mass_ratio = flipper_length/`Body Mass (g)`) |&gt;\n  arrange(length_mass_ratio)",
    "crumbs": [
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#calculating-summary-statistics",
    "href": "lessons/r-lessons/r-tidydata.html#calculating-summary-statistics",
    "title": "R for Data Cleaning",
    "section": "Calculating summary statistics",
    "text": "Calculating summary statistics\ndplyr makes summarizing data a breeze using the summarize() function:\n\npenguins_raw |&gt; \n  summarize(mean_flipper_length = mean(`Flipper Length (mm)`),\n            mean_body_mass = mean(`Body Mass (g)`))\n\n# A tibble: 1 × 2\n  mean_flipper_length mean_body_mass\n                &lt;dbl&gt;          &lt;dbl&gt;\n1                  NA             NA\n\n\n\n\n\n\n\n\nTip\n\n\n\nOh no! If you want to calculate the mean or do another arithmatic operation on a numeric vector and R returns NA values, it likely means that the vector has missing values. Use na.rm = T to drop the NA values in your calculation. We’ll see more of this later in this lesson.\n\n\n\npenguins_raw |&gt; \n  summarize(mean_flipper_length = mean(`Flipper Length (mm)`, na.rm = T),\n            mean_body_mass = mean(`Body Mass (g)`, na.rm = T))\n\n# A tibble: 1 × 2\n  mean_flipper_length mean_body_mass\n                &lt;dbl&gt;          &lt;dbl&gt;\n1                201.          4202.\n\n\nTo make summaries, we can use any function that takes a vector and returns one value. Another example:\n\npenguins_raw |&gt; \n  filter(`Clutch Completion` == \"Yes\") |&gt; # to filter out penguins that did not have an (observed) full nest \n  summarize(max_flipper_length = max(`Flipper Length (mm)`, na.rm = T),\n            min_flipper_length = min(`Flipper Length (mm)`, na.rm = T))\n\n# A tibble: 1 × 2\n  max_flipper_length min_flipper_length\n               &lt;dbl&gt;              &lt;dbl&gt;\n1                231                174\n\n\nGrouped summaries allow us to disaggregate summaries according to other variables (usually categorical):\n\npenguins_raw |&gt; \n  filter(`Clutch Completion` == \"Yes\") |&gt; # to filter out penguins that did not have an (observed) full nest \n  summarize(max_flipper_length = max(`Flipper Length (mm)`, na.rm = T),\n            min_flipper_length = min(`Flipper Length (mm)`, na.rm = T),\n            .by = Sex)  #  to group by sex \n\n# A tibble: 3 × 3\n  Sex    max_flipper_length min_flipper_length\n  &lt;chr&gt;               &lt;dbl&gt;              &lt;dbl&gt;\n1 MALE                  231                178\n2 FEMALE                222                174\n3 &lt;NA&gt;                  217                179\n\npenguins_raw |&gt; \n  filter(`Clutch Completion` == \"Yes\") |&gt; # to filter out penguins that did not have an (observed) full nest \n  summarize(max_flipper_length = max(`Flipper Length (mm)`, na.rm = T),\n            min_flipper_length = min(`Flipper Length (mm)`, na.rm = T),\n            .by = Sex) |&gt;  #  to group by sex \n  filter(is.na(Sex) == F) # to drop the penguins with an unknown sex \n\n# A tibble: 2 × 3\n  Sex    max_flipper_length min_flipper_length\n  &lt;chr&gt;               &lt;dbl&gt;              &lt;dbl&gt;\n1 MALE                  231                178\n2 FEMALE                222                174\n\n\n\n\n\n\n\n\nExercise\n\n\n\nObtain the maximum and minimum flipper length to mass ratio (call them max_ratio and min_ratio, drawing from the length_mass_ratio variable from before) for each penguin species.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\npenguins_raw |&gt; \n select(Species, `Body Mass (g)`, matches(\"Length\")) |&gt; # select just for clarity\n    rename(flipper_length = `Flipper Length (mm)`) |&gt;\n  mutate(length_mass_ratio = flipper_length/`Body Mass (g)`) |&gt;\n  # summarize flipper length to mass ratio by species\n summarize(max_ratio = max(length_mass_ratio, na.rm = T),\n            min_ratio = min(length_mass_ratio, na.rm = T),\n            .by = Species)   #  to group by species \n\n# A tibble: 3 × 3\n  Species                                   max_ratio min_ratio\n  &lt;chr&gt;                                         &lt;dbl&gt;     &lt;dbl&gt;\n1 Adelie Penguin (Pygoscelis adeliae)          0.0660    0.0396\n2 Gentoo penguin (Pygoscelis papua)            0.0527    0.0351\n3 Chinstrap penguin (Pygoscelis antarctica)    0.0711    0.0438",
    "crumbs": [
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#recoding-variables",
    "href": "lessons/r-lessons/r-tidydata.html#recoding-variables",
    "title": "R for Data Cleaning",
    "section": "Recoding variables",
    "text": "Recoding variables\nTake a look at the Species variable. We can do a simple tabulation with count():\n\npenguins_raw |&gt; \n  count(Species)\n\n# A tibble: 3 × 2\n  Species                                       n\n  &lt;chr&gt;                                     &lt;int&gt;\n1 Adelie Penguin (Pygoscelis adeliae)         152\n2 Chinstrap penguin (Pygoscelis antarctica)    68\n3 Gentoo penguin (Pygoscelis papua)           124\n\n\n\n\n\n\n\n\nTip\n\n\n\nAnother common way to compute quick tabulations in R is with the table() function. Be aware that this takes a vector as the input:\n\ntable(penguins_raw$Species)\n\n\n      Adelie Penguin (Pygoscelis adeliae) \n                                      152 \nChinstrap penguin (Pygoscelis antarctica) \n                                       68 \n        Gentoo penguin (Pygoscelis papua) \n                                      124 \n\n\n\n\nWe might want to recode this variable. For instance, if we are only interested in the Chinstrap penguins, we could create a dummy/binary variable for whether the penguin is a Chinstrap or not. We can do this with if_else(), which works with logical conditions:\n\npenguins_raw |&gt; \n  # the arguments are condition, true (what to do if true), false\n  mutate(chinstrap = if_else(Species == \"Chinstrap penguin (Pygoscelis antarctica)\", 1, 0)) |&gt; \n  count(chinstrap)\n\n# A tibble: 2 × 2\n  chinstrap     n\n      &lt;dbl&gt; &lt;int&gt;\n1         0   276\n2         1    68\n\n\nInstead of a numeric classification (0 and 1), we could use characters:\n\npenguins_raw |&gt; \n  # the arguments are condition, true (what to do if true), false\n  mutate(chinstrap = if_else(Species == \"Chinstrap penguin (Pygoscelis antarctica)\", \"Chinstrap\", \"Other\")) |&gt; \n  count(chinstrap)\n\n# A tibble: 2 × 2\n  chinstrap     n\n  &lt;chr&gt;     &lt;int&gt;\n1 Chinstrap    68\n2 Other       276\n\n\nif_else() is great for binary recoding. But sometimes we want to create more than two categories. We can use case_when(). This time, say we just want to simplify the Species variable to the familiar names of the penguins, not their scientific names:\n\npenguins_raw |&gt; \n  # syntax is condition ~ value\n  mutate(species = case_when(\n    Species == \"Adelie Penguin (Pygoscelis adeliae)\" ~ \"Adelie\",\n    Species == \"Chinstrap penguin (Pygoscelis antarctica)\" ~ \"Chinstrap\", \n    Species == \"Gentoo penguin (Pygoscelis papua)\" ~ \"Gentoo\",\n    .default = \"Other\" # what to do in all other cases\n  )) |&gt; \n  count(species)\n\n# A tibble: 3 × 2\n  species       n\n  &lt;chr&gt;     &lt;int&gt;\n1 Adelie      152\n2 Chinstrap    68\n3 Gentoo      124\n\n\nSave this as an object called species_table. We will use this later.\n\nspecies_table &lt;- penguins_raw |&gt; \n  # syntax is condition ~ value\n  mutate(species = case_when(\n    Species == \"Adelie Penguin (Pygoscelis adeliae)\" ~ \"Adelie\",\n    Species == \"Chinstrap penguin (Pygoscelis antarctica)\" ~ \"Chinstrap\", \n    Species == \"Gentoo penguin (Pygoscelis papua)\" ~ \"Gentoo\",\n    .default = \"Other\" # what to do in all other cases\n  )) |&gt; \n  count(species)\n\nThe .default = argument in case_when() can also be used to leave the variable as-is for non-specified cases. For example, let’s combine Adelie and Gentoo species:\n\npenguins_raw |&gt; \n  # syntax is condition ~ value\n  mutate(species = case_when(\n    Species %in% c(\"Adelie Penguin (Pygoscelis adeliae)\", \"Gentoo penguin (Pygoscelis papua)\") ~ \"Adelie/Gentoo\",\n    Species == \"Chinstrap penguin (Pygoscelis antarctica)\" ~ \"Chinstrap\",  \n    .default = \"Other\" # what to do in all other cases\n  )) |&gt; \n  count(species)\n\n# A tibble: 2 × 2\n  species           n\n  &lt;chr&gt;         &lt;int&gt;\n1 Adelie/Gentoo   276\n2 Chinstrap        68\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\nCreate a dummy variable, large_flipper, for whether the penguin has a flipper that is longer than 210mm. Then compute its mean.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\nSay you want to get more specific and determine whether the flipper is small, medium, or large. Say a small flipper is 180mm or smaller, a medium-sized flipper ranges from 180 - 210mm, and a large flipper is longer than 210mm. Create the variable flipper_size that takes on the values Small, Medium, or Large depending on the length.\n\n\n\n\n\n\n\nSolution",
    "crumbs": [
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#missing-values",
    "href": "lessons/r-lessons/r-tidydata.html#missing-values",
    "title": "R for Data Cleaning",
    "section": "Missing values",
    "text": "Missing values\nMissing values are commonplace in real datasets. In R, missing values are a special type of value in vectors, denoted as NA.\n\n\n\n\n\n\nWarning\n\n\n\nThe special value NA is different from the character value “NA”. For example, notice that a numeric vector can have NAs, while it obviously cannot hold the character value “NA”:\n\nc(5, 4.6, NA, 8)\n\n[1] 5.0 4.6  NA 8.0\n\n\n\n\nA quick way to check for missing values in small datasets is with the summary() function:\n\nsummary(penguins_raw)\n\n  studyName         Sample Number      Species             Region         \n Length:344         Min.   :  1.00   Length:344         Length:344        \n Class :character   1st Qu.: 29.00   Class :character   Class :character  \n Mode  :character   Median : 58.00   Mode  :character   Mode  :character  \n                    Mean   : 63.15                                        \n                    3rd Qu.: 95.25                                        \n                    Max.   :152.00                                        \n                                                                          \n    Island             Stage           Individual ID      Clutch Completion \n Length:344         Length:344         Length:344         Length:344        \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n                                                                            \n    Date Egg          Culmen Length (mm) Culmen Depth (mm) Flipper Length (mm)\n Min.   :2007-11-09   Min.   :32.10      Min.   :13.10     Min.   :172.0      \n 1st Qu.:2007-11-28   1st Qu.:39.23      1st Qu.:15.60     1st Qu.:190.0      \n Median :2008-11-09   Median :44.45      Median :17.30     Median :197.0      \n Mean   :2008-11-27   Mean   :43.92      Mean   :17.15     Mean   :200.9      \n 3rd Qu.:2009-11-16   3rd Qu.:48.50      3rd Qu.:18.70     3rd Qu.:213.0      \n Max.   :2009-12-01   Max.   :59.60      Max.   :21.50     Max.   :231.0      \n                      NA's   :2          NA's   :2         NA's   :2          \n Body Mass (g)      Sex            Delta 15 N (o/oo) Delta 13 C (o/oo)\n Min.   :2700   Length:344         Min.   : 7.632    Min.   :-27.02   \n 1st Qu.:3550   Class :character   1st Qu.: 8.300    1st Qu.:-26.32   \n Median :4050   Mode  :character   Median : 8.652    Median :-25.83   \n Mean   :4202                      Mean   : 8.733    Mean   :-25.69   \n 3rd Qu.:4750                      3rd Qu.: 9.172    3rd Qu.:-25.06   \n Max.   :6300                      Max.   :10.025    Max.   :-23.79   \n NA's   :2                         NA's   :14        NA's   :13       \n   Comments        \n Length:344        \n Class :character  \n Mode  :character  \n                   \n                   \n                   \n                   \n\n\nNotice that we have missingness in the Flipper Length (mm) and Body Mass (g) variables, among others. We might want to filter the dataset to see which observations are in this situation:\n\npenguins_raw |&gt; \n  filter(`Body Mass (g)` == NA | `Flipper Length (mm)` == NA)\n\n# A tibble: 0 × 17\n# ℹ 17 variables: studyName &lt;chr&gt;, Sample Number &lt;dbl&gt;, Species &lt;chr&gt;,\n#   Region &lt;chr&gt;, Island &lt;chr&gt;, Stage &lt;chr&gt;, Individual ID &lt;chr&gt;,\n#   Clutch Completion &lt;chr&gt;, Date Egg &lt;date&gt;, Culmen Length (mm) &lt;dbl&gt;,\n#   Culmen Depth (mm) &lt;dbl&gt;, Flipper Length (mm) &lt;dbl&gt;, Body Mass (g) &lt;dbl&gt;,\n#   Sex &lt;chr&gt;, Delta 15 N (o/oo) &lt;dbl&gt;, Delta 13 C (o/oo) &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\nBut the code above doesn’t work! To refer to missing values in logical conditions, we cannot use == NA. Instead, we need to use the is.na() function:\n\npenguins_raw |&gt; \n  filter(is.na(`Body Mass (g)`) | is.na(`Flipper Length (mm)`))\n\n# A tibble: 2 × 17\n  studyName `Sample Number` Species          Region Island Stage `Individual ID`\n  &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;          \n1 PAL0708                 4 Adelie Penguin … Anvers Torge… Adul… N2A2           \n2 PAL0910               120 Gentoo penguin … Anvers Biscoe Adul… N38A2          \n# ℹ 10 more variables: `Clutch Completion` &lt;chr&gt;, `Date Egg` &lt;date&gt;,\n#   `Culmen Length (mm)` &lt;dbl&gt;, `Culmen Depth (mm)` &lt;dbl&gt;,\n#   `Flipper Length (mm)` &lt;dbl&gt;, `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;,\n#   `Delta 15 N (o/oo)` &lt;dbl&gt;, `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;\n\n\nAs we saw earlier when trying to calculate the mean, in most R functions, missing values are “contagious.” This means that any missing value will contaminate the operation and carry over to the results. Recall:\n\npenguins_raw |&gt; \n  summarize(mean_flipper_length = mean(`Flipper Length (mm)`))\n\n# A tibble: 1 × 1\n  mean_flipper_length\n                &lt;dbl&gt;\n1                  NA\n\n\nSometimes we’d like to perform our operations even in the presence of missing values, simply excluding them. Most basic R functions have an na.rm = argument to do this:\n\npenguins_raw |&gt; \n  summarize(mean_flipper_length = mean(`Flipper Length (mm)`, na.rm = T))\n\n# A tibble: 1 × 1\n  mean_flipper_length\n                &lt;dbl&gt;\n1                201.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCalculate the median value of the penguins’ flipper length and body mass for each Island (i.e., perform a grouped summary).\n\n\n\n\n\n\nSolution",
    "crumbs": [
      "R for Data Cleaning"
    ]
  }
]