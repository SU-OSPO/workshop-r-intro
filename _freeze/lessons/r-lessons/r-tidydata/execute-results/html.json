{
  "hash": "d202c529905a9abb5790c50fd179130d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R for Data Cleaning\"\nformat: html\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n\n\n\n+----------------------------------+----------------------------------+\n| ### Questions                    | ### Objectives                   |\n+==================================+==================================+\n| -   \"How can I summarize my data | -   \"To become familiar with the |\n|     in R?\"                       |     functions of the `dplyr` and |\n| -   \"How can R help make my      |     `tidyr` packages.\"           |\n|     research more reproducible?\" | -   \"To be able to use `dplyr`   |\n| -   \"How can I combine two       |     and `tidyr` to prepare data  |\n|     datasets from different      |     for analysis.\"               |\n|     sources?\"                    | -   \"To be able to combine two   |\n| -   \"How can data tidying        |     different data sources using |\n|     facilitate answering         |     joins.\"                      |\n|     analysis questions?\"         | -   \"To be able to create plots  |\n|                                  |     and summary tables to answer |\n|                                  |     analysis questions.\"         |\n+----------------------------------+----------------------------------+\n\n\n# Getting Started {#getting-started}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\n\n## Loading in the data\n\nThe output in your console shows that by doing this, we attach several\nuseful packages for data wrangling, including `readr`. Check out these\npackages and their documentation at\n[tidyverse.org](https://www.tidyverse.org)\n\n> **Reminder:** Many of these packages, including `dplyr` , come with\n> \"Cheatsheets\" found under the **Help** RStudio menu tab.\n\nReload your data:\n\nNotice that the output of the `read_csv()` function is pretty\ninformative. It tells us the name of all of our column headers as well\nas how it interpreted the data type. This birds-eye-view can help you\ntake a quick look that everything is how we expect it to be.\n\nNow we have the tools necessary to work through this lesson.\n\n# An introduction to data analysis in R using `dplyr` {#intro-data-analysis}\n\n## Get stats fast with `summarize()` {#get-stats-fast-with-summarize}\n\n[*Back to top*](#getting-started)\n\n## Narrow down rows with `filter()` {#narrow-down-rows-with-filter}\n\n[*Back to top*](#getting-started)\n\nNotice how the pipe operator (`%>%`) allows us to combine these two\nsimple steps into a more complicated data extraction?. We took the data,\nfiltered out the rows, then took the mean value. The argument we pass to\n`filter()` needs to be some expression that will return TRUE or FALSE.\nWe can use comparisons like `>` (greater than) and `<` (less than) for\nexample. Here we tested for equality using a double equals sign `==`.\nYou use `==` (double equals) when testing if two values are equal, and\nyou use `=` (single equals) when naming arguments that you are passing\nto functions. Try changing it to use `filter(year = 2007)` and see what\nhappens.\n\n## Grouping rows using `group_by()` {#grouping-rows-using-group_by}\n\n[*Back to top*](#getting-started)\n\nWe see that the life expectancy in 2007 is much larger than the value we\ngot using all of the rows. It seems life expectancy is increasing which\nis good news. But now we might be interested in calculating the average\nfor each year. Rather that doing a bunch of different `filter()`\nstatements, we can instead use the `group_by()` function. The function\nallows us to tell the code to treat the rows in logical groups, so\nrather than summarizing over all the rows, we will get one summary value\nfor each group. Here's what that will look like:\n\nThe `group_by()` function expects you to pass in the name of a column\n(or multiple columns separated by comma) in your data.\n\nNote that you might get a message about the summarize function\nregrouping the output by 'year'. This simply indicates what the function\nis grouping by.\n\nYou can also create more than one new column when you call\n`summarize()`. To do so, you must separate your columns with a comma.\nBuilding on the code from the last exercise, let's add a new column that\ncalculates the minimum life expectancy for each continent.\n\n## Make new variables with `mutate()` {#make-new-variables-with-mutate}\n\n[*Back to top*](#getting-started)\n\nEach time we ran `summarize()`, we got back fewer rows than passed in.\nWe either got one row back, or one row per group. But sometimes we want\nto create a new column in our data without changing the number of rows.\nThe function we use to create new columns is called `mutate()`.\n\nWe have a column for the population and the GDP per capita. If we wanted\nto get the total GDP, we could multiply the per capita GDP values by the\ntotal population. Here's what such a `mutate()` command would look like:\n\nThis will add a new column called \"gdp\" to our data. We use the column\nnames as if they were regular values that we want to perform\nmathematical operations on and provide the name in front of an equals\nsign like we have done with `summarize()`\n\n## Subset columns using `select()` {#subset-columns-using-select}\n\n[*Back to top*](#getting-started)\n\nWe use the `filter()` function to choose a subset of the rows from our\ndata, but when we want to choose a subset of columns from our data we\nuse `select()`. For example, if we only wanted to see the population\n(\"pop\") and year values, we can do:\n\nWe can also use `select()` to drop/remove particular columns by putting\na minus sign (`-`) in front of the column name. For example, if we want\neverything but the continent column, we can do:\n\n## Changing the shape of the data\n\n[*Back to top*](#getting-started)\n\nData comes in many shapes and sizes, and one way we classify data is\neither \"wide\" or \"long.\" Data that is \"long\" has one row per\nobservation. The gapminder_data data is in a long format. We have one\nrow for each country for each year and each different measurement for\nthat country is in a different column. We might describe this data as\n\"tidy\" because it makes it easy to work with `ggplot2` and `dplyr`\nfunctions (this is where the \"tidy\" in \"tidyverse\" comes from). As tidy\nas it may be, sometimes we may want our data in a \"wide\" format.\nTypically in \"wide\" format each row represents a group of observations\nand each value is placed in a different column rather than a different\nrow. For example maybe we want only one row per country and want to\nspread the life expectancy values into different columns (one for each\nyear).\n\nThe `tidyr` package contains the functions `pivot_wider` and\n`pivot_longer` that make it easy to switch between the two formats. The\n`tidyr` package is included in the `tidyverse` package so we don't need\nto do anything to load it.\n\nNotice here that we tell `pivot_wider()` which columns to pull the names\nwe wish our new columns to be named from the year variable, and the\nvalues to populate those columns from the lifeExp variable. (Again,\nneither of which have to be in quotes in the code when there are no\nspecial characters or spaces - certainly an incentive not to use special\ncharacters or spaces!) We see that the resulting table has new columns\nby year, and the values populate it with our remaining variables\ndictating the rows.\n\nBefore we move on to more data cleaning, let's create the final\ngapminder dataframe we will be working with for the rest of the lesson!\n\n## Reviewing Git and GitHub\n\nNow that we have our gapminder data prepared, let's use what we learned\nabout git and GitHub in the previous lesson to add, commit, and push our\nchanges.\n\nOpen Terminal/Git Bash, if you do not have it open already. First we'll\nneed to navigate to our un-report directory.\n\nLet's start by print our current working directory and listing the items\nin the directory, to see where we are.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}