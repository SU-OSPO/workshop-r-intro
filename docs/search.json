[
  {
    "objectID": "lessons/r-lessons/r-markdown.html",
    "href": "lessons/r-lessons/r-markdown.html",
    "title": "R for Data Cleaning",
    "section": "",
    "text": "“How can I summarize my data in R?”\n“How can R help make my research more reproducible?”\n“How can I combine two datasets from different sources?”\n“How can data tidying facilitate answering analysis questions?”\n\n\n“To become familiar with the functions of the dplyr and tidyr packages.”\n“To be able to use dplyr and tidyr to prepare data for analysis.”\n“To be able to combine two different data sources using joins.”\n“To be able to create plots and summary tables to answer analysis questions.”",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-markdown.html#loading-in-the-data",
    "href": "lessons/r-lessons/r-markdown.html#loading-in-the-data",
    "title": "R for Data Cleaning",
    "section": "Loading in the data",
    "text": "Loading in the data\nThe output in your console shows that by doing this, we attach several useful packages for data wrangling, including readr. Check out these packages and their documentation at tidyverse.org\n\nReminder: Many of these packages, including dplyr , come with “Cheatsheets” found under the Help RStudio menu tab.\n\nReload your data:\nNotice that the output of the read_csv() function is pretty informative. It tells us the name of all of our column headers as well as how it interpreted the data type. This birds-eye-view can help you take a quick look that everything is how we expect it to be.\nNow we have the tools necessary to work through this lesson.",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-markdown.html#get-stats-fast-with-summarize",
    "href": "lessons/r-lessons/r-markdown.html#get-stats-fast-with-summarize",
    "title": "R for Data Cleaning",
    "section": "Get stats fast with summarize()",
    "text": "Get stats fast with summarize()\nBack to top",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-markdown.html#narrow-down-rows-with-filter",
    "href": "lessons/r-lessons/r-markdown.html#narrow-down-rows-with-filter",
    "title": "R for Data Cleaning",
    "section": "Narrow down rows with filter()",
    "text": "Narrow down rows with filter()\nBack to top\nNotice how the pipe operator (%&gt;%) allows us to combine these two simple steps into a more complicated data extraction?. We took the data, filtered out the rows, then took the mean value. The argument we pass to filter() needs to be some expression that will return TRUE or FALSE. We can use comparisons like &gt; (greater than) and &lt; (less than) for example. Here we tested for equality using a double equals sign ==. You use == (double equals) when testing if two values are equal, and you use = (single equals) when naming arguments that you are passing to functions. Try changing it to use filter(year = 2007) and see what happens.",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-markdown.html#grouping-rows-using-group_by",
    "href": "lessons/r-lessons/r-markdown.html#grouping-rows-using-group_by",
    "title": "R for Data Cleaning",
    "section": "Grouping rows using group_by()",
    "text": "Grouping rows using group_by()\nBack to top\nWe see that the life expectancy in 2007 is much larger than the value we got using all of the rows. It seems life expectancy is increasing which is good news. But now we might be interested in calculating the average for each year. Rather that doing a bunch of different filter() statements, we can instead use the group_by() function. The function allows us to tell the code to treat the rows in logical groups, so rather than summarizing over all the rows, we will get one summary value for each group. Here’s what that will look like:\nThe group_by() function expects you to pass in the name of a column (or multiple columns separated by comma) in your data.\nNote that you might get a message about the summarize function regrouping the output by ‘year’. This simply indicates what the function is grouping by.\nYou can also create more than one new column when you call summarize(). To do so, you must separate your columns with a comma. Building on the code from the last exercise, let’s add a new column that calculates the minimum life expectancy for each continent.",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-markdown.html#make-new-variables-with-mutate",
    "href": "lessons/r-lessons/r-markdown.html#make-new-variables-with-mutate",
    "title": "R for Data Cleaning",
    "section": "Make new variables with mutate()",
    "text": "Make new variables with mutate()\nBack to top\nEach time we ran summarize(), we got back fewer rows than passed in. We either got one row back, or one row per group. But sometimes we want to create a new column in our data without changing the number of rows. The function we use to create new columns is called mutate().\nWe have a column for the population and the GDP per capita. If we wanted to get the total GDP, we could multiply the per capita GDP values by the total population. Here’s what such a mutate() command would look like:\nThis will add a new column called “gdp” to our data. We use the column names as if they were regular values that we want to perform mathematical operations on and provide the name in front of an equals sign like we have done with summarize()",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-markdown.html#subset-columns-using-select",
    "href": "lessons/r-lessons/r-markdown.html#subset-columns-using-select",
    "title": "R for Data Cleaning",
    "section": "Subset columns using select()",
    "text": "Subset columns using select()\nBack to top\nWe use the filter() function to choose a subset of the rows from our data, but when we want to choose a subset of columns from our data we use select(). For example, if we only wanted to see the population (“pop”) and year values, we can do:\nWe can also use select() to drop/remove particular columns by putting a minus sign (-) in front of the column name. For example, if we want everything but the continent column, we can do:",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-markdown.html#changing-the-shape-of-the-data",
    "href": "lessons/r-lessons/r-markdown.html#changing-the-shape-of-the-data",
    "title": "R for Data Cleaning",
    "section": "Changing the shape of the data",
    "text": "Changing the shape of the data\nBack to top\nData comes in many shapes and sizes, and one way we classify data is either “wide” or “long.” Data that is “long” has one row per observation. The gapminder_data data is in a long format. We have one row for each country for each year and each different measurement for that country is in a different column. We might describe this data as “tidy” because it makes it easy to work with ggplot2 and dplyr functions (this is where the “tidy” in “tidyverse” comes from). As tidy as it may be, sometimes we may want our data in a “wide” format. Typically in “wide” format each row represents a group of observations and each value is placed in a different column rather than a different row. For example maybe we want only one row per country and want to spread the life expectancy values into different columns (one for each year).\nThe tidyr package contains the functions pivot_wider and pivot_longer that make it easy to switch between the two formats. The tidyr package is included in the tidyverse package so we don’t need to do anything to load it.\nNotice here that we tell pivot_wider() which columns to pull the names we wish our new columns to be named from the year variable, and the values to populate those columns from the lifeExp variable. (Again, neither of which have to be in quotes in the code when there are no special characters or spaces - certainly an incentive not to use special characters or spaces!) We see that the resulting table has new columns by year, and the values populate it with our remaining variables dictating the rows.\nBefore we move on to more data cleaning, let’s create the final gapminder dataframe we will be working with for the rest of the lesson!",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-markdown.html#reviewing-git-and-github",
    "href": "lessons/r-lessons/r-markdown.html#reviewing-git-and-github",
    "title": "R for Data Cleaning",
    "section": "Reviewing Git and GitHub",
    "text": "Reviewing Git and GitHub\nNow that we have our gapminder data prepared, let’s use what we learned about git and GitHub in the previous lesson to add, commit, and push our changes.\nOpen Terminal/Git Bash, if you do not have it open already. First we’ll need to navigate to our un-report directory.\nLet’s start by print our current working directory and listing the items in the directory, to see where we are.",
    "crumbs": [
      "Home",
      "R for Data Cleaning"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html",
    "href": "lessons/shell-intro/shell-intro.html",
    "title": "Working in the Unix Shell",
    "section": "",
    "text": "What is a command shell and why would I use one?\n\n\nExplain how the shell relates to the keyboard, the screen, the operating system, and users’ programs.\nExplain when and why command-line interfaces should be used instead of graphical interfaces.",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#installation",
    "href": "lessons/shell-intro/shell-intro.html#installation",
    "title": "Working in the Unix Shell",
    "section": "Installation",
    "text": "Installation\nIf you do not already have the shell software installed, you will need to download and install it. Follow the directions below for your operating system\n\n\n\n\n\n\nWindows\n\n\n\n\n\nComputers with Windows operating systems do not automatically have a Unix Shell program installed. In this lesson, we encourage you to use an emulator included in Git for Windows, which gives you access to both Bash shell commands and Git.\nOnce installed, you can open a terminal by running the program Git Bash from the Windows start menu.\nFor advanced users:\nAs an alternative to Git for Windows you may wish to Install the Windows Subsystem for Linux which gives access to a Bash shell command-line tool in Windows 10 and above.\nPlease note that commands in the Windows Subsystem for Linux (WSL) may differ slightly from those shown in the lesson or presented in the workshop.\n\n\n\n\n\n\n\n\n\nMacOS\n\n\n\n\n\nFor a Mac computer running macOS Mojave or earlier releases, the default Unix Shell is Bash. For a Mac computer running macOS Catalina or later releases, the default Unix Shell is Zsh. Your default shell is available via the Terminal program within your Utilities folder.\nTo open Terminal, try one or both of the following:\n\nIn Finder, select the Go menu, then select Utilities. Locate Terminal in the Utilities folder and open it.\nUse the Mac ‘Spotlight’ computer search function. Search for: Terminal and press Return.\n\nTo check if your machine is set up to use something other than Bash, type echo $SHELL in your terminal window.\nIf your machine is set up to use something other than Bash, you can run it by opening a terminal and typing bash.\nHow to Use Terminal on a Mac\n\n\n\n\n\n\n\n\n\nLinux\n\n\n\n\n\nThe default Unix Shell for Linux operating systems is usually Bash. On most versions of Linux, it is accessible by running the Gnome Terminal or KDE Konsole or xterm, which can be found via the applications menu or the search bar. If your machine is set up to use something other than Bash, you can run it by opening a terminal and typing bash.",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#open-a-new-shell",
    "href": "lessons/shell-intro/shell-intro.html#open-a-new-shell",
    "title": "Working in the Unix Shell",
    "section": "Open a new shell",
    "text": "Open a new shell\nAfter installing the software:\n\nOpen a terminal. If you’re not sure how to open a terminal on your operating system, see the instructions below.\nIn the terminal type cd then press the Return key. This step will make sure you start with your home folder as your working directory.\n\nIn the lesson, you will find out how to access the data files in this folder.\n\n\n\n\n\n\nWhere to type commands: How to open a new shell\n\n\n\nThe shell is a program that enables us to send commands to the computer and receive output. It is also referred to as the terminal or command line.\nSome computers include a default Unix Shell program. The steps below describe some methods for identifying and opening a Unix Shell program if you already have one installed. There are also options for identifying and downloading a Unix Shell program, a Linux/UNIX emulator, or a program to access a Unix Shell on a server.\nIf none of the options below address your circumstances, try an online search for: Unix shell [your computer model] [your operating system].",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#a-typical-problem",
    "href": "lessons/shell-intro/shell-intro.html#a-typical-problem",
    "title": "Working in the Unix Shell",
    "section": "A Typical Problem",
    "text": "A Typical Problem\nTODO: Info here giving penguin background\nIn order to achieve our task, we need to know how to:\n\nnavigate to a file/directory\ncreate a file/directory\ncheck the length of a file\nchain commands together\nretrieve a set of files\niterate over files\nrun a shell script containing her pipeline\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA shell is a program whose primary purpose is to read commands and run other programs.\nThis lesson uses Bash, the default shell in many implementations of Unix.\nPrograms can be run in Bash by entering commands at the command-line prompt.\nThe shell’s main advantages are its high action-to-keystroke ratio, its support for automating repetitive tasks, and its capacity to access networked machines.\nA significant challenge when using the shell can be knowing what commands need to be run and how to run them.",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html",
    "href": "lessons/r-lessons/r-tidydata.html",
    "title": "Making Reports with R Markdown",
    "section": "",
    "text": "“How can I summarize my data in R?”\n“How can R help make my research more reproducible?”\n“How can I combine two datasets from different sources?”\n“How can data tidying facilitate answering analysis questions?”\n\n\n“To become familiar with the functions of the dplyr and tidyr packages.”\n“To be able to use dplyr and tidyr to prepare data for analysis.”\n“To be able to combine two different data sources using joins.”\n“To be able to create plots and summary tables to answer analysis questions.”",
    "crumbs": [
      "Home",
      "Making Reports with R Markdown"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#loading-in-the-data",
    "href": "lessons/r-lessons/r-tidydata.html#loading-in-the-data",
    "title": "Making Reports with R Markdown",
    "section": "Loading in the data",
    "text": "Loading in the data\nThe output in your console shows that by doing this, we attach several useful packages for data wrangling, including readr. Check out these packages and their documentation at tidyverse.org\n\nReminder: Many of these packages, including dplyr , come with “Cheatsheets” found under the Help RStudio menu tab.\n\nReload your data:\nNotice that the output of the read_csv() function is pretty informative. It tells us the name of all of our column headers as well as how it interpreted the data type. This birds-eye-view can help you take a quick look that everything is how we expect it to be.\nNow we have the tools necessary to work through this lesson.",
    "crumbs": [
      "Home",
      "Making Reports with R Markdown"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#get-stats-fast-with-summarize",
    "href": "lessons/r-lessons/r-tidydata.html#get-stats-fast-with-summarize",
    "title": "Making Reports with R Markdown",
    "section": "Get stats fast with summarize()",
    "text": "Get stats fast with summarize()\nBack to top",
    "crumbs": [
      "Home",
      "Making Reports with R Markdown"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#narrow-down-rows-with-filter",
    "href": "lessons/r-lessons/r-tidydata.html#narrow-down-rows-with-filter",
    "title": "Making Reports with R Markdown",
    "section": "Narrow down rows with filter()",
    "text": "Narrow down rows with filter()\nBack to top\nNotice how the pipe operator (%&gt;%) allows us to combine these two simple steps into a more complicated data extraction?. We took the data, filtered out the rows, then took the mean value. The argument we pass to filter() needs to be some expression that will return TRUE or FALSE. We can use comparisons like &gt; (greater than) and &lt; (less than) for example. Here we tested for equality using a double equals sign ==. You use == (double equals) when testing if two values are equal, and you use = (single equals) when naming arguments that you are passing to functions. Try changing it to use filter(year = 2007) and see what happens.",
    "crumbs": [
      "Home",
      "Making Reports with R Markdown"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#grouping-rows-using-group_by",
    "href": "lessons/r-lessons/r-tidydata.html#grouping-rows-using-group_by",
    "title": "Making Reports with R Markdown",
    "section": "Grouping rows using group_by()",
    "text": "Grouping rows using group_by()\nBack to top\nWe see that the life expectancy in 2007 is much larger than the value we got using all of the rows. It seems life expectancy is increasing which is good news. But now we might be interested in calculating the average for each year. Rather that doing a bunch of different filter() statements, we can instead use the group_by() function. The function allows us to tell the code to treat the rows in logical groups, so rather than summarizing over all the rows, we will get one summary value for each group. Here’s what that will look like:\nThe group_by() function expects you to pass in the name of a column (or multiple columns separated by comma) in your data.\nNote that you might get a message about the summarize function regrouping the output by ‘year’. This simply indicates what the function is grouping by.\nYou can also create more than one new column when you call summarize(). To do so, you must separate your columns with a comma. Building on the code from the last exercise, let’s add a new column that calculates the minimum life expectancy for each continent.",
    "crumbs": [
      "Home",
      "Making Reports with R Markdown"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#make-new-variables-with-mutate",
    "href": "lessons/r-lessons/r-tidydata.html#make-new-variables-with-mutate",
    "title": "Making Reports with R Markdown",
    "section": "Make new variables with mutate()",
    "text": "Make new variables with mutate()\nBack to top\nEach time we ran summarize(), we got back fewer rows than passed in. We either got one row back, or one row per group. But sometimes we want to create a new column in our data without changing the number of rows. The function we use to create new columns is called mutate().\nWe have a column for the population and the GDP per capita. If we wanted to get the total GDP, we could multiply the per capita GDP values by the total population. Here’s what such a mutate() command would look like:\nThis will add a new column called “gdp” to our data. We use the column names as if they were regular values that we want to perform mathematical operations on and provide the name in front of an equals sign like we have done with summarize()",
    "crumbs": [
      "Home",
      "Making Reports with R Markdown"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#subset-columns-using-select",
    "href": "lessons/r-lessons/r-tidydata.html#subset-columns-using-select",
    "title": "Making Reports with R Markdown",
    "section": "Subset columns using select()",
    "text": "Subset columns using select()\nBack to top\nWe use the filter() function to choose a subset of the rows from our data, but when we want to choose a subset of columns from our data we use select(). For example, if we only wanted to see the population (“pop”) and year values, we can do:\nWe can also use select() to drop/remove particular columns by putting a minus sign (-) in front of the column name. For example, if we want everything but the continent column, we can do:",
    "crumbs": [
      "Home",
      "Making Reports with R Markdown"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#changing-the-shape-of-the-data",
    "href": "lessons/r-lessons/r-tidydata.html#changing-the-shape-of-the-data",
    "title": "Making Reports with R Markdown",
    "section": "Changing the shape of the data",
    "text": "Changing the shape of the data\nBack to top\nData comes in many shapes and sizes, and one way we classify data is either “wide” or “long.” Data that is “long” has one row per observation. The gapminder_data data is in a long format. We have one row for each country for each year and each different measurement for that country is in a different column. We might describe this data as “tidy” because it makes it easy to work with ggplot2 and dplyr functions (this is where the “tidy” in “tidyverse” comes from). As tidy as it may be, sometimes we may want our data in a “wide” format. Typically in “wide” format each row represents a group of observations and each value is placed in a different column rather than a different row. For example maybe we want only one row per country and want to spread the life expectancy values into different columns (one for each year).\nThe tidyr package contains the functions pivot_wider and pivot_longer that make it easy to switch between the two formats. The tidyr package is included in the tidyverse package so we don’t need to do anything to load it.\nNotice here that we tell pivot_wider() which columns to pull the names we wish our new columns to be named from the year variable, and the values to populate those columns from the lifeExp variable. (Again, neither of which have to be in quotes in the code when there are no special characters or spaces - certainly an incentive not to use special characters or spaces!) We see that the resulting table has new columns by year, and the values populate it with our remaining variables dictating the rows.\nBefore we move on to more data cleaning, let’s create the final gapminder dataframe we will be working with for the rest of the lesson!",
    "crumbs": [
      "Home",
      "Making Reports with R Markdown"
    ]
  },
  {
    "objectID": "lessons/r-lessons/r-tidydata.html#reviewing-git-and-github",
    "href": "lessons/r-lessons/r-tidydata.html#reviewing-git-and-github",
    "title": "Making Reports with R Markdown",
    "section": "Reviewing Git and GitHub",
    "text": "Reviewing Git and GitHub\nNow that we have our gapminder data prepared, let’s use what we learned about git and GitHub in the previous lesson to add, commit, and push our changes.\nOpen Terminal/Git Bash, if you do not have it open already. First we’ll need to navigate to our un-report directory.\nLet’s start by print our current working directory and listing the items in the directory, to see where we are.",
    "crumbs": [
      "Home",
      "Making Reports with R Markdown"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#listing-files",
    "href": "lessons/shell-intro/shell-intro.html#listing-files",
    "title": "Working in the Unix Shell",
    "section": "Listing files",
    "text": "Listing files\n\n\n\n\n\n\nKey Points",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#command-not-found",
    "href": "lessons/shell-intro/shell-intro.html#command-not-found",
    "title": "Working in the Unix Shell",
    "section": "Command not found",
    "text": "Command not found\nSo let’s try our first command, ls, which is short for listing. This command will list the contents of the current directory:\n$ ls\nDesktop     Downloads   Movies      Pictures\nDocuments   Library     Music       Public\n\n\n\n\n\n\nCommand not found\n\n\n\nIf the shell can’t find a program whose name is the command you typed, it will print an error message such as:\n$ ks\nks: command not found\nThis might happen if the command was mis-typed or if the program corresponding to that command is not installed.\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA shell is a program whose primary purpose is to read commands and run other programs.\nThis lesson uses Bash, the default shell in many implementations of Unix.\nPrograms can be run in Bash by entering commands at the command-line prompt.\nThe shell’s main advantages are its high action-to-keystroke ratio, its support for automating repetitive tasks, and its capacity to access networked machines.\nA significant challenge when using the shell can be knowing what commands need to be run and how to run them.",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#the-prompt",
    "href": "lessons/shell-intro/shell-intro.html#the-prompt",
    "title": "Working in the Unix Shell",
    "section": "The prompt",
    "text": "The prompt\nWhen the shell is first opened, you are presented with a prompt, indicating that the shell is waiting for input.\n$\nThe shell typically uses $ as the prompt, but may use a different symbol. In the examples for this lesson, we’ll show the prompt as $. Most importantly, do not type the prompt when typing commands. Only type the command that follows the prompt. This rule applies both in these lessons and in lessons from other sources. Also note that after you type a command, you have to press the Enter key to execute it.\nThe prompt is followed by a text cursor, a character that indicates the position where your typing will appear. The cursor is usually a flashing or solid block, but it can also be an underscore or a pipe. You may have seen it in a text editor program, for example.\nNote that your prompt might look a little different. In particular, most popular shell environments by default put your user name and the host name before the $. Such a prompt might look like, e.g.:\nsklucas@localhost $\nThe prompt might even include more than this. Do not worry if your prompt is not just a short $. This lesson does not depend on this additional information and it should also not get in your way. The only important item to focus on is the $ character itself and we will see later why.\n\n\n\n\n\n\nOPTIONAL: Change your prompt to $\n\n\n\nIf you’d like to simplify your prompt for the purposes of this tutorial, copy and paste the code below into your terminal:\nPS1='$ '\n\n\nSo let’s try our first command, ls, which is short for listing. This command will list the contents of the current directory:\n$ ls\nDesktop     Downloads   Movies      Pictures\nDocuments   Library     Music       Public\n\n\n\n\n\n\nCommand not found\n\n\n\nIf the shell can’t find a program whose name is the command you typed, it will print an error message such as:\n$ ks\nks: command not found\nThis might happen if the command was mis-typed or if the program corresponding to that command is not installed.\n\n\n\nA Typical Problem\nYou are a marine biologist who has just returned from a six-month survey of the North Pacific Gyre, where you have sampled gelatinous marine life in the Great Pacific Garbage Patch. You have 1520 samples that you’ve run through an assay machine to measure the relative abundance of 300 proteins. You need to run these 1520 files through an imaginary program called goostats.sh. In addition to this huge task, you have to write up results by the end of the month, so your paper can appear in a special issue of Aquatic Goo Letters.\nIf you choose to run goostats.sh by hand using a GUI, you’ll have to select and open a file 1520 times. If goostats.sh takes 30 seconds to run each file, the whole process will take more than 12 hours. With the shell, you can instead assign your computer this mundane task while you focuses her attention on writing your paper.\nThe next few lessons will explore the ways you can achieve this. More specifically, the lessons explain how you can use a command shell to run the goostats.sh program, using loops to automate the repetitive steps of entering file names, so that your computer can work while you write your paper.\nAs a bonus, once you have put a processing pipeline together, you will be able to use it again whenever you collect more data.\nIn order to achieve her task, you need to know how to:\n\nnavigate to a file/directory\ncreate a file/directory\ncheck the length of a file\nchain commands together\nretrieve a set of files\niterate over files\nrun a shell script containing her pipeline\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA shell is a program whose primary purpose is to read commands and run other programs.\nThis lesson uses Bash, the default shell in many implementations of Unix.\nPrograms can be run in Bash by entering commands at the command-line prompt.\nThe shell’s main advantages are its high action-to-keystroke ratio, its support for automating repetitive tasks, and its capacity to access networked machines.\nA significant challenge when using the shell can be knowing what commands need to be run and how to run them.",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#where-am-i",
    "href": "lessons/shell-intro/shell-intro.html#where-am-i",
    "title": "Working in the Unix Shell",
    "section": "Where am I?",
    "text": "Where am I?\nFirst, let’s find out where we are by running a command called pwd (which stands for ‘print working directory’). Directories are like places — at any time while we are using the shell, we are in exactly one place called our current working directory. Commands mostly read and write files in the current working directory, i.e. ‘here’, so knowing where you are before running a command is important. pwd shows you where you are:\n$ pwd\n/Users/sklucas\nThe computer’s response is /Users/sklucas, which is my home directory.\n\nThe home directory\nThe home directory will look different on different operating systems.\n\nLinux: /home/sklucas\nWindows: C:\\Users\\sklucas (This may differ based on Windows versions)\n\nIf pwd returns something else, you may need to navigate to your home directory using the command cd.\nLet’s look at how a filesystem is organized:\n\nThe filesystem looks like an upside-down tree. We refer to the topmost directory as the “root directory”. It contains everything else. It is referred to with the / symbol.\nIn this illustration, we have several other directories stemming off of the root. The bin directory often refers to a location where programs are stored. tmp is a common directory on filesystems as a place to hold files that don’t need to be kept long-term. You may recognize the Users directory from the output we had above when typing pwd. We know the path of our home directory, where we currently are, is /Users/sklucas.\n\n\n\n\n\n\nSlashes\n\n\n\nThere are two meanings for the / character. When it appears at the front of a path, it means “root”, when it appears within a path, it acts as a separator.\n\n\n\nThe Users folder may have more than one directory in it. For example, the image below depicts two users, sklucas and Collin. The home directory just as the home directory for sklucas is /Users/sklucas, the home directory for Collin would be /Users/Collin. Typically, when you open a new command prompt, you will start in your home directory by default",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#listing-directory-contents",
    "href": "lessons/shell-intro/shell-intro.html#listing-directory-contents",
    "title": "Working in the Unix Shell",
    "section": "Listing directory contents",
    "text": "Listing directory contents\nWe often want to know what a directory contains. To do this, we use the “listing” command ls:\n$ ls\nwhich might return something that looks like this (results will vary):\nApplications  Documents  Library  Music    Public\nDesktop       Downloads  Movies   Pictures  \nls prints the names of the files and directories in your current location. Typing ls -F will give specific notation below based on the\n\nA trailing / indicates that this is a directory\n@ indicates a link\n* indicates an executable\n\nDepending on your shell’s default settings, the shell might also use colors to indicate whether each entry is a file or directory.\n\n\n\n\n\n\nClearing your terminal\n\n\n\nIf your screen gets too cluttered, you can clear your terminal using the clear command. You can still access previous commands using ↑↑ and ↓↓ to move line-by-line, or by scrolling in your terminal.",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#getting-help",
    "href": "lessons/shell-intro/shell-intro.html#getting-help",
    "title": "Working in the Unix Shell",
    "section": "Getting help",
    "text": "Getting help\nMost bash commands have help menus that tell the user about how the command is used and what options are available for tailoring the function. There are two common ways to get help with commands, which can differ based on the source of the command (built-in or externally installed), and the operating system.\n\nWe can pass a --help option to any command (on linux and Git Bash).\n$ ls --help\nWe can read the manual on a function using the man command (linux and OSX)\n$ man ls\nTo navigate through the man pages, you may use ↑↑ and ↓↓ to move line-by-line, or try bb and SpacebarSpacebar to skip up and down by a full page. To search for a character or word in the man pages, use // followed by the character or word you are searching for. Sometimes a search will result in multiple hits. If so, you can move between hits using NN (for moving forward) and Shift+NShift+N (for moving backward). To **quit** the man pages, press qq.\n\n\n\n\n\n\n\nBash Built-in commands\n\n\n\nSome commands are built in to the Bash shell, rather than existing as separate programs on the filesystem. One example is the cd “change directory” command. If you get a message like No manual entry for cd, try help cd instead. The help command is how you get usage information for Bash built-ins.",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#command-options",
    "href": "lessons/shell-intro/shell-intro.html#command-options",
    "title": "Working in the Unix Shell",
    "section": "Command options",
    "text": "Command options\nWe’ve seen that commands can have many options associated with them, which can control how the command functions. These are often notated by short and long forms that are typically equal in their meaning, but have conventional use in different scenarios.\nWhen options exist as both short and long options:\n\nUse the short option when typing commands directly into the shell to minimize keystrokes and get your task done faster.\nUse the long option in scripts to provide clarity. It will be read many times and typed once.\n\n\n\n\n\n\n\nUnsupported commandline options\n\n\n\nIf you try to use an option that is not supported, ls and other commands will usually print an error message similar to:\n$ ls -j\nMac zsh output:\nls: invalid option -- j\nusage: ls [-@ABCFGHILOPRSTUWXabcdefghiklmnopqrstuvwxy1%,] [--color=when] [-D format] [file ...]\nother Unix output:\nls: invalid option -- 'j'\nTry 'ls --help' for more information.\n\n\n\nChallenge Questions\nExplore the ls command options to answer the following questions:\n\n\n\n\n\n\nQuestion 1: Listing in long, human-readable format\n\n\n\nWhich options for ls produces output in long format that is human readable? (i.e. displaying something like 5.3K instead of 5369)\n\n\n\n\n\n\nSolution\n\n\n\n\n\nthe options -l and -h can be used with ls to make the output long and human readable. You can use them in two ways:\n\nls -l -h\nor string them together ls -lh\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 2: Listing in Reverse Chronological Order\n\n\n\nBy default, ls lists the contents of a directory in alphabetical order by name. The command ls -t lists items by time of last change instead of alphabetically. The command ls -r lists the contents of a directory in reverse order. Which file is displayed last when you combine the -t and -r options? Hint: You may need to use the -l option to see the last changed dates.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe most recently changed file is listed last when using -rt. This can be very useful for finding your most recent edits or checking to see if a new output file was written.",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#general-syntax-of-a-shell-command",
    "href": "lessons/shell-intro/shell-intro.html#general-syntax-of-a-shell-command",
    "title": "Working in the Unix Shell",
    "section": "General Syntax of a Shell Command",
    "text": "General Syntax of a Shell Command\nWe have now encountered commands, options, and arguments, but it is perhaps useful to formalise some terminology.\nConsider the command below as a general example of a command, which we will dissect into its component parts:\n$ ls -F /\n\nls is the command, with an option -F and an argument /. We’ve already encountered options which either start with a single dash (-), known as short options, or two dashes (--), known as long options. Options change the behavior of a command and arguments tell the command what to operate on (e.g. files and directories). Sometimes options and arguments are referred to as parameters. A command can be called with more than one option and more than one argument, but a command doesn’t always require an argument or an option.\nYou might sometimes see options being referred to as switches or flags, especially for options that take no argument. In this lesson we will stick with using the term option.\nEach part is separated by spaces. If you omit the space between ls and -F the shell will look for a command called ls-F, which doesn’t exist. Also, capitalization can be important. For example, ls -s will display the size of files and directories alongside the names, while ls -S will sort the files and directories by size, as shown below:\n$ cd ~/Desktop/shell-lesson-data\n$ ls -s exercise-data\ntotal 28\n 4 animal-counts   4 creatures  12 numbers.txt   4 alkanes   4 writing\nNote that the sizes returned by ls -s are in blocks. As these are defined differently for different operating systems, you may not obtain the same figures as in the example.\n$ ls -S exercise-data\nanimal-counts  creatures  alkanes  writing  numbers.txt\nPutting all that together, our command ls -F / above gives us a listing of files and directories in the root directory /. An example of the output you might get from the above command is given below:\n$ ls -F /\nApplications/         System/\nLibrary/              Users/\nNetwork/              Volumes/\n\nYour Task: Organizing Files\nKnowing this much about files and directories, You are ready to organize the files that the protein assay machine will create.\nYou create a directory called north-pacific-gyre (to remind yourself where the data came from), which will contain the data files from the assay machine and your data processing scripts.\nEach of your physical samples is labelled according to your lab’s convention with a unique ten-character ID, such as ‘NENE01729A’. This ID is what you used in your collection log to record the location, time, depth, and other characteristics of the sample, so you decide to use it within the filename of each data file. Since the output of the assay machine is plain text, you will call your files NENE01729A.txt, NENE01812A.txt, and so on. All 1520 files will go into the same directory.\nNow in your current directory shell-lesson-data, you can see what files you have using the command:\n$ ls north-pacific-gyre/\nThis command is a lot to type, but you can let the shell do most of the work through what is called tab completion. If you types:\n$ ls nor\nand then presses Tab (the tab key on her keyboard), the shell automatically completes the directory name for you:\n$ ls north-pacific-gyre/\nPressing Tab again does nothing, since there are multiple possibilities; pressing Tab twice brings up a list of all the files.\nIf you then presses G and then presses Tab again, the shell will append ‘goo’ since all files that start with ‘g’ share the first three characters ‘goo’.\n$ ls north-pacific-gyre/goo\nTo see all of those files, you can press Tab twice more.\nls north-pacific-gyre/goo\ngoodiff.sh   goostats.sh\nThis is called tab completion, and we will see it in many other tools as we go on.\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nThe file system is responsible for managing information on the disk.\nInformation is stored in files, which are stored in directories (folders).\nDirectories can also store other directories, which then form a directory tree.\npwd prints the user’s current working directory.\nls [path] prints a listing of a specific file or directory; ls on its own lists the current working directory.\ncd [path] changes the current working directory.\nMost commands take options that begin with a single -.\nDirectory names in a path are separated with / on Unix, but \\ on Windows.\n/ on its own is the root directory of the whole file system.\nAn absolute path specifies a location from the root of the file system.\nA relative path specifies a location starting from the current location.\n. on its own means ‘the current directory’; .. means ‘the directory above the current one’.",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#challenge-questions",
    "href": "lessons/shell-intro/shell-intro.html#challenge-questions",
    "title": "Working in the Unix Shell",
    "section": "Challenge Questions",
    "text": "Challenge Questions\nExplore the ls command options to answer the following questions:\n\n\n\n\n\n\nQuestion 1: Listing in long, human-readable format\n\n\n\nWhich options for ls produces output in long format that is human readable? (i.e. displaying something like 5.3K instead of 5369)\n\n\n\n\n\n\nSolution\n\n\n\n\n\nthe options -l and -h can be used with ls to make the output long and human readable. You can use them in two ways:\n\nls -l -h\nor string them together ls -lh\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 2: Listing in Reverse Chronological Order\n\n\n\nBy default, ls lists the contents of a directory in alphabetical order by name. The command ls -t lists items by time of last change instead of alphabetically. The command ls -r lists the contents of a directory in reverse order. Which file is displayed last when you combine the -t and -r options? Hint: You may need to use the -l option to see the last changed dates.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe most recently changed file is listed last when using -rt. This can be very useful for finding your most recent edits or checking to see if a new output file was written.",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  },
  {
    "objectID": "lessons/shell-intro/shell-intro.html#exploring-other-directories",
    "href": "lessons/shell-intro/shell-intro.html#exploring-other-directories",
    "title": "Working in the Unix Shell",
    "section": "Exploring other directories",
    "text": "Exploring other directories\nNot only can we use ls on the current working directory, but we can use it to list the contents of a different directory. Let’s take a look at our Desktop directory by running ls -F Desktop, i.e., the command ls with the -F option and the argument Desktop. The argument Desktop tells ls that we want a listing of something other than our current working directory:\n$ ls -F Desktop\nYou should see your newly created directory “workshop”\nshell-lesson-data/\nNote that if a directory named Desktop does not exist in your current working directory, this command will return an error. Typically, a Desktop directory exists in your home directory, which we assume is the current working directory of your bash shell.\nYour output should be a list of all the files and sub-directories in your Desktop directory, including the shell-lesson-data directory you downloaded at the setup for this lesson. (On most systems, the contents of the Desktop directory in the shell will show up as icons in a graphical user interface behind all the open windows. See if this is the case for you.)\nOrganizing things hierarchically helps us keep track of our work. While it’s possible to put hundreds of files in our home directory just as it’s possible to pile hundreds of printed papers on our desk, it’s much easier to find things when they’ve been organized into sensibly-named subdirectories.\nNow that we know the shell-lesson-data directory is located in our Desktop directory, we can do two things.\nFirst, using the same strategy as before, we can look at its contents by passing a directory name to ls:\n$ ls -F Desktop/shell-lesson-data\nexercise-data/  north-pacific-gyre/\nSecond, we can actually change our location to a different directory, so we are no longer located in our home directory.\nThe command to change locations is cd followed by a directory name to change our working directory. cd stands for ‘change directory’, which is a bit misleading. The command doesn’t change the directory; it changes the shell’s current working directory. In other words it changes the shell’s settings for what directory we are in. The cd command is akin to double-clicking a folder in a graphical interface to get into that folder.\nLet’s say we want to move into the exercise-data directory we saw above. We can use the following series of commands to get there:\n$ cd Desktop\n$ cd shell-lesson-data\n$ cd exercise-data\nThese commands will move us from our home directory into our Desktop directory, then into the shell-lesson-data directory, then into the exercise-data directory. You will notice that cd doesn’t print anything. This is normal. Many shell commands will not output anything to the screen when successfully executed. But if we run pwd after it, we can see that we are now in /Users/sklucas/Desktop/shell-lesson-data/exercise-data.\nIf we run ls -F without arguments now, it lists the contents of /Users/sklucas/Desktop/shell-lesson-data/exercise-data, because that’s where we now are:\n$ pwd\n/Users/sklucas/Desktop/shell-lesson-data/exercise-data\n$ ls -F\nalkanes/  animal-counts/  creatures/  numbers.txt  writing/\nWe now know how to go down the directory tree (i.e. how to go into a subdirectory), but how do we go up (i.e. how do we leave a directory and go into its parent directory)? We might try the following:\n$ cd shell-lesson-data\n-bash: cd: shell-lesson-data: No such file or directory\nBut we get an error! Why is this?\nWith our methods so far, cd can only see sub-directories inside your current directory. There are different ways to see directories above your current location; we’ll start with the simplest.\nThere is a shortcut in the shell to move up one directory level. It works as follows:\n$ cd ..\n.. is a special directory name meaning “the directory containing this one”, or more succinctly, the parent of the current directory. Sure enough, if we run pwd after running cd .., we’re back in /Users/sklucas/Desktop/shell-lesson-data:\n$ pwd\n/Users/sklucas/Desktop/shell-lesson-data\nThe special directory .. doesn’t usually show up when we run ls. If we want to display it, we can add the -a option to ls -F:\n$ ls -F -a\n./  ../  exercise-data/  north-pacific-gyre/\n-a stands for ‘show all’ (including hidden files); it forces ls to show us file and directory names that begin with ., such as .. (which, if we’re in /Users/sklucas, refers to the /Users directory). As you can see, it also displays another special directory that’s just called ., which means ‘the current working directory’. It may seem redundant to have a name for it, but we’ll see some uses for it soon.\nNote that in most command line tools, multiple options can be combined with a single - and no spaces between the options; ls -F -a is equivalent to ls -Fa.\n\n\n\n\n\n\nOther Hidden Files\n\n\n\nIn addition to the hidden directories .. and ., you may also see a file called .bash_profile. This file usually contains shell configuration settings. You may also see other files and directories beginning with .. These are usually files and directories that are used to configure different programs on your computer. The prefix . is used to prevent these configuration files from cluttering the terminal when a standard ls command is used.\n\n\nThese three commands are the basic commands for navigating the filesystem on your computer: pwd, ls, and cd. Let’s explore some variations on those commands. What happens if you type cd on its own, without giving a directory?\n$ cd\nHow can you check what happened? pwd gives us the answer!\n$ pwd\n/Users/sklucas\nIt turns out that cd without an argument will return you to your home directory, which is great if you’ve got lost in your own filesystem.\nLet’s try returning to the exercise-data directory from before. Last time, we used three commands, but we can actually string together the list of directories to move to exercise-data in one step:\n$ cd Desktop/shell-lesson-data/exercise-data\nCheck that we’ve moved to the right place by running pwd and ls -F.\nIf we want to move up one level from the data directory, we could use cd ... But there is another way to move to any directory, regardless of your current location.\nSo far, when specifying directory names, or even a directory path (as above), we have been using relative paths. When you use a relative path with a command like ls or cd, it tries to find that location from where we are, rather than from the root of the file system.\nHowever, it is possible to specify the absolute path to a directory by including its entire path from the root directory, which is indicated by a leading slash. The leading / tells the computer to follow the path from the root of the file system, so it always refers to exactly one directory, no matter where we are when we run the command.\nThis allows us to move to our shell-lesson-data directory from anywhere on the filesystem (including from inside exercise-data). To find the absolute path we’re looking for, we can use pwd and then extract the piece we need to move to shell-lesson-data.\n$ pwd\n/Users/sklucas/Desktop/shell-lesson-data/exercise-data\n$ cd /Users/sklucas/Desktop/shell-lesson-data\nRun pwd and ls -F to ensure that we’re in the directory we expect.\n\n\n\n\n\n\nTwo more shortcuts\n\n\n\nThe shell interprets a tilde (~) character at the start of a path to mean “the current user’s home directory”. For example, if your home directory is /Users/sklucas, then ~/data is equivalent to /Users/sklucas/data. This only works if it is the first character in the path; here/there/~/elsewhere is not here/there/Users/sklucas/elsewhere.\nAnother shortcut is the - (dash) character. cd will translate - into the previous directory I was in, which is faster than having to remember, then type, the full path. This is a very efficient way of moving back and forth between two directories – i.e. if you execute cd - twice, you end up back in the starting directory.\nThe difference between cd .. and cd - is that the former brings you up, while the latter brings you back.\n\nTry it!\nFirst navigate to ~/Desktop/shell-lesson-data (you should already be there).\n$ cd ~/Desktop/shell-lesson-data\nThen cd into the exercise-data/creatures directory\n$ cd exercise-data/creatures\nNow if you run\n$ cd -\nyou’ll see you’re back in ~/Desktop/shell-lesson-data. Run cd - again and you’re back in ~/Desktop/shell-lesson-data/exercise-data/creatures\n\n\n\n\nChallenge Questions\n\n\n\n\n\n\nQuestion 3: Absolute vs Relative Paths\n\n\n\nStarting from /Users/sklucas/data, which of the following commands could sklucas use to navigate to her home directory, which is /Users/sklucas?\n\ncd .\ncd /\ncd /home/sklucas\ncd ../..\ncd ~\ncd home\ncd ~/data/..\ncd\ncd ..\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: . stands for the current directory.\nNo: / stands for the root directory.\nNo: sklucas’s home directory is /Users/sklucas.\nNo: this command goes up two levels, i.e. ends in /Users.\nYes: ~ stands for the user’s home directory, in this case /Users/sklucas.\nNo: this command would navigate into a directory home in the current directory if it exists.\nYes: unnecessarily complicated, but correct.\nYes: shortcut to go back to the user’s home directory.\nYes: goes up one level.\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 4: Relative Path Resolution\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/thing, what will ls -F ../backup display?\n\n\n../backup: No such file or directory\n2012-12-01 2013-01-08 2013-01-27\n2012-12-01/ 2013-01-08/ 2013-01-27/\noriginal/ pnas_final/ pnas_sub/\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: there is a directory backup in /Users.\nNo: this is the content of Users/thing/backup, but with .., we asked for one level further up.\nNo: see previous explanation.\nYes: ../backup/ refers to /Users/backup/.\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 4: ls reading comprehension\n\n\n\nUsing the filesystem diagram below, if pwd displays /Users/backup, and -r tells ls to display things in reverse order, what command(s) will result in the following output:\npnas_sub/ pnas_final/ original/\n\n\nls pwd\nls -r -F\nls -r -F /Users/backup\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo: pwd is not the name of a directory.\nYes: ls without directory argument lists files and directories in the current directory.\nYes: uses the absolute path explicitly.",
    "crumbs": [
      "Home",
      "Working in the Unix Shell"
    ]
  }
]